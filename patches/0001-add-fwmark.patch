From 3b5e27843f1b604ff9d9e8578d22bd03e4b6ba45 Mon Sep 17 00:00:00 2001
From: zhenglixin <lixin.zhenglx@gmail.com>
Date: Sat, 20 Sep 2025 20:27:52 +0800
Subject: [PATCH 1/2] add fwmark

---
 src/common.h |  1 +
 src/jconf.c  |  4 ++++
 src/jconf.h  |  1 +
 src/local.c  | 19 +++++++++++++++++++
 src/redir.c  | 23 +++++++++++++++++++++++
 src/tunnel.c | 19 +++++++++++++++++++
 src/utils.c  |  2 ++
 7 files changed, 69 insertions(+)

diff --git a/src/common.h b/src/common.h
index 14f1d8d..4d337b5 100644
--- a/src/common.h
+++ b/src/common.h
@@ -71,6 +71,7 @@ enum {
     GETOPT_VAL_MANAGER_ADDRESS,
     GETOPT_VAL_EXECUTABLE,
     GETOPT_VAL_WORKDIR,
+    GETOPT_VAL_FWMARK
 };
 
 #endif // _COMMON_H
diff --git a/src/jconf.c b/src/jconf.c
index 5adba34..1d87cec 100644
--- a/src/jconf.c
+++ b/src/jconf.c
@@ -351,6 +351,10 @@ read_jconf(const char *file)
                 conf.acl = to_string(value);
             } else if (strcmp(name, "manager_address") == 0) {
                 conf.manager_address = to_string(value);
+            } else if (strcmp(name, "fwmark") == 0) {
+                check_json_value_type(value, json_integer,
+                                      "invalid config file: option 'fwmark' must be an integer");
+                conf.fwmark = value->u.integer;
             }
         }
     } else {
diff --git a/src/jconf.h b/src/jconf.h
index 4bf7f5e..df7d0f3 100644
--- a/src/jconf.h
+++ b/src/jconf.h
@@ -86,6 +86,7 @@ typedef struct {
     char *workdir;
     char *acl;
     char *manager_address;
+    int fwmark;
 } jconf_t;
 
 jconf_t *read_jconf(const char *file);
diff --git a/src/local.c b/src/local.c
index de19a1d..c80aef4 100644
--- a/src/local.c
+++ b/src/local.c
@@ -79,6 +79,7 @@
 
 int verbose    = 0;
 int reuse_port = 0;
+int fwmark = 0;
 
 #ifdef __ANDROID__
 int vpn        = 0;
@@ -1280,6 +1281,9 @@ create_remote(listen_ctx_t *listener,
 #ifdef SO_NOSIGPIPE
     setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
 #endif
+#ifdef SO_MARK
+    setsockopt(remotefd, SOL_SOCKET, SO_MARK, &fwmark, sizeof(fwmark));
+#endif
 
     if (listener->mptcp > 1) {
         int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
@@ -1439,6 +1443,9 @@ main(int argc, char **argv)
         { "plugin-opts", required_argument, NULL, GETOPT_VAL_PLUGIN_OPTS },
         { "password",    required_argument, NULL, GETOPT_VAL_PASSWORD    },
         { "key",         required_argument, NULL, GETOPT_VAL_KEY         },
+#ifdef __linux__
+        { "fwmark",      required_argument, NULL, GETOPT_VAL_FWMARK      },
+#endif
         { "help",        no_argument,       NULL, GETOPT_VAL_HELP        },
         { NULL,          0,                 NULL, 0                      }
     };
@@ -1486,6 +1493,12 @@ main(int argc, char **argv)
         case GETOPT_VAL_REUSE_PORT:
             reuse_port = 1;
             break;
+#ifdef __linux__
+        case GETOPT_VAL_FWMARK:
+            fwmark = atoi(optarg);
+            LOGI("set FWMARK to %d", fwmark);
+            break;
+#endif
         case 's':
             if (remote_num < MAX_REMOTE_NUM) {
                 parse_addr(optarg, &remote_addr[remote_num++]);
@@ -1628,6 +1641,12 @@ main(int argc, char **argv)
         if (no_delay == 0) {
             no_delay = conf->no_delay;
         }
+        if (fwmark == 0) {
+            fwmark = conf->fwmark;
+        }
+        if (fwmark < 0) {
+            fwmark = 0;
+        }
 #ifdef HAVE_SETRLIMIT
         if (nofile == 0) {
             nofile = conf->nofile;
diff --git a/src/redir.c b/src/redir.c
index 0c33d76..9968a3f 100644
--- a/src/redir.c
+++ b/src/redir.c
@@ -89,6 +89,7 @@ static void close_and_free_server(EV_P_ server_t *server);
 
 int verbose    = 0;
 int reuse_port = 0;
+int fwmark = 0;
 
 static crypto_t *crypto;
 
@@ -769,6 +770,9 @@ accept_cb(EV_P_ ev_io *w, int revents)
 #ifdef SO_NOSIGPIPE
     setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
 #endif
+#ifdef SO_MARK
+    setsockopt(remotefd, SOL_SOCKET, SO_MARK, &fwmark, sizeof(fwmark));
+#endif
 
     // Enable TCP keepalive feature
     int keepAlive    = 1;
@@ -906,6 +910,9 @@ main(int argc, char **argv)
         { "no-delay",    no_argument,       NULL, GETOPT_VAL_NODELAY     },
         { "password",    required_argument, NULL, GETOPT_VAL_PASSWORD    },
         { "key",         required_argument, NULL, GETOPT_VAL_KEY         },
+#ifdef __linux__
+        { "fwmark",      required_argument, NULL, GETOPT_VAL_FWMARK      },
+#endif
         { "help",        no_argument,       NULL, GETOPT_VAL_HELP        },
         { NULL,          0,                 NULL, 0                      }
     };
@@ -944,6 +951,12 @@ main(int argc, char **argv)
         case GETOPT_VAL_REUSE_PORT:
             reuse_port = 1;
             break;
+#ifdef __linux__
+        case GETOPT_VAL_FWMARK:
+            fwmark = atoi(optarg);
+            LOGI("set FWMARK to %d", fwmark);
+            break;
+#endif
         case 's':
             if (remote_num < MAX_REMOTE_NUM) {
                 parse_addr(optarg, &remote_addr[remote_num++]);
@@ -1082,6 +1095,12 @@ main(int argc, char **argv)
         if (fast_open == 0) {
             fast_open = conf->fast_open;
         }
+        if (fwmark == 0) {
+            fwmark = conf->fwmark;
+        }
+        if (fwmark < 0) {
+            fwmark = 0;
+        }
 #ifdef HAVE_SETRLIMIT
         if (nofile == 0) {
             nofile = conf->nofile;
@@ -1275,6 +1294,10 @@ main(int argc, char **argv)
             LOGI("TCP relay disabled");
         }
 
+        if (fwmark) {
+            LOGI("FWMARK of outbound is %d", fwmark);
+        }
+
         // Handle additionals TOS/DSCP listening ports
         if (dscp_num > 0) {
             listen_ctx_current      = (listen_ctx_t *)ss_malloc(sizeof(listen_ctx_t));
diff --git a/src/tunnel.c b/src/tunnel.c
index a928e61..ea95c6a 100644
--- a/src/tunnel.c
+++ b/src/tunnel.c
@@ -82,6 +82,7 @@ int vpn = 0;
 
 int verbose    = 0;
 int reuse_port = 0;
+int fwmark = 0;
 
 static crypto_t *crypto;
 
@@ -754,6 +755,9 @@ accept_cb(EV_P_ ev_io *w, int revents)
 #ifdef SO_NOSIGPIPE
     setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
 #endif
+#ifdef SO_MARK
+    setsockopt(remotefd, SOL_SOCKET, SO_MARK, &fwmark, sizeof(fwmark));
+#endif
 
     if (listener->mptcp > 1) {
         int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
@@ -900,6 +904,9 @@ main(int argc, char **argv)
         { "reuse-port",  no_argument,       NULL, GETOPT_VAL_REUSE_PORT  },
         { "password",    required_argument, NULL, GETOPT_VAL_PASSWORD    },
         { "key",         required_argument, NULL, GETOPT_VAL_KEY         },
+#ifdef __linux__
+        { "fwmark",      required_argument, NULL, GETOPT_VAL_FWMARK      },
+#endif
         { "help",        no_argument,       NULL, GETOPT_VAL_HELP        },
         { NULL,          0,                 NULL, 0                      }
     };
@@ -943,6 +950,12 @@ main(int argc, char **argv)
         case GETOPT_VAL_REUSE_PORT:
             reuse_port = 1;
             break;
+#ifdef __linux__
+        case GETOPT_VAL_FWMARK:
+            fwmark = atoi(optarg);
+            LOGI("set FWMARK to %d", fwmark);
+            break;;
+#endif
         case 's':
             if (remote_num < MAX_REMOTE_NUM) {
                 parse_addr(optarg, &remote_addr[remote_num++]);
@@ -1089,6 +1102,12 @@ main(int argc, char **argv)
         if (fast_open == 0) {
             fast_open = conf->fast_open;
         }
+        if (fwmark == 0) {
+            fwmark = conf->fwmark;
+        }
+        if (fwmark < 0) {
+            fwmark = 0;
+        }
 #ifdef HAVE_SETRLIMIT
         if (nofile == 0) {
             nofile = conf->nofile;
diff --git a/src/utils.c b/src/utils.c
index 0e94e5d..857f33b 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -406,6 +406,8 @@ usage()
 #ifdef __linux__
     printf(
         "       [--mptcp]                  Enable Multipath TCP on MPTCP Kernel.\n");
+    printf(
+        "       [--fwmark <FWMARK>]        FWMark of net packet.\n");
 #endif
 #ifndef MODULE_MANAGER
     printf(
-- 
2.37.1 (Apple Git-137.1)

