From 7ef3f48d8b3012e60b07432a8384e3f313e2dd33 Mon Sep 17 00:00:00 2001
From: zhenglixin <lixin.zhenglx@gmail.com>
Date: Tue, 23 Sep 2025 03:07:09 +0800
Subject: [PATCH 2/6] remove ss-local/ss-server/ss-tunnel

---
 README.md           |   35 +-
 doc/CMakeLists.txt  |   12 +-
 snap/snapcraft.yaml |   28 +-
 src/CMakeLists.txt  |  144 +--
 src/Makefile.am     |   78 +-
 src/acl.c           |  355 -------
 src/acl.h           |   40 -
 src/android.c       |  138 ---
 src/common.h        |   21 +-
 src/crypto.c        |    8 +-
 src/local.c         | 2195 --------------------------------------
 src/local.h         |  104 --
 src/manager.c       | 1292 -----------------------
 src/manager.h       |   80 --
 src/netutils.c      |    8 +-
 src/plugin.c        |   31 -
 src/plugin.h        |    3 -
 src/resolv.c        |  497 ---------
 src/resolv.h        |   46 -
 src/rule.c          |  133 ---
 src/rule.h          |   58 --
 src/server.c        | 2428 -------------------------------------------
 src/server.h        |  121 ---
 src/socks5.h        |   75 --
 src/stream.c        |    7 -
 src/tunnel.c        | 1449 --------------------------
 src/tunnel.h        |   91 --
 src/udprelay.c      |  529 +---------
 src/udprelay.h      |   26 -
 src/utils.c         |   77 --
 30 files changed, 18 insertions(+), 10091 deletions(-)
 delete mode 100644 src/acl.c
 delete mode 100644 src/acl.h
 delete mode 100644 src/android.c
 delete mode 100644 src/local.c
 delete mode 100644 src/local.h
 delete mode 100644 src/manager.c
 delete mode 100644 src/manager.h
 delete mode 100644 src/resolv.c
 delete mode 100644 src/resolv.h
 delete mode 100644 src/rule.c
 delete mode 100644 src/rule.h
 delete mode 100644 src/server.c
 delete mode 100644 src/server.h
 delete mode 100644 src/socks5.h
 delete mode 100644 src/tunnel.c
 delete mode 100644 src/tunnel.h

diff --git a/README.md b/README.md
index 8a874db..6741250 100644
--- a/README.md
+++ b/README.md
@@ -357,10 +357,7 @@ More information about the image can be found [here](docker/alpine/README.md).
 For a detailed and complete list of all supported arguments,
 you may refer to the man pages of the applications, respectively.
 
-    ss-[local|redir|server|tunnel|manager]
-
-       -s <server_host>           Host name or IP address of your remote server.
-
+    ss-redir -s <server_host> -p <server_port> -l <local_port> -k <password> -m <encrypt_method>
        -p <server_port>           Port number of your remote server.
 
        -l <local_port>            Port number of your local server.
@@ -388,17 +385,7 @@ you may refer to the man pages of the applications, respectively.
 
        [-n <number>]              Max number of open files.
 
-       [-i <interface>]           Network interface to bind.
-                                  (not available in redir mode)
-
        [-b <local_address>]       Local address to bind.
-                                  For servers: Specify the local address to use 
-                                  while this server is making outbound 
-                                  connections to remote servers on behalf of the
-                                  clients.
-                                  For clients: Specify the local address to use 
-                                  while this client is making outbound 
-                                  connections to the server.
 
        [-u]                       Enable UDP relay.
                                   (TPROXY is required in redir mode)
@@ -409,26 +396,12 @@ you may refer to the man pages of the applications, respectively.
        [-T]                       Use tproxy instead of redirect. (for tcp)
                                   (only available in redir mode)
 
-       [-L <addr>:<port>]         Destination server address and port
-                                  for local port forwarding.
-                                  (only available in tunnel mode)
-
        [-6]                       Resolve hostname to IPv6 address first.
 
-       [-d <addr>]                Name servers for internal DNS resolver.
-                                  (only available in server mode)
-
        [--reuse-port]             Enable port reuse.
 
        [--fast-open]              Enable TCP fast open.
                                   with Linux kernel > 3.7.0.
-                                  (only available in local and server mode)
-
-       [--acl <acl_file>]         Path to ACL (Access Control List).
-                                  (only available in local and server mode)
-
-       [--manager-address <addr>] UNIX domain socket address.
-                                  (only available in server and manager mode)
 
        [--mtu <MTU>]              MTU of your network interface.
 
@@ -436,12 +409,6 @@ you may refer to the man pages of the applications, respectively.
 
        [--no-delay]               Enable TCP_NODELAY.
 
-       [--executable <path>]      Path to the executable of ss-server.
-                                  (only available in manager mode)
-
-       [-D <path>]                Path to the working directory of ss-manager.
-                                  (only available in manager mode)
-
        [--key <key_in_base64>]    Key of your remote server.
 
        [--plugin <name>]          Enable SIP003 plugin. (Experimental)
diff --git a/doc/CMakeLists.txt b/doc/CMakeLists.txt
index 9abd455..8e320f3 100644
--- a/doc/CMakeLists.txt
+++ b/doc/CMakeLists.txt
@@ -14,14 +14,6 @@ else ()
     option(WITH_DOC_HTML "Build html doc" ON)
 endif ()
 
-# NOTE For brew user, we have to setup this env var. see `brew info asciidoc'
-set(XMLTO_ENV)
-set(XMLTO_CATALOG_DIR_MACOS /usr/local/etc/xml/catalog)
-if (EXISTS ${XMLTO_CATALOG_DIR_MACOS})
-    set(XMLTO_ENV XML_CATALOG_FILES=${XMLTO_CATALOG_DIR_MACOS})
-    message(STATUS "Detect xmlto catalog dir ${XMLTO_CATALOG_DIR_MACOS}")
-endif ()
-
 set(CMAKE_MANPAGE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/man)
 set(CMAKE_HTML_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/html)
 
@@ -31,7 +23,7 @@ set(ASCIIDOC_XML_OPTS -b docbook -d manpage -f ${DOC_DIR}/asciidoc.conf -aversio
 set(ASCIIDOC_HTML_OPTS -b html4 -d article -f ${DOC_DIR}/asciidoc.conf -aversion=${PROJECT_VERSION})
 
 
-set(MAN_NAMES ss-local.1 ss-manager.1 ss-nat.1 ss-redir.1 ss-server.1 ss-tunnel.1 shadowsocks-libev.8)
+set(MAN_NAMES ss-nat.1 ss-redir.1 shadowsocks-libev.8)
 set(MAN_FILES)
 set(HTML_FILES)
 
@@ -46,7 +38,7 @@ foreach (manfile IN LISTS MAN_NAMES)
 
     add_custom_command(OUTPUT ${manfile}
             COMMAND ${ASCIIDOC_EXECUTABLE} ${ASCIIDOC_XML_OPTS} -o ${xmlfile} ${docfile}
-            COMMAND ${CMAKE_COMMAND} -E env ${XMLTO_ENV} ${XMLTO_EXECUTABLE} ${XMLTO_OPTS} ${xmlfile}
+            COMMAND ${XMLTO_EXECUTABLE} ${XMLTO_OPTS} ${xmlfile}
             # After we built the manpage, the xmlfile is nolongger needed
             COMMAND ${CMAKE_COMMAND} -E remove ${xmlfile}
             DEPENDS ${docfile}
diff --git a/snap/snapcraft.yaml b/snap/snapcraft.yaml
index 49b687f..776fa1e 100644
--- a/snap/snapcraft.yaml
+++ b/snap/snapcraft.yaml
@@ -12,43 +12,17 @@ grade: stable
 confinement: strict
 
 apps:
-  ss-local:
-    command: bin/ss-local
-    plugs: [network, network-bind]
-
-  ss-local-daemon:
-    command: bin/ss-local
-    daemon: simple
-    plugs: [network, network-bind]
-
-  ss-server:
-    command: bin/ss-server
-    plugs: [network, network-bind]
-
-  ss-server-daemon:
-    command: bin/ss-server
-    daemon: simple
-    plugs: [network, network-bind]
-
   ss-redir:
     command: bin/ss-redir
     plugs: [network, network-bind]
 
-  ss-tunnel:
-    command: bin/ss-tunnel
-    plugs: [network, network-bind]
-
-  ss-manager:
-    command: bin/ss-manager
-    plugs: [network]
-
 passthrough:
   layout:
     /etc/shadowsocks-libev:
       bind: $SNAP_COMMON/etc/shadowsocks-libev
 
 parts:
- shadowsocks-libev:
+  shadowsocks-libev:
     plugin: autotools
     source: https://github.com/shadowsocks/shadowsocks-libev/releases/download/v3.3.5/shadowsocks-libev-3.3.5.tar.gz
     build-packages:
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 9ca9d85..65f44fb 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,29 +1,19 @@
 # redir need linux/* stuff
 if (LINUX)
     option(WITH_SS_REDIR "Build ss-redir" ON)
-    option(WITH_SS_MANAGER "Build ss-manager" ON)
 else ()
     option(WITH_SS_REDIR "Build ss-redir" OFF)
-    option(WITH_SS_MANAGER "Build ss-manager" OFF)
 endif ()
 
-
-set(SS_ACL_SOURCE
-        acl.c
-        rule.c
-        )
-
 set(SS_CRYPTO_SOURCE
         crypto.c
         aead.c
         stream.c
         base64.c
         )
-
 set(SS_PLUGIN_SOURCE
         plugin.c
         )
-
 set(SS_SHARED_SOURCES
         ppbloom.c
         utils.c
@@ -31,49 +21,6 @@ set(SS_SHARED_SOURCES
         json.c
         netutils.c
         )
-if (MINGW)
-set(SS_SHARED_SOURCES ${SS_SHARED_SOURCES} winsock.c)
-endif ()
-
-set(LIBSHADOWSOCKS_LIBEV_SOURCE
-        ${SS_SHARED_SOURCES}
-        udprelay.c
-        cache.c
-        local.c
-        ${SS_CRYPTO_SOURCE}
-        ${SS_PLUGIN_SOURCE}
-        ${SS_ACL_SOURCE}
-        )
-
-set(SS_LOCAL_SOURCE
-        ${LIBSHADOWSOCKS_LIBEV_SOURCE}
-
-        )
-
-set(SS_TUNNEL_SOURCE
-        ${SS_SHARED_SOURCES}
-        udprelay.c
-        cache.c
-        tunnel.c
-        ${SS_CRYPTO_SOURCE}
-        ${SS_PLUGIN_SOURCE}
-        )
-
-set(SS_SERVER_SOURCE
-        ${SS_SHARED_SOURCES}
-        udprelay.c
-        cache.c
-        resolv.c
-        server.c
-        ${SS_CRYPTO_SOURCE}
-        ${SS_PLUGIN_SOURCE}
-        ${SS_ACL_SOURCE}
-        )
-
-set(SS_MANAGER_SOURCE
-        ${SS_SHARED_SOURCES}
-        manager.c
-        )
 
 set(SS_REDIR_SOURCE
         ${SS_SHARED_SOURCES}
@@ -84,18 +31,6 @@ set(SS_REDIR_SOURCE
         ${SS_PLUGIN_SOURCE}
         )
 
-if (CMAKE_SYSTEM_NAME STREQUAL Darwin)
-find_path(LIBSODIUM_INCLUDE_DIR sodium.h
-        PATHS
-        $ENV{LIBSODIUM_INCLUDE_DIR}
-        $ENV{LIBSODIUM_DIR}/include
-        /usr/local/libsodium/include
-        /opt/libsodium/include
-        /usr/local/include
-)
-include_directories(${LIBSODIUM_INCLUDE_DIR})
-endif ()
-
 if (WITH_STATIC)
 find_library(LIBSODIUM libsodium.a)
 find_library(LIBMBEDTLS libmbedtls.a)
@@ -115,11 +50,6 @@ list(APPEND DEPS
         ${LIBMBEDTLS}
         ${LIBMBEDCRYPTO}
         )
-
-if (MINGW)
-list(APPEND DEPS ws2_32 iphlpapi)
-add_compile_definitions(CARES_STATICLIB PCRE_STATIC)
-endif ()
 endif ()
 
 find_library(LIBSODIUM_SHARED sodium)
@@ -165,91 +95,33 @@ find_package (Threads)
 if (WITH_STATIC)
 # ------------------------------------------------------------------
 # Static
-# By default we use normal name for static, all shared targets will add a `-shared' suffix
-add_executable(ss-server ${SS_SERVER_SOURCE})
-add_executable(ss-tunnel ${SS_TUNNEL_SOURCE})
-if (WITH_SS_MANAGER)
-    add_executable(ss-manager ${SS_MANAGER_SOURCE})
-else ()
-    add_executable(ss-manager EXCLUDE_FROM_ALL ${SS_MANAGER_SOURCE})
-endif ()
-add_executable(ss-local ${SS_LOCAL_SOURCE})
 if (WITH_SS_REDIR)
     add_executable(ss-redir ${SS_REDIR_SOURCE})
 else ()
     add_executable(ss-redir EXCLUDE_FROM_ALL ${SS_REDIR_SOURCE})
 endif ()
-add_library(shadowsocks-libev STATIC ${LIBSHADOWSOCKS_LIBEV_SOURCE})
-
 
-target_compile_definitions(ss-server PUBLIC -DMODULE_REMOTE)
-target_compile_definitions(ss-tunnel PUBLIC -DMODULE_TUNNEL)
-target_compile_definitions(ss-manager PUBLIC -DMODULE_MANAGER)
-target_compile_definitions(ss-local PUBLIC -DMODULE_LOCAL)
-target_compile_definitions(ss-redir PUBLIC -DMODULE_REDIR)
-target_compile_definitions(shadowsocks-libev PUBLIC -DMODULE_LOCAL -DLIB_ONLY)
-
-target_include_directories(shadowsocks-libev PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
-
-target_link_libraries(ss-server cork ipset ${DEPS})
-target_link_libraries(ss-tunnel cork ${DEPS})
-target_link_libraries(ss-manager m bloom cork ${LIBEV} ${LIBUDNS})
-target_link_libraries(ss-local cork ipset ${DEPS})
+target_compile_definitions(ss-redir PUBLIC)
 target_link_libraries(ss-redir cork ipset ${DEPS})
-target_link_libraries(shadowsocks-libev cork ipset ${DEPS})
 endif ()
 
 # ------------------------------------------------------------------
 # Shared
-# Shared target will have a `-shared' suffix
-# All shared dependency also have `-shared' suffix
-# For shared binary, we still use the same name as static, without `-shared', but will output to shared directory
-add_executable(ss-server-shared ${SS_SERVER_SOURCE})
-add_executable(ss-tunnel-shared ${SS_TUNNEL_SOURCE})
-if (WITH_SS_MANAGER)
-    add_executable(ss-manager-shared ${SS_MANAGER_SOURCE})
-else ()
-    add_executable(ss-manager-shared EXCLUDE_FROM_ALL ${SS_MANAGER_SOURCE})
-endif ()
-add_executable(ss-local-shared ${SS_LOCAL_SOURCE})
 if (WITH_SS_REDIR)
     add_executable(ss-redir-shared ${SS_REDIR_SOURCE})
 else ()
     add_executable(ss-redir-shared EXCLUDE_FROM_ALL ${SS_REDIR_SOURCE})
 endif ()
-add_library(shadowsocks-libev-shared SHARED ${LIBSHADOWSOCKS_LIBEV_SOURCE})
 
-target_compile_definitions(ss-server-shared PUBLIC -DMODULE_REMOTE)
-target_compile_definitions(ss-tunnel-shared PUBLIC -DMODULE_TUNNEL)
-target_compile_definitions(ss-manager-shared PUBLIC -DMODULE_MANAGER)
-target_compile_definitions(ss-local-shared PUBLIC -DMODULE_LOCAL)
-target_compile_definitions(ss-redir-shared PUBLIC -DMODULE_REDIR)
-target_compile_definitions(shadowsocks-libev-shared PUBLIC -DMODULE_LOCAL -DLIB_ONLY)
-
-target_include_directories(shadowsocks-libev-shared PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
-
-target_link_libraries(ss-server-shared ${DEPS_SHARED})
-target_link_libraries(ss-tunnel-shared ${DEPS_SHARED})
-target_link_libraries(ss-manager-shared ${CMAKE_THREAD_LIBS_INIT} ${LIBEV_SHARED} ${LIBUDNS_SHARED} ${DEPS_SHARED})
-target_link_libraries(ss-local-shared ${DEPS_SHARED})
+target_compile_definitions(ss-redir-shared PUBLIC)
 target_link_libraries(ss-redir-shared ${DEPS_SHARED})
-target_link_libraries(shadowsocks-libev-shared ${DEPS_SHARED})
-
-set_target_properties(ss-server-shared PROPERTIES OUTPUT_NAME ss-server)
-set_target_properties(ss-tunnel-shared PROPERTIES OUTPUT_NAME ss-tunnel)
-set_target_properties(ss-manager-shared PROPERTIES OUTPUT_NAME ss-manager)
-set_target_properties(ss-local-shared PROPERTIES OUTPUT_NAME ss-local)
 set_target_properties(ss-redir-shared PROPERTIES OUTPUT_NAME ss-redir)
 
-set_target_properties(ss-server-shared ss-tunnel-shared ss-manager-shared ss-local-shared ss-redir-shared
+set_target_properties(ss-redir-shared
         PROPERTIES
         RUNTIME_OUTPUT_DIRECTORY ${RUNTIME_SHARED_OUTPUT_DIRECTORY}
         )
 
-set_target_properties(shadowsocks-libev-shared PROPERTIES OUTPUT_NAME shadowsocks-libev)
-target_compile_definitions(shadowsocks-libev-shared PUBLIC -DMODULE_LOCAL)
-target_link_libraries(shadowsocks-libev-shared ${DEPS_SHARED})
-
 # ------------------------------------------------------------------
 # Misc
 # Recommend to install shared by default
@@ -257,16 +129,6 @@ install(DIRECTORY ${RUNTIME_SHARED_OUTPUT_DIRECTORY}/
         USE_SOURCE_PERMISSIONS
         DESTINATION bin)
 
-if (WITH_STATIC)
-    install(TARGETS shadowsocks-libev
-        ARCHIVE DESTINATION lib)
-endif ()
-
-install(TARGETS shadowsocks-libev-shared
-        LIBRARY DESTINATION lib)
-
-install(FILES shadowsocks.h DESTINATION include)
-
 
 add_custom_target(distclean
         COMMAND ${CMAKE_COMMAND} -E echo WARNING: distclean target is not functional
diff --git a/src/Makefile.am b/src/Makefile.am
index c255b60..995f1cd 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -19,14 +19,6 @@ SS_COMMON_LIBS += -lbloom -lcork -lcorkipset
 endif
 SS_COMMON_LIBS += -lev -lsodium -lm
 
-bin_PROGRAMS = ss-local ss-tunnel ss-server
-if !BUILD_WINCOMPAT
-bin_PROGRAMS += ss-manager
-endif
-
-acl_src = rule.c \
-          acl.c
-
 crypto_src = crypto.c \
              aead.c \
              stream.c \
@@ -35,58 +27,7 @@ crypto_src = crypto.c \
 
 plugin_src = plugin.c
 
-common_src = utils.c \
-             jconf.c \
-             json.c \
-             udprelay.c \
-             cache.c \
-             netutils.c
-
-if BUILD_WINCOMPAT
-common_src += winsock.c
-endif
-
-ss_local_SOURCES = local.c \
-                   $(common_src) \
-                   $(crypto_src) \
-                   $(plugin_src) \
-                   $(acl_src)
-
-ss_tunnel_SOURCES = tunnel.c \
-                    $(common_src) \
-                    $(crypto_src) \
-                    $(plugin_src)
-
-ss_server_SOURCES = resolv.c \
-                    server.c \
-                    $(common_src) \
-                    $(crypto_src) \
-                    $(plugin_src) \
-                    ${acl_src}
-
-ss_manager_SOURCES = utils.c \
-                     jconf.c \
-                     json.c \
-                     netutils.c \
-                     manager.c
-
-ss_local_LDADD = $(SS_COMMON_LIBS)
-ss_tunnel_LDADD = $(SS_COMMON_LIBS)
-ss_server_LDADD = $(SS_COMMON_LIBS)
-ss_manager_LDADD = $(SS_COMMON_LIBS)
-ss_local_LDADD += -lcares
-ss_tunnel_LDADD += -lcares
-ss_server_LDADD += -lcares
-ss_manager_LDADD += -lcares
-
-ss_local_CFLAGS = $(AM_CFLAGS) -DMODULE_LOCAL
-ss_tunnel_CFLAGS = $(AM_CFLAGS) -DMODULE_TUNNEL
-ss_server_CFLAGS = $(AM_CFLAGS) -DMODULE_REMOTE
-ss_manager_CFLAGS = $(AM_CFLAGS) -DMODULE_MANAGER
-
-if BUILD_REDIRECTOR
-bin_SCRIPTS = ss-nat
-bin_PROGRAMS += ss-redir
+bin_PROGRAMS = ss-redir
 ss_redir_SOURCES = utils.c \
                    jconf.c \
                    json.c \
@@ -97,19 +38,10 @@ ss_redir_SOURCES = utils.c \
                    $(crypto_src) \
                    $(plugin_src)
 
-ss_redir_CFLAGS = $(AM_CFLAGS) -DMODULE_REDIR
+ss_redir_CFLAGS = $(AM_CFLAGS)
 ss_redir_LDADD = $(SS_COMMON_LIBS)
 ss_redir_LDADD += -lcares
-endif
-
-lib_LTLIBRARIES = libshadowsocks-libev.la
-libshadowsocks_libev_la_SOURCES = $(ss_local_SOURCES)
-libshadowsocks_libev_la_CFLAGS = $(ss_local_CFLAGS) -DLIB_ONLY
-libshadowsocks_libev_la_LDFLAGS = -version-info $(VERSION_INFO)
-libshadowsocks_libev_la_LIBADD = $(ss_local_LDADD)
-include_HEADERS = shadowsocks.h
 
-noinst_HEADERS = acl.h crypto.h stream.h aead.h json.h netutils.h redir.h server.h uthash.h \
-                 cache.h local.h plugin.h resolv.h tunnel.h utils.h base64.h ppbloom.h \
-                 common.h jconf.h manager.h rule.h socks5.h udprelay.h winsock.h
-EXTRA_DIST = ss-nat
+noinst_HEADERS = crypto.h stream.h aead.h json.h netutils.h redir.h uthash.h \
+                 cache.h plugin.h utils.h base64.h ppbloom.h \
+                 common.h jconf.h udprelay.h
diff --git a/src/acl.c b/src/acl.c
deleted file mode 100644
index 1efc1aa..0000000
--- a/src/acl.c
+++ /dev/null
@@ -1,355 +0,0 @@
-/*
- * acl.c - Manage the ACL (Access Control List)
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <ctype.h>
-
-#ifdef USE_SYSTEM_SHARED_LIB
-#include <libcorkipset/ipset.h>
-#else
-#include <ipset/ipset.h>
-#endif
-
-#include "rule.h"
-#include "netutils.h"
-#include "utils.h"
-#include "cache.h"
-#include "acl.h"
-
-static struct ip_set white_list_ipv4;
-static struct ip_set white_list_ipv6;
-
-static struct ip_set black_list_ipv4;
-static struct ip_set black_list_ipv6;
-
-static struct cork_dllist black_list_rules;
-static struct cork_dllist white_list_rules;
-
-static int acl_mode = BLACK_LIST;
-
-static struct ip_set outbound_block_list_ipv4;
-static struct ip_set outbound_block_list_ipv6;
-static struct cork_dllist outbound_block_list_rules;
-
-static void
-parse_addr_cidr(const char *str, char *host, int *cidr)
-{
-    int ret = -1;
-    char *pch;
-
-    pch = strchr(str, '/');
-    while (pch != NULL) {
-        ret = pch - str;
-        pch = strchr(pch + 1, '/');
-    }
-    if (ret == -1) {
-        strcpy(host, str);
-        *cidr = -1;
-    } else {
-        memcpy(host, str, ret);
-        host[ret] = '\0';
-        *cidr     = atoi(str + ret + 1);
-    }
-}
-
-char *
-trimwhitespace(char *str)
-{
-    char *end;
-
-    // Trim leading space
-    while (isspace((unsigned char)*str))
-        str++;
-
-    if (*str == 0)   // All spaces?
-        return str;
-
-    // Trim trailing space
-    end = str + strlen(str) - 1;
-    while (end > str && isspace((unsigned char)*end))
-        end--;
-
-    // Write new null terminator
-    *(end + 1) = 0;
-
-    return str;
-}
-
-int
-init_acl(const char *path)
-{
-    if (path == NULL) {
-        return -1;
-    }
-
-    // initialize ipset
-    ipset_init_library();
-
-    ipset_init(&white_list_ipv4);
-    ipset_init(&white_list_ipv6);
-    ipset_init(&black_list_ipv4);
-    ipset_init(&black_list_ipv6);
-    ipset_init(&outbound_block_list_ipv4);
-    ipset_init(&outbound_block_list_ipv6);
-
-    cork_dllist_init(&black_list_rules);
-    cork_dllist_init(&white_list_rules);
-    cork_dllist_init(&outbound_block_list_rules);
-
-    struct ip_set *list_ipv4  = &black_list_ipv4;
-    struct ip_set *list_ipv6  = &black_list_ipv6;
-    struct cork_dllist *rules = &black_list_rules;
-
-    FILE *f = fopen(path, "r");
-    if (f == NULL) {
-        LOGE("Invalid acl path.");
-        return -1;
-    }
-
-    char buf[MAX_HOSTNAME_LEN];
-
-    while (!feof(f))
-        if (fgets(buf, 256, f)) {
-            // Discards the whole line if longer than 255 characters
-            int long_line = 0;  // 1: Long  2: Error
-            while ((strlen(buf) == 255) && (buf[254] != '\n')) {
-                long_line = 1;
-                LOGE("Discarding long ACL content: %s", buf);
-                if (fgets(buf, 256, f) == NULL) {
-                    long_line = 2;
-                    break;
-                }
-            }
-            if (long_line) {
-                if (long_line == 1) {
-                    LOGE("Discarding long ACL content: %s", buf);
-                }
-                continue;
-            }
-
-            // Trim the newline
-            int len = strlen(buf);
-            if (len > 0 && buf[len - 1] == '\n') {
-                buf[len - 1] = '\0';
-            }
-
-            char *comment = strchr(buf, '#');
-            if (comment) {
-                *comment = '\0';
-            }
-
-            char *line = trimwhitespace(buf);
-            if (strlen(line) == 0) {
-                continue;
-            }
-
-            if (strcmp(line, "[outbound_block_list]") == 0) {
-                list_ipv4 = &outbound_block_list_ipv4;
-                list_ipv6 = &outbound_block_list_ipv6;
-                rules     = &outbound_block_list_rules;
-                continue;
-            } else if (strcmp(line, "[black_list]") == 0
-                       || strcmp(line, "[bypass_list]") == 0) {
-                list_ipv4 = &black_list_ipv4;
-                list_ipv6 = &black_list_ipv6;
-                rules     = &black_list_rules;
-                continue;
-            } else if (strcmp(line, "[white_list]") == 0
-                       || strcmp(line, "[proxy_list]") == 0) {
-                list_ipv4 = &white_list_ipv4;
-                list_ipv6 = &white_list_ipv6;
-                rules     = &white_list_rules;
-                continue;
-            } else if (strcmp(line, "[reject_all]") == 0
-                       || strcmp(line, "[bypass_all]") == 0) {
-                acl_mode = WHITE_LIST;
-                continue;
-            } else if (strcmp(line, "[accept_all]") == 0
-                       || strcmp(line, "[proxy_all]") == 0) {
-                acl_mode = BLACK_LIST;
-                continue;
-            }
-
-            char host[MAX_HOSTNAME_LEN];
-            int cidr;
-            parse_addr_cidr(line, host, &cidr);
-
-            struct cork_ip addr;
-            int err = cork_ip_init(&addr, host);
-            if (!err) {
-                if (addr.version == 4) {
-                    if (cidr >= 0) {
-                        ipset_ipv4_add_network(list_ipv4, &(addr.ip.v4), cidr);
-                    } else {
-                        ipset_ipv4_add(list_ipv4, &(addr.ip.v4));
-                    }
-                } else if (addr.version == 6) {
-                    if (cidr >= 0) {
-                        ipset_ipv6_add_network(list_ipv6, &(addr.ip.v6), cidr);
-                    } else {
-                        ipset_ipv6_add(list_ipv6, &(addr.ip.v6));
-                    }
-                }
-            } else {
-                rule_t *rule = new_rule();
-                accept_rule_arg(rule, line);
-                init_rule(rule);
-                add_rule(rules, rule);
-            }
-        }
-
-    fclose(f);
-
-    return 0;
-}
-
-void
-free_rules(struct cork_dllist *rules)
-{
-    struct cork_dllist_item *iter;
-    while ((iter = cork_dllist_head(rules)) != NULL) {
-        rule_t *rule = cork_container_of(iter, rule_t, entries);
-        remove_rule(rule);
-    }
-}
-
-void
-free_acl(void)
-{
-    ipset_done(&black_list_ipv4);
-    ipset_done(&black_list_ipv6);
-    ipset_done(&white_list_ipv4);
-    ipset_done(&white_list_ipv6);
-
-    free_rules(&black_list_rules);
-    free_rules(&white_list_rules);
-}
-
-int
-get_acl_mode(void)
-{
-    return acl_mode;
-}
-
-/*
- * Return 0,  if not match.
- * Return 1,  if match black list.
- * Return -1, if match white list.
- */
-int
-acl_match_host(const char *host)
-{
-    struct cork_ip addr;
-    int ret = 0;
-    int err = cork_ip_init(&addr, host);
-
-    if (err) {
-        int host_len = strlen(host);
-        if (lookup_rule(&black_list_rules, host, host_len) != NULL)
-            ret = 1;
-        else if (lookup_rule(&white_list_rules, host, host_len) != NULL)
-            ret = -1;
-        return ret;
-    }
-
-    if (addr.version == 4) {
-        if (ipset_contains_ipv4(&black_list_ipv4, &(addr.ip.v4)))
-            ret = 1;
-        else if (ipset_contains_ipv4(&white_list_ipv4, &(addr.ip.v4)))
-            ret = -1;
-    } else if (addr.version == 6) {
-        if (ipset_contains_ipv6(&black_list_ipv6, &(addr.ip.v6)))
-            ret = 1;
-        else if (ipset_contains_ipv6(&white_list_ipv6, &(addr.ip.v6)))
-            ret = -1;
-    }
-
-    return ret;
-}
-
-int
-acl_add_ip(const char *ip)
-{
-    struct cork_ip addr;
-    int err = cork_ip_init(&addr, ip);
-    if (err) {
-        return -1;
-    }
-
-    if (addr.version == 4) {
-        ipset_ipv4_add(&black_list_ipv4, &(addr.ip.v4));
-    } else if (addr.version == 6) {
-        ipset_ipv6_add(&black_list_ipv6, &(addr.ip.v6));
-    }
-
-    return 0;
-}
-
-int
-acl_remove_ip(const char *ip)
-{
-    struct cork_ip addr;
-    int err = cork_ip_init(&addr, ip);
-    if (err) {
-        return -1;
-    }
-
-    if (addr.version == 4) {
-        ipset_ipv4_remove(&black_list_ipv4, &(addr.ip.v4));
-    } else if (addr.version == 6) {
-        ipset_ipv6_remove(&black_list_ipv6, &(addr.ip.v6));
-    }
-
-    return 0;
-}
-
-/*
- * Return 0,  if not match.
- * Return 1,  if match black list.
- */
-int
-outbound_block_match_host(const char *host)
-{
-    struct cork_ip addr;
-    int ret = 0;
-    int err = cork_ip_init(&addr, host);
-
-    if (err) {
-        int host_len = strlen(host);
-        if (lookup_rule(&outbound_block_list_rules, host, host_len) != NULL)
-            ret = 1;
-        return ret;
-    }
-
-    if (addr.version == 4) {
-        if (ipset_contains_ipv4(&outbound_block_list_ipv4, &(addr.ip.v4)))
-            ret = 1;
-    } else if (addr.version == 6) {
-        if (ipset_contains_ipv6(&outbound_block_list_ipv6, &(addr.ip.v6)))
-            ret = 1;
-    }
-
-    return ret;
-}
diff --git a/src/acl.h b/src/acl.h
deleted file mode 100644
index 197027c..0000000
--- a/src/acl.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * acl.h - Define the ACL interface
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _ACL_H
-#define _ACL_H
-
-#define BLACK_LIST 0
-#define WHITE_LIST 1
-
-int init_acl(const char *path);
-void free_acl(void);
-
-int acl_match_host(const char *ip);
-int acl_add_ip(const char *ip);
-int acl_remove_ip(const char *ip);
-
-int get_acl_mode(void);
-
-int outbound_block_match_host(const char *host);
-
-#endif // _ACL_H
diff --git a/src/android.c b/src/android.c
deleted file mode 100644
index 5b6db3d..0000000
--- a/src/android.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * android.c - Setup IPC for shadowsocks-android
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <locale.h>
-#include <signal.h>
-#include <string.h>
-#include <strings.h>
-#include <unistd.h>
-
-#include <errno.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-
-#include <sys/un.h>
-#include <ancillary.h>
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "netutils.h"
-#include "utils.h"
-
-int
-protect_socket(int fd)
-{
-    int sock;
-    struct sockaddr_un addr;
-
-    if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-        LOGE("[android] socket() failed: %s (socket fd = %d)\n", strerror(errno), sock);
-        return -1;
-    }
-
-    // Set timeout to 3s
-    struct timeval tv;
-    tv.tv_sec  = 3;
-    tv.tv_usec = 0;
-    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(struct timeval));
-    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(struct timeval));
-
-    memset(&addr, 0, sizeof(addr));
-    addr.sun_family = AF_UNIX;
-    strncpy(addr.sun_path, "protect_path", sizeof(addr.sun_path) - 1);
-
-    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
-        LOGE("[android] connect() failed for protect_path: %s (socket fd = %d)\n",
-             strerror(errno), sock);
-        close(sock);
-        return -1;
-    }
-
-    if (ancil_send_fd(sock, fd)) {
-        ERROR("[android] ancil_send_fd");
-        close(sock);
-        return -1;
-    }
-
-    char ret = 0;
-
-    if (recv(sock, &ret, 1, 0) == -1) {
-        ERROR("[android] recv");
-        close(sock);
-        return -1;
-    }
-
-    close(sock);
-    return ret;
-}
-
-extern char *stat_path;
-
-int
-send_traffic_stat(uint64_t tx, uint64_t rx)
-{
-    if (!stat_path)
-        return 0;
-    int sock;
-    struct sockaddr_un addr;
-
-    if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-        LOGE("[android] socket() failed: %s (socket fd = %d)\n", strerror(errno), sock);
-        return -1;
-    }
-
-    // Set timeout to 1s
-    struct timeval tv;
-    tv.tv_sec  = 1;
-    tv.tv_usec = 0;
-    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(struct timeval));
-    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(struct timeval));
-
-    memset(&addr, 0, sizeof(addr));
-    addr.sun_family = AF_UNIX;
-    strncpy(addr.sun_path, stat_path, sizeof(addr.sun_path) - 1);
-
-    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
-        LOGE("[android] connect() failed for stat_path: %s (socket fd = %d)\n",
-             strerror(errno), sock);
-        close(sock);
-        return -1;
-    }
-
-    uint64_t stat[2] = { tx, rx };
-
-    if (send(sock, stat, sizeof(stat), 0) == -1) {
-        ERROR("[android] send");
-        close(sock);
-        return -1;
-    }
-
-    close(sock);
-    return 0;
-}
diff --git a/src/common.h b/src/common.h
index 66e985c..d642fd0 100644
--- a/src/common.h
+++ b/src/common.h
@@ -26,28 +26,14 @@
 #define SOL_TCP IPPROTO_TCP
 #endif
 
-#if defined(MODULE_TUNNEL) || defined(MODULE_REDIR)
-#define MODULE_LOCAL
-#endif
-
 #include "crypto.h"
 
 int init_udprelay(const char *server_host, const char *server_port,
-#ifdef MODULE_LOCAL
                   const struct sockaddr *remote_addr, const int remote_addr_len,
-#ifdef MODULE_TUNNEL
-                  const ss_addr_t tunnel_addr,
-#endif
-#endif
                   int mtu, crypto_t *crypto, int timeout, const char *iface);
 
 void free_udprelay(void);
 
-#ifdef __ANDROID__
-int protect_socket(int fd);
-int send_traffic_stat(uint64_t tx, uint64_t rx);
-#endif
-
 #define STAGE_ERROR     -1  /* Error detected                   */
 #define STAGE_INIT       0  /* Initial stage                    */
 #define STAGE_HANDSHAKE  1  /* Handshake with client            */
@@ -61,21 +47,16 @@ enum {
     GETOPT_VAL_REUSE_PORT,
     GETOPT_VAL_FAST_OPEN,
     GETOPT_VAL_NODELAY,
-    GETOPT_VAL_ACL,
     GETOPT_VAL_MTU,
     GETOPT_VAL_MPTCP,
     GETOPT_VAL_PLUGIN,
     GETOPT_VAL_PLUGIN_OPTS,
     GETOPT_VAL_PASSWORD,
     GETOPT_VAL_KEY,
-    GETOPT_VAL_MANAGER_ADDRESS,
-    GETOPT_VAL_EXECUTABLE,
-    GETOPT_VAL_WORKDIR,
     GETOPT_VAL_TCP_INCOMING_SNDBUF,
     GETOPT_VAL_TCP_INCOMING_RCVBUF,
     GETOPT_VAL_TCP_OUTGOING_SNDBUF,
-    GETOPT_VAL_TCP_OUTGOING_RCVBUF,
-    GETOPT_VAL_NFTABLES_SETS
+    GETOPT_VAL_TCP_OUTGOING_RCVBUF
 };
 
 #endif // _COMMON_H
diff --git a/src/crypto.c b/src/crypto.c
index 76c426b..d8a554e 100644
--- a/src/crypto.c
+++ b/src/crypto.c
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#if defined(__linux__) && defined(HAVE_LINUX_RANDOM_H)
+#if defined(HAVE_LINUX_RANDOM_H)
 #include <fcntl.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
@@ -115,7 +115,7 @@ crypto_md5(const unsigned char *d, size_t n, unsigned char *md)
 static void
 entropy_check(void)
 {
-#if defined(__linux__) && defined(HAVE_LINUX_RANDOM_H) && defined(RNDGETENTCNT)
+#if defined(HAVE_LINUX_RANDOM_H) && defined(RNDGETENTCNT)
     int fd;
     int c;
 
@@ -143,11 +143,7 @@ crypto_init(const char *password, const char *key, const char *method)
     }
 
     // Initialize NONCE bloom filter
-#ifdef MODULE_REMOTE
-    ppbloom_init(BF_NUM_ENTRIES_FOR_SERVER, BF_ERROR_RATE_FOR_SERVER);
-#else
     ppbloom_init(BF_NUM_ENTRIES_FOR_CLIENT, BF_ERROR_RATE_FOR_CLIENT);
-#endif
 
     if (method != NULL) {
         for (i = 0; i < STREAM_CIPHER_NUM; i++)
diff --git a/src/local.c b/src/local.c
deleted file mode 100644
index fa1ca7b..0000000
--- a/src/local.c
+++ /dev/null
@@ -1,2195 +0,0 @@
-/*
- * local.c - Setup a socks5 proxy through remote shadowsocks server
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <locale.h>
-#include <signal.h>
-#include <string.h>
-#include <strings.h>
-#include <unistd.h>
-#include <getopt.h>
-#ifndef __MINGW32__
-#include <errno.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#endif
-#ifdef LIB_ONLY
-#include "shadowsocks.h"
-#endif
-
-#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
-#include <net/if.h>
-#include <sys/ioctl.h>
-#define SET_INTERFACE
-#endif
-
-#include <libcork/core.h>
-
-#include "netutils.h"
-#include "utils.h"
-#include "socks5.h"
-#include "acl.h"
-#include "plugin.h"
-#include "local.h"
-#include "winsock.h"
-
-#ifndef LIB_ONLY
-#ifdef __APPLE__
-#include <AvailabilityMacros.h>
-#if defined(MAC_OS_X_VERSION_10_10) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10
-#include <launch.h>
-#define HAVE_LAUNCHD
-#endif
-#endif
-#endif
-
-#ifndef EAGAIN
-#define EAGAIN EWOULDBLOCK
-#endif
-
-#ifndef EWOULDBLOCK
-#define EWOULDBLOCK EAGAIN
-#endif
-
-int verbose    = 0;
-int reuse_port = 0;
-int tcp_incoming_sndbuf = 0;
-int tcp_incoming_rcvbuf = 0;
-int tcp_outgoing_sndbuf = 0;
-int tcp_outgoing_rcvbuf = 0;
-
-#ifdef __ANDROID__
-int vpn        = 0;
-uint64_t tx    = 0;
-uint64_t rx    = 0;
-ev_tstamp last = 0;
-
-char *stat_path   = NULL;
-#endif
-
-static crypto_t *crypto;
-
-static int acl       = 0;
-static int mode      = TCP_ONLY;
-static int ipv6first = 0;
-int fast_open        = 0;
-static int no_delay  = 0;
-static int udp_fd    = 0;
-static int ret_val   = 0;
-
-static struct ev_signal sigint_watcher;
-static struct ev_signal sigterm_watcher;
-#ifndef __MINGW32__
-static struct ev_signal sigchld_watcher;
-static struct ev_signal sigusr1_watcher;
-#else
-#ifndef LIB_ONLY
-static struct plugin_watcher_t {
-    ev_io io;
-    SOCKET fd;
-    uint16_t port;
-    int valid;
-} plugin_watcher;
-#endif
-#endif
-
-#ifdef HAVE_SETRLIMIT
-#ifndef LIB_ONLY
-static int nofile = 0;
-#endif
-#endif
-
-static void server_recv_cb(EV_P_ ev_io *w, int revents);
-static void server_send_cb(EV_P_ ev_io *w, int revents);
-static void remote_recv_cb(EV_P_ ev_io *w, int revents);
-static void remote_send_cb(EV_P_ ev_io *w, int revents);
-static void accept_cb(EV_P_ ev_io *w, int revents);
-static void signal_cb(EV_P_ ev_signal *w, int revents);
-#if defined(__MINGW32__) && !defined(LIB_ONLY)
-static void plugin_watcher_cb(EV_P_ ev_io *w, int revents);
-#endif
-
-static int create_and_bind(const char *addr, const char *port);
-#ifdef HAVE_LAUNCHD
-static int launch_or_create(const char *addr, const char *port);
-#endif
-static remote_t *create_remote(listen_ctx_t *listener, struct sockaddr *addr, int direct);
-static void free_remote(remote_t *remote);
-static void close_and_free_remote(EV_P_ remote_t *remote);
-static void free_server(server_t *server);
-static void close_and_free_server(EV_P_ server_t *server);
-
-static remote_t *new_remote(int fd, int timeout);
-static server_t *new_server(int fd);
-
-static struct cork_dllist connections;
-
-#ifndef __MINGW32__
-int
-setnonblocking(int fd)
-{
-    int flags;
-    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
-        flags = 0;
-    }
-    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-}
-
-#endif
-
-int
-create_and_bind(const char *addr, const char *port)
-{
-    struct addrinfo hints;
-    struct addrinfo *result, *rp;
-    int s, listen_sock = -1;
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_family   = AF_UNSPEC;   /* Return IPv4 and IPv6 choices */
-    hints.ai_socktype = SOCK_STREAM; /* We want a TCP socket */
-    result            = NULL;
-
-    s = getaddrinfo(addr, port, &hints, &result);
-
-    if (s != 0) {
-        LOGI("getaddrinfo: %s", gai_strerror(s));
-        return -1;
-    }
-
-    if (result == NULL) {
-        LOGE("Could not bind");
-        return -1;
-    }
-
-    for (rp = result; rp != NULL; rp = rp->ai_next) {
-        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
-        if (listen_sock == -1) {
-            continue;
-        }
-
-        int opt = 1;
-        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-        if (reuse_port) {
-            int err = set_reuseport(listen_sock);
-            if (err == 0) {
-                LOGI("tcp port reuse enabled");
-            }
-        }
-
-        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);
-        if (s == 0) {
-            /* We managed to bind successfully! */
-            break;
-        } else {
-            ERROR("bind");
-        }
-
-        close(listen_sock);
-        listen_sock = -1;
-    }
-
-    freeaddrinfo(result);
-
-    return listen_sock;
-}
-
-#ifdef HAVE_LAUNCHD
-int
-launch_or_create(const char *addr, const char *port)
-{
-    int *fds;
-    size_t cnt;
-    int error = launch_activate_socket("Listeners", &fds, &cnt);
-    if (error == 0) {
-        if (cnt == 1) {
-            return fds[0];
-        } else {
-            FATAL("please don't specify multi entry");
-        }
-    } else if (error == ESRCH || error == ENOENT) {
-        /* ESRCH:  The calling process is not managed by launchd(8).
-         * ENOENT: The socket name specified does not exist
-         *          in the caller's launchd.plist(5).
-         */
-        if (port == NULL) {
-            usage();
-            exit(EXIT_FAILURE);
-        }
-        return create_and_bind(addr, port);
-    } else {
-        FATAL("launch_activate_socket() error");
-    }
-    return -1;
-}
-
-#endif
-
-static void
-free_connections(struct ev_loop *loop)
-{
-    struct cork_dllist_item *curr, *next;
-    cork_dllist_foreach_void(&connections, curr, next) {
-        server_t *server = cork_container_of(curr, server_t, entries);
-        remote_t *remote = server->remote;
-        close_and_free_server(loop, server);
-        close_and_free_remote(loop, remote);
-    }
-}
-
-static void
-delayed_connect_cb(EV_P_ ev_timer *watcher, int revents)
-{
-    server_t *server = cork_container_of(watcher, server_t,
-                                         delayed_connect_watcher);
-
-    server_recv_cb(EV_A_ & server->recv_ctx->io, revents);
-}
-
-static int
-server_handshake_reply(EV_P_ ev_io *w, int udp_assc, struct socks5_response *response)
-{
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
-    remote_t *remote              = server->remote;
-    if (server->stage != STAGE_HANDSHAKE)
-        return 0;
-
-    struct sockaddr_in sock_addr;
-    if (udp_assc) {
-        socklen_t addr_len = sizeof(sock_addr);
-        if (getsockname(server->fd, (struct sockaddr *)&sock_addr, &addr_len) < 0) {
-            LOGE("getsockname: %s", strerror(errno));
-            response->rep = SOCKS5_REP_CONN_REFUSED;
-            send(server->fd, (char *)response, sizeof(struct socks5_response), 0);
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return -1;
-        }
-    } else
-        memset(&sock_addr, 0, sizeof(sock_addr));
-
-    buffer_t resp_to_send;
-    buffer_t *resp_buf = &resp_to_send;
-    balloc(resp_buf, SOCKET_BUF_SIZE);
-
-    memcpy(resp_buf->data, response, sizeof(struct socks5_response));
-    memcpy(resp_buf->data + sizeof(struct socks5_response),
-           &sock_addr.sin_addr, sizeof(sock_addr.sin_addr));
-    memcpy(resp_buf->data + sizeof(struct socks5_response) +
-           sizeof(sock_addr.sin_addr),
-           &sock_addr.sin_port, sizeof(sock_addr.sin_port));
-
-    int reply_size = sizeof(struct socks5_response) +
-                     sizeof(sock_addr.sin_addr) + sizeof(sock_addr.sin_port);
-
-    int s = send(server->fd, resp_buf->data, reply_size, 0);
-
-    bfree(resp_buf);
-
-    if (s < reply_size) {
-        LOGE("failed to send fake reply");
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return -1;
-    }
-    if (udp_assc) {
-        // Wait until client closes the connection
-        return -1;
-    }
-    return 0;
-}
-
-static int
-server_handshake(EV_P_ ev_io *w, buffer_t *buf)
-{
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
-    remote_t *remote              = server->remote;
-
-    struct socks5_request *request = (struct socks5_request *)buf->data;
-    size_t request_len             = sizeof(struct socks5_request);
-
-    if (buf->len < request_len) {
-        return -1;
-    }
-
-    struct socks5_response response;
-    response.ver  = SVERSION;
-    response.rep  = SOCKS5_REP_SUCCEEDED;
-    response.rsv  = 0;
-    response.atyp = SOCKS5_ATYP_IPV4;
-
-    if (request->cmd == SOCKS5_CMD_UDP_ASSOCIATE) {
-        if (verbose) {
-            LOGI("udp assc request accepted");
-        }
-        return server_handshake_reply(EV_A_ w, 1, &response);
-    } else if (request->cmd != SOCKS5_CMD_CONNECT) {
-        LOGE("unsupported command: %d", request->cmd);
-        response.rep = SOCKS5_REP_CMD_NOT_SUPPORTED;
-        char *send_buf = (char *)&response;
-        send(server->fd, send_buf, 4, 0);
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return -1;
-    }
-
-    char host[MAX_HOSTNAME_LEN + 1], ip[INET6_ADDRSTRLEN], port[16];
-
-    buffer_t *abuf = server->abuf;
-    abuf->idx = 0;
-    abuf->len = 0;
-
-    abuf->data[abuf->len++] = request->atyp;
-    int atyp = request->atyp;
-
-    // get remote addr and port
-    if (atyp == SOCKS5_ATYP_IPV4) {
-        size_t in_addr_len = sizeof(struct in_addr);
-        if (buf->len < request_len + in_addr_len + 2) {
-            return -1;
-        }
-        memcpy(abuf->data + abuf->len, buf->data + request_len, in_addr_len + 2);
-        abuf->len += in_addr_len + 2;
-
-        if (acl || verbose) {
-            uint16_t p = load16_be(buf->data + request_len + in_addr_len);
-            if (!inet_ntop(AF_INET, (const void *)(buf->data + request_len),
-                           ip, INET_ADDRSTRLEN)) {
-                LOGI("inet_ntop(AF_INET): %s", strerror(errno));
-                ip[0] = '\0';
-            }
-            sprintf(port, "%d", p);
-        }
-    } else if (atyp == SOCKS5_ATYP_DOMAIN) {
-        uint8_t name_len = *(uint8_t *)(buf->data + request_len);
-        if (buf->len < request_len + 1 + name_len + 2) {
-            return -1;
-        }
-        abuf->data[abuf->len++] = name_len;
-        memcpy(abuf->data + abuf->len, buf->data + request_len + 1, name_len + 2);
-        abuf->len += name_len + 2;
-
-        if (acl || verbose) {
-            uint16_t p = load16_be(buf->data + request_len + 1 + name_len);
-            memcpy(host, buf->data + request_len + 1, name_len);
-            host[name_len] = '\0';
-            sprintf(port, "%d", p);
-        }
-    } else if (atyp == SOCKS5_ATYP_IPV6) {
-        size_t in6_addr_len = sizeof(struct in6_addr);
-        if (buf->len < request_len + in6_addr_len + 2) {
-            return -1;
-        }
-        memcpy(abuf->data + abuf->len, buf->data + request_len, in6_addr_len + 2);
-        abuf->len += in6_addr_len + 2;
-
-        if (acl || verbose) {
-            uint16_t p = load16_be(buf->data + request_len + in6_addr_len);
-            if (!inet_ntop(AF_INET6, (const void *)(buf->data + request_len),
-                           ip, INET6_ADDRSTRLEN)) {
-                LOGI("inet_ntop(AF_INET6): %s", strerror(errno));
-                ip[0] = '\0';
-            }
-            sprintf(port, "%d", p);
-        }
-    } else {
-        LOGE("unsupported addrtype: %d", request->atyp);
-        response.rep = SOCKS5_REP_ADDRTYPE_NOT_SUPPORTED;
-        char *send_buf = (char *)&response;
-        send(server->fd, send_buf, 4, 0);
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return -1;
-    }
-
-    if (server_handshake_reply(EV_A_ w, 0, &response) < 0)
-        return -1;
-    server->stage = STAGE_STREAM;
-
-    buf->len -= (3 + abuf->len);
-    if (buf->len > 0) {
-        memmove(buf->data, buf->data + 3 + abuf->len, buf->len);
-    }
-
-    if (verbose) {
-        if (atyp == SOCKS5_ATYP_DOMAIN)
-            LOGI("connect to %s:%s", host, port);
-        else if (atyp == SOCKS5_ATYP_IPV4)
-            LOGI("connect to %s:%s", ip, port);
-        else if (atyp == SOCKS5_ATYP_IPV6)
-            LOGI("connect to [%s]:%s", ip, port);
-    }
-
-    if (acl
-#ifdef __ANDROID__
-        && !(vpn && strcmp(port, "53") == 0)
-#endif
-        ) {
-        int bypass   = 0;
-        int resolved = 0;
-        struct sockaddr_storage storage;
-        memset(&storage, 0, sizeof(struct sockaddr_storage));
-        int err;
-
-        int host_match = 0;
-        if (atyp == SOCKS5_ATYP_DOMAIN)
-            host_match = acl_match_host(host);
-
-        if (host_match > 0)
-            bypass = 1;                             // bypass hostnames in black list
-        else if (host_match < 0)
-            bypass = 0;                             // proxy hostnames in white list
-        else {
-            if (atyp == SOCKS5_ATYP_DOMAIN
-#ifdef __ANDROID__
-                && !vpn
-#endif
-                ) {           // resolve domain so we can bypass domain with geoip
-                if (get_sockaddr(host, port, &storage, 0, ipv6first))
-                    goto not_bypass;
-                resolved = 1;
-                switch (((struct sockaddr *)&storage)->sa_family) {
-                case AF_INET:
-                {
-                    struct sockaddr_in *addr_in = (struct sockaddr_in *)&storage;
-                    if (!inet_ntop(AF_INET, &(addr_in->sin_addr), ip, INET_ADDRSTRLEN))
-                        goto not_bypass;
-                    break;
-                }
-                case AF_INET6:
-                {
-                    struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)&storage;
-                    if (!inet_ntop(AF_INET6, &(addr_in6->sin6_addr), ip, INET6_ADDRSTRLEN))
-                        goto not_bypass;
-                    break;
-                }
-                default:
-                    goto not_bypass;
-                }
-            }
-
-            int ip_match = (resolved || atyp == SOCKS5_ATYP_IPV4
-                            || atyp == SOCKS5_ATYP_IPV6) ? acl_match_host(ip) : 0;
-
-            switch (get_acl_mode()) {
-            case BLACK_LIST:
-                if (ip_match > 0)
-                    bypass = 1;                                               // bypass IPs in black list
-                break;
-            case WHITE_LIST:
-                bypass = 1;
-                if (ip_match < 0)
-                    bypass = 0;                                               // proxy IPs in white list
-                break;
-            }
-        }
-
-        if (bypass) {
-            if (verbose) {
-                if (atyp == SOCKS5_ATYP_DOMAIN)
-                    LOGI("bypass %s:%s", host, port);
-                else if (atyp == 1)
-                    LOGI("bypass %s:%s", ip, port);
-                else if (atyp == 4)
-                    LOGI("bypass [%s]:%s", ip, port);
-            }
-            if (atyp == SOCKS5_ATYP_DOMAIN && !resolved)
-#ifdef __ANDROID__
-                if (vpn)
-                    goto not_bypass;
-                else
-#endif
-                err = get_sockaddr(host, port, &storage, 0, ipv6first);
-            else
-                err = get_sockaddr(ip, port, &storage, 0, ipv6first);
-            if (err != -1) {
-                remote = create_remote(server->listener, (struct sockaddr *)&storage, 1);
-            }
-        }
-    }
-
-not_bypass:
-    // Not bypass
-    if (remote == NULL) {
-        remote = create_remote(server->listener, NULL, 0);
-    }
-
-    if (remote == NULL) {
-        LOGE("invalid remote addr");
-        close_and_free_server(EV_A_ server);
-        return -1;
-    }
-
-    if (!remote->direct) {
-        int err = crypto->encrypt(abuf, server->e_ctx, SOCKET_BUF_SIZE);
-        if (err) {
-            LOGE("invalid password or cipher");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return -1;
-        }
-    }
-
-    if (buf->len > 0) {
-        memcpy(remote->buf->data, buf->data, buf->len);
-        remote->buf->len = buf->len;
-    }
-
-    server->remote = remote;
-    remote->server = server;
-
-    if (buf->len > 0) {
-        return 0;
-    } else {
-        ev_timer_start(EV_A_ & server->delayed_connect_watcher);
-    }
-
-    return -1;
-}
-
-static void
-server_stream(EV_P_ ev_io *w, buffer_t *buf)
-{
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
-    remote_t *remote              = server->remote;
-
-    if (remote == NULL) {
-        LOGE("invalid remote");
-        close_and_free_server(EV_A_ server);
-        return;
-    }
-
-    // insert shadowsocks header
-    if (!remote->direct) {
-#ifdef __ANDROID__
-        tx += remote->buf->len;
-#endif
-        int err = crypto->encrypt(remote->buf, server->e_ctx, SOCKET_BUF_SIZE);
-
-        if (err) {
-            LOGE("invalid password or cipher");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-
-        if (server->abuf) {
-            bprepend(remote->buf, server->abuf, SOCKET_BUF_SIZE);
-            bfree(server->abuf);
-            ss_free(server->abuf);
-            server->abuf = NULL;
-        }
-    }
-
-    if (!remote->send_ctx->connected) {
-#ifdef __ANDROID__
-        if (vpn) {
-            int not_protect = 0;
-            if (remote->addr.ss_family == AF_INET) {
-                struct sockaddr_in *s = (struct sockaddr_in *)&remote->addr;
-                if (s->sin_addr.s_addr == inet_addr("127.0.0.1"))
-                    not_protect = 1;
-            }
-            if (!not_protect) {
-                if (protect_socket(remote->fd) == -1) {
-                    ERROR("protect_socket");
-                    close_and_free_remote(EV_A_ remote);
-                    close_and_free_server(EV_A_ server);
-                    return;
-                }
-            }
-        }
-#endif
-
-        remote->buf->idx = 0;
-
-        if (!fast_open || remote->direct) {
-            // connecting, wait until connected
-            int r = connect(remote->fd, (struct sockaddr *)&(remote->addr), remote->addr_len);
-
-            if (r == -1 && errno != CONNECT_IN_PROGRESS) {
-                ERROR("connect");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-
-            // wait on remote connected event
-            ev_io_stop(EV_A_ & server_recv_ctx->io);
-            ev_io_start(EV_A_ & remote->send_ctx->io);
-            ev_timer_start(EV_A_ & remote->send_ctx->watcher);
-        } else {
-#if defined(MSG_FASTOPEN) && !defined(TCP_FASTOPEN_CONNECT)
-            int s = -1;
-            s = sendto(remote->fd, remote->buf->data, remote->buf->len, MSG_FASTOPEN,
-                       (struct sockaddr *)&(remote->addr), remote->addr_len);
-#elif defined(TCP_FASTOPEN_WINSOCK)
-            DWORD s   = -1;
-            DWORD err = 0;
-            do {
-                int optval = 1;
-                // Set fast open option
-                if (setsockopt(remote->fd, IPPROTO_TCP, TCP_FASTOPEN,
-                               &optval, sizeof(optval)) != 0) {
-                    ERROR("setsockopt");
-                    break;
-                }
-                // Load ConnectEx function
-                LPFN_CONNECTEX ConnectEx = winsock_getconnectex();
-                if (ConnectEx == NULL) {
-                    LOGE("Cannot load ConnectEx() function");
-                    err = WSAENOPROTOOPT;
-                    break;
-                }
-                // ConnectEx requires a bound socket
-                if (winsock_dummybind(remote->fd,
-                                      (struct sockaddr *)&(remote->addr)) != 0) {
-                    ERROR("bind");
-                    break;
-                }
-                // Call ConnectEx to send data
-                memset(&remote->olap, 0, sizeof(remote->olap));
-                remote->connect_ex_done = 0;
-                if (ConnectEx(remote->fd, (const struct sockaddr *)&(remote->addr),
-                              remote->addr_len, remote->buf->data, remote->buf->len,
-                              &s, &remote->olap)) {
-                    remote->connect_ex_done = 1;
-                    break;
-                }
-                // XXX: ConnectEx pending, check later in remote_send
-                if (WSAGetLastError() == ERROR_IO_PENDING) {
-                    err = CONNECT_IN_PROGRESS;
-                    break;
-                }
-                ERROR("ConnectEx");
-            } while (0);
-            // Set error number
-            if (err) {
-                SetLastError(err);
-            }
-#else
-            int s = -1;
-#if defined(CONNECT_DATA_IDEMPOTENT)
-            ((struct sockaddr_in *)&(remote->addr))->sin_len = sizeof(struct sockaddr_in);
-            sa_endpoints_t endpoints;
-            memset((char *)&endpoints, 0, sizeof(endpoints));
-            endpoints.sae_dstaddr    = (struct sockaddr *)&(remote->addr);
-            endpoints.sae_dstaddrlen = remote->addr_len;
-
-            s = connectx(remote->fd, &endpoints, SAE_ASSOCID_ANY,
-                         CONNECT_RESUME_ON_READ_WRITE | CONNECT_DATA_IDEMPOTENT,
-                         NULL, 0, NULL, NULL);
-#elif defined(TCP_FASTOPEN_CONNECT)
-            int optval = 1;
-            if (setsockopt(remote->fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT,
-                           (void *)&optval, sizeof(optval)) < 0)
-                FATAL("failed to set TCP_FASTOPEN_CONNECT");
-            s = connect(remote->fd, (struct sockaddr *)&(remote->addr), remote->addr_len);
-#else
-            FATAL("fast open is not enabled in this build");
-#endif
-            if (s == 0)
-                s = send(remote->fd, remote->buf->data, remote->buf->len, 0);
-#endif
-            if (s == -1) {
-                if (errno == CONNECT_IN_PROGRESS) {
-                    // in progress, wait until connected
-                    remote->buf->idx = 0;
-                    ev_io_stop(EV_A_ & server_recv_ctx->io);
-                    ev_io_start(EV_A_ & remote->send_ctx->io);
-                    return;
-                } else {
-                    if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
-                        errno == ENOPROTOOPT) {
-                        LOGE("fast open is not supported on this platform");
-                        // just turn it off
-                        fast_open = 0;
-                    } else {
-                        ERROR("fast_open_connect");
-                    }
-                    close_and_free_remote(EV_A_ remote);
-                    close_and_free_server(EV_A_ server);
-                    return;
-                }
-            } else {
-                remote->buf->len -= s;
-                remote->buf->idx  = s;
-
-                ev_io_stop(EV_A_ & server_recv_ctx->io);
-                ev_io_start(EV_A_ & remote->send_ctx->io);
-                ev_timer_start(EV_A_ & remote->send_ctx->watcher);
-                return;
-            }
-        }
-    } else {
-        int s = send(remote->fd, remote->buf->data, remote->buf->len, 0);
-        if (s == -1) {
-            if (errno == EAGAIN || errno == EWOULDBLOCK) {
-                // no data, wait for send
-                remote->buf->idx = 0;
-                ev_io_stop(EV_A_ & server_recv_ctx->io);
-                ev_io_start(EV_A_ & remote->send_ctx->io);
-                return;
-            } else {
-                ERROR("server_recv_cb_send");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-        } else if (s < (int)(remote->buf->len)) {
-            remote->buf->len -= s;
-            remote->buf->idx  = s;
-            ev_io_stop(EV_A_ & server_recv_ctx->io);
-            ev_io_start(EV_A_ & remote->send_ctx->io);
-            return;
-        } else {
-            remote->buf->idx = 0;
-            remote->buf->len = 0;
-        }
-    }
-}
-
-static void
-server_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
-    remote_t *remote              = server->remote;
-    buffer_t *buf;
-    ssize_t r;
-
-    ev_timer_stop(EV_A_ & server->delayed_connect_watcher);
-
-    if (remote == NULL) {
-        buf = server->buf;
-    } else {
-        buf = remote->buf;
-    }
-
-    if (revents != EV_TIMER) {
-        r = recv(server->fd, buf->data + buf->len, SOCKET_BUF_SIZE - buf->len, 0);
-
-        if (r == 0) {
-            // connection closed
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        } else if (r == -1) {
-            if (errno == EAGAIN || errno == EWOULDBLOCK) {
-                // no data
-                // continue to wait for recv
-                return;
-            } else {
-                if (verbose)
-                    ERROR("server_recv_cb_recv");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-        }
-        buf->len += r;
-    }
-
-    while (1) {
-        // local socks5 server
-        if (server->stage == STAGE_STREAM) {
-            server_stream(EV_A_ w, buf);
-
-            // all processed
-            return;
-        } else if (server->stage == STAGE_INIT) {
-            if (verbose) {
-                struct sockaddr_in peer_addr;
-                socklen_t peer_addr_len = sizeof peer_addr;
-                if (getpeername(server->fd, (struct sockaddr *)&peer_addr, &peer_addr_len) == 0) {
-                    LOGI("connection from %s:%hu", inet_ntoa(peer_addr.sin_addr), ntohs(peer_addr.sin_port));
-                }
-            }
-            if (buf->len < 1)
-                return;
-            if (buf->data[0] != SVERSION) {
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-            if (buf->len < sizeof(struct method_select_request)) {
-                return;
-            }
-            struct method_select_request *method = (struct method_select_request *)buf->data;
-            int method_len                       = method->nmethods + sizeof(struct method_select_request);
-            if (buf->len < method_len) {
-                return;
-            }
-
-            struct method_select_response response;
-            response.ver    = SVERSION;
-            response.method = METHOD_UNACCEPTABLE;
-            for (int i = 0; i < method->nmethods; i++)
-                if (method->methods[i] == METHOD_NOAUTH) {
-                    response.method = METHOD_NOAUTH;
-                    break;
-                }
-            char *send_buf = (char *)&response;
-            send(server->fd, send_buf, sizeof(response), 0);
-            if (response.method == METHOD_UNACCEPTABLE) {
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-
-            server->stage = STAGE_HANDSHAKE;
-
-            if (method_len < (int)(buf->len)) {
-                memmove(buf->data, buf->data + method_len, buf->len - method_len);
-                buf->len -= method_len;
-                continue;
-            }
-
-            buf->len = 0;
-            return;
-        } else if (server->stage == STAGE_HANDSHAKE) {
-            int ret = server_handshake(EV_A_ w, buf);
-            if (ret)
-                return;
-        }
-    }
-}
-
-static void
-server_send_cb(EV_P_ ev_io *w, int revents)
-{
-    server_ctx_t *server_send_ctx = (server_ctx_t *)w;
-    server_t *server              = server_send_ctx->server;
-    remote_t *remote              = server->remote;
-    if (server->buf->len == 0) {
-        // close and free
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else {
-        // has data to send
-        ssize_t s = send(server->fd, server->buf->data + server->buf->idx,
-                         server->buf->len, 0);
-        if (s == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("server_send_cb_send");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        } else if (s < (ssize_t)(server->buf->len)) {
-            // partly sent, move memory, wait for the next time to send
-            server->buf->len -= s;
-            server->buf->idx += s;
-            return;
-        } else {
-            // all sent out, wait for reading
-            server->buf->len = 0;
-            server->buf->idx = 0;
-            ev_io_stop(EV_A_ & server_send_ctx->io);
-            ev_io_start(EV_A_ & remote->recv_ctx->io);
-            return;
-        }
-    }
-}
-
-#ifdef __ANDROID__
-void
-stat_update_cb()
-{
-    ev_tstamp now = ev_time();
-    if (now - last > 0.5) {
-        send_traffic_stat(tx, rx);
-        last = now;
-    }
-}
-
-#endif
-
-static void
-remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
-{
-    remote_ctx_t *remote_ctx
-        = cork_container_of(watcher, remote_ctx_t, watcher);
-
-    remote_t *remote = remote_ctx->remote;
-    server_t *server = remote->server;
-
-    if (verbose) {
-        LOGI("TCP connection timeout");
-    }
-
-    close_and_free_remote(EV_A_ remote);
-    close_and_free_server(EV_A_ server);
-}
-
-static void
-remote_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_recv_ctx->remote;
-    server_t *server              = remote->server;
-
-    ssize_t r = recv(remote->fd, server->buf->data, SOCKET_BUF_SIZE, 0);
-
-    if (r == 0) {
-        // connection closed
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else if (r == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data
-            // continue to wait for recv
-            return;
-        } else {
-            ERROR("remote_recv_cb_recv");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    server->buf->len = r;
-
-    if (!remote->direct) {
-#ifdef __ANDROID__
-        rx += server->buf->len;
-        stat_update_cb();
-#endif
-        int err = crypto->decrypt(server->buf, server->d_ctx, SOCKET_BUF_SIZE);
-        if (err == CRYPTO_ERROR) {
-            LOGE("invalid password or cipher");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        } else if (err == CRYPTO_NEED_MORE) {
-            return; // Wait for more
-        }
-    }
-
-    int s = send(server->fd, server->buf->data, server->buf->len, 0);
-
-    if (s == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data, wait for send
-            server->buf->idx = 0;
-            ev_io_stop(EV_A_ & remote_recv_ctx->io);
-            ev_io_start(EV_A_ & server->send_ctx->io);
-        } else {
-            ERROR("remote_recv_cb_send");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    } else if (s < (int)(server->buf->len)) {
-        server->buf->len -= s;
-        server->buf->idx  = s;
-        ev_io_stop(EV_A_ & remote_recv_ctx->io);
-        ev_io_start(EV_A_ & server->send_ctx->io);
-    }
-
-    // Disable TCP_NODELAY after the first response are sent
-    if (!remote->recv_ctx->connected && !no_delay) {
-        int opt = 0;
-        setsockopt(server->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-        setsockopt(remote->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-    }
-    remote->recv_ctx->connected = 1;
-}
-
-static void
-remote_send_cb(EV_P_ ev_io *w, int revents)
-{
-    remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_send_ctx->remote;
-    server_t *server              = remote->server;
-
-    if (!remote_send_ctx->connected) {
-#ifdef TCP_FASTOPEN_WINSOCK
-        if (fast_open) {
-            // Check if ConnectEx is done
-            if (!remote->connect_ex_done) {
-                DWORD numBytes;
-                DWORD flags;
-                // Non-blocking way to fetch ConnectEx result
-                if (WSAGetOverlappedResult(remote->fd, &remote->olap,
-                                           &numBytes, FALSE, &flags)) {
-                    remote->buf->len       -= numBytes;
-                    remote->buf->idx        = numBytes;
-                    remote->connect_ex_done = 1;
-                } else if (WSAGetLastError() == WSA_IO_INCOMPLETE) {
-                    // XXX: ConnectEx still not connected, wait for next time
-                    return;
-                } else {
-                    ERROR("WSAGetOverlappedResult");
-                    // not connected
-                    close_and_free_remote(EV_A_ remote);
-                    close_and_free_server(EV_A_ server);
-                    return;
-                }
-            }
-
-            // Make getpeername work
-            if (setsockopt(remote->fd, SOL_SOCKET,
-                           SO_UPDATE_CONNECT_CONTEXT, NULL, 0) != 0) {
-                ERROR("setsockopt");
-            }
-        }
-#endif
-        struct sockaddr_storage addr;
-        socklen_t len = sizeof addr;
-        int r         = getpeername(remote->fd, (struct sockaddr *)&addr, &len);
-        if (r == 0) {
-            remote_send_ctx->connected = 1;
-            ev_timer_stop(EV_A_ & remote_send_ctx->watcher);
-            ev_io_start(EV_A_ & remote->recv_ctx->io);
-
-            // no need to send any data
-            if (remote->buf->len == 0) {
-                ev_io_stop(EV_A_ & remote_send_ctx->io);
-                ev_io_start(EV_A_ & server->recv_ctx->io);
-                return;
-            }
-        } else {
-            // not connected
-            ERROR("getpeername");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    if (remote->buf->len == 0) {
-        // close and free
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else {
-        // has data to send
-        ssize_t s = send(remote->fd, remote->buf->data + remote->buf->idx,
-                         remote->buf->len, 0);
-        if (s == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("remote_send_cb_send");
-                // close and free
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        } else if (s < (ssize_t)(remote->buf->len)) {
-            // partly sent, move memory, wait for the next time to send
-            remote->buf->len -= s;
-            remote->buf->idx += s;
-            return;
-        } else {
-            // all sent out, wait for reading
-            remote->buf->len = 0;
-            remote->buf->idx = 0;
-            ev_io_stop(EV_A_ & remote_send_ctx->io);
-            ev_io_start(EV_A_ & server->recv_ctx->io);
-        }
-    }
-}
-
-static remote_t *
-new_remote(int fd, int timeout)
-{
-    remote_t *remote;
-    remote = ss_malloc(sizeof(remote_t));
-
-    memset(remote, 0, sizeof(remote_t));
-
-    remote->buf      = ss_malloc(sizeof(buffer_t));
-    remote->recv_ctx = ss_malloc(sizeof(remote_ctx_t));
-    remote->send_ctx = ss_malloc(sizeof(remote_ctx_t));
-    balloc(remote->buf, SOCKET_BUF_SIZE);
-    memset(remote->recv_ctx, 0, sizeof(remote_ctx_t));
-    memset(remote->send_ctx, 0, sizeof(remote_ctx_t));
-    remote->recv_ctx->connected = 0;
-    remote->send_ctx->connected = 0;
-    remote->fd                  = fd;
-    remote->recv_ctx->remote    = remote;
-    remote->send_ctx->remote    = remote;
-
-    ev_io_init(&remote->recv_ctx->io, remote_recv_cb, fd, EV_READ);
-    ev_io_init(&remote->send_ctx->io, remote_send_cb, fd, EV_WRITE);
-    ev_timer_init(&remote->send_ctx->watcher, remote_timeout_cb,
-                  min(MAX_CONNECT_TIMEOUT, timeout), 0);
-
-    return remote;
-}
-
-static void
-free_remote(remote_t *remote)
-{
-    if (remote->server != NULL) {
-        remote->server->remote = NULL;
-    }
-    if (remote->buf != NULL) {
-        bfree(remote->buf);
-        ss_free(remote->buf);
-    }
-    ss_free(remote->recv_ctx);
-    ss_free(remote->send_ctx);
-    ss_free(remote);
-}
-
-static void
-close_and_free_remote(EV_P_ remote_t *remote)
-{
-    if (remote != NULL) {
-        ev_timer_stop(EV_A_ & remote->send_ctx->watcher);
-        ev_io_stop(EV_A_ & remote->send_ctx->io);
-        ev_io_stop(EV_A_ & remote->recv_ctx->io);
-        close(remote->fd);
-        free_remote(remote);
-    }
-}
-
-static server_t *
-new_server(int fd)
-{
-    server_t *server;
-    server = ss_malloc(sizeof(server_t));
-
-    memset(server, 0, sizeof(server_t));
-
-    server->recv_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->send_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->buf      = ss_malloc(sizeof(buffer_t));
-    server->abuf     = ss_malloc(sizeof(buffer_t));
-    balloc(server->buf, SOCKET_BUF_SIZE);
-    balloc(server->abuf, SOCKET_BUF_SIZE);
-    memset(server->recv_ctx, 0, sizeof(server_ctx_t));
-    memset(server->send_ctx, 0, sizeof(server_ctx_t));
-    server->stage               = STAGE_INIT;
-    server->recv_ctx->connected = 0;
-    server->send_ctx->connected = 0;
-    server->fd                  = fd;
-    server->recv_ctx->server    = server;
-    server->send_ctx->server    = server;
-
-    server->e_ctx = ss_malloc(sizeof(cipher_ctx_t));
-    server->d_ctx = ss_malloc(sizeof(cipher_ctx_t));
-    crypto->ctx_init(crypto->cipher, server->e_ctx, 1);
-    crypto->ctx_init(crypto->cipher, server->d_ctx, 0);
-
-    ev_io_init(&server->recv_ctx->io, server_recv_cb, fd, EV_READ);
-    ev_io_init(&server->send_ctx->io, server_send_cb, fd, EV_WRITE);
-
-    ev_timer_init(&server->delayed_connect_watcher,
-                  delayed_connect_cb, 0.05, 0);
-
-    cork_dllist_add(&connections, &server->entries);
-
-    return server;
-}
-
-static void
-free_server(server_t *server)
-{
-    cork_dllist_remove(&server->entries);
-
-    if (server->remote != NULL) {
-        server->remote->server = NULL;
-    }
-    if (server->e_ctx != NULL) {
-        crypto->ctx_release(server->e_ctx);
-        ss_free(server->e_ctx);
-    }
-    if (server->d_ctx != NULL) {
-        crypto->ctx_release(server->d_ctx);
-        ss_free(server->d_ctx);
-    }
-    if (server->buf != NULL) {
-        bfree(server->buf);
-        ss_free(server->buf);
-    }
-    if (server->abuf != NULL) {
-        bfree(server->abuf);
-        ss_free(server->abuf);
-    }
-    ss_free(server->recv_ctx);
-    ss_free(server->send_ctx);
-    ss_free(server);
-}
-
-static void
-close_and_free_server(EV_P_ server_t *server)
-{
-    if (server != NULL) {
-        ev_io_stop(EV_A_ & server->send_ctx->io);
-        ev_io_stop(EV_A_ & server->recv_ctx->io);
-        ev_timer_stop(EV_A_ & server->delayed_connect_watcher);
-        close(server->fd);
-        free_server(server);
-    }
-}
-
-static remote_t *
-create_remote(listen_ctx_t *listener,
-              struct sockaddr *addr,
-              int direct)
-{
-    struct sockaddr *remote_addr;
-
-    int index = rand() % listener->remote_num;
-    if (addr == NULL) {
-        remote_addr = listener->remote_addr[index];
-    } else {
-        remote_addr = addr;
-    }
-
-    int protocol = IPPROTO_TCP;
-    if (listener->mptcp < 0) {
-        protocol = IPPROTO_MPTCP; // Enable upstream MPTCP
-    }
-    int remotefd = socket(remote_addr->sa_family, SOCK_STREAM, protocol);
-    if (remotefd == -1) {
-        ERROR("socket");
-        return NULL;
-    }
-
-    int opt = 1;
-    setsockopt(remotefd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-
-    // Enable out-of-tree MPTCP
-    if (listener->mptcp > 1) {
-        int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
-        if (err == -1) {
-            ERROR("failed to enable out-of-tree multipath TCP");
-        }
-    } else if (listener->mptcp == 1) {
-        int i = 0;
-        while ((listener->mptcp = mptcp_enabled_values[i]) > 0) {
-            int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
-            if (err != -1) {
-                break;
-            }
-            i++;
-        }
-        if (listener->mptcp == 0) {
-            ERROR("failed to enable out-of-tree multipath TCP");
-        }
-    }
-
-    if (tcp_outgoing_sndbuf > 0) {
-        setsockopt(remotefd, SOL_SOCKET, SO_SNDBUF, &tcp_outgoing_sndbuf, sizeof(int));
-    }
-
-    if (tcp_outgoing_rcvbuf > 0) {
-        setsockopt(remotefd, SOL_SOCKET, SO_RCVBUF, &tcp_outgoing_rcvbuf, sizeof(int));
-    }
-
-    // Setup
-    setnonblocking(remotefd);
-#ifdef SET_INTERFACE
-    if (listener->iface) {
-        if (setinterface(remotefd, listener->iface) == -1)
-            ERROR("setinterface");
-    }
-#endif
-
-    remote_t *remote = new_remote(remotefd, direct ? MAX_CONNECT_TIMEOUT : listener->timeout);
-    remote->addr_len = get_sockaddr_len(remote_addr);
-    memcpy(&(remote->addr), remote_addr, remote->addr_len);
-    remote->direct = direct;
-
-    if (verbose) {
-        struct sockaddr_in *sockaddr = (struct sockaddr_in *)&remote->addr;
-        LOGI("remote: %s:%hu", inet_ntoa(sockaddr->sin_addr), ntohs(sockaddr->sin_port));
-    }
-
-    return remote;
-}
-
-static void
-signal_cb(EV_P_ ev_signal *w, int revents)
-{
-    if (revents & EV_SIGNAL) {
-        switch (w->signum) {
-#ifndef __MINGW32__
-        case SIGCHLD:
-            if (!is_plugin_running()) {
-                LOGE("plugin service exit unexpectedly");
-                ret_val = -1;
-            } else
-                return;
-        case SIGUSR1:
-#endif
-        case SIGINT:
-        case SIGTERM:
-            ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-            ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-            ev_signal_stop(EV_DEFAULT, &sigchld_watcher);
-            ev_signal_stop(EV_DEFAULT, &sigusr1_watcher);
-#else
-#ifndef LIB_ONLY
-            ev_io_stop(EV_DEFAULT, &plugin_watcher.io);
-#endif
-#endif
-            ev_unloop(EV_A_ EVUNLOOP_ALL);
-        }
-    }
-}
-
-#if defined(__MINGW32__) && !defined(LIB_ONLY)
-static void
-plugin_watcher_cb(EV_P_ ev_io *w, int revents)
-{
-    char buf[1];
-    SOCKET fd = accept(plugin_watcher.fd, NULL, NULL);
-    if (fd == INVALID_SOCKET) {
-        return;
-    }
-    recv(fd, buf, 1, 0);
-    closesocket(fd);
-    LOGE("plugin service exit unexpectedly");
-    ret_val = -1;
-    ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-    ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-    ev_io_stop(EV_DEFAULT, &plugin_watcher.io);
-    ev_unloop(EV_A_ EVUNLOOP_ALL);
-}
-
-#endif
-
-void
-accept_cb(EV_P_ ev_io *w, int revents)
-{
-    listen_ctx_t *listener = (listen_ctx_t *)w;
-    int serverfd           = accept(listener->fd, NULL, NULL);
-    if (serverfd == -1) {
-        ERROR("accept");
-        return;
-    }
-    setnonblocking(serverfd);
-    int opt = 1;
-    setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-
-    if (tcp_incoming_sndbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &tcp_incoming_sndbuf, sizeof(int));
-    }
-
-    if (tcp_incoming_rcvbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &tcp_incoming_rcvbuf, sizeof(int));
-    }
-
-    server_t *server = new_server(serverfd);
-    server->listener = listener;
-
-    ev_io_start(EV_A_ & server->recv_ctx->io);
-}
-
-#ifndef LIB_ONLY
-int
-main(int argc, char **argv)
-{
-    int i, c;
-    int pid_flags    = 0;
-    int mtu          = 0;
-    int mptcp        = 0;
-    char *user       = NULL;
-    char *local_port = NULL;
-    char *local_addr = NULL;
-    char *password   = NULL;
-    char *key        = NULL;
-    char *timeout    = NULL;
-    char *method     = NULL;
-    char *pid_path   = NULL;
-    char *conf_path  = NULL;
-    char *iface      = NULL;
-
-    char *plugin      = NULL;
-    char *plugin_opts = NULL;
-    char *plugin_host = NULL;
-    char *plugin_port = NULL;
-    char tmp_port[8];
-
-    int remote_num = 0;
-    ss_addr_t remote_addr[MAX_REMOTE_NUM];
-    char *remote_port = NULL;
-
-    memset(remote_addr, 0, sizeof(ss_addr_t) * MAX_REMOTE_NUM);
-    srand(time(NULL));
-
-    static struct option long_options[] = {
-        { "reuse-port",  no_argument,       NULL, GETOPT_VAL_REUSE_PORT  },
-        { "tcp-incoming-sndbuf", required_argument, NULL, GETOPT_VAL_TCP_INCOMING_SNDBUF },
-        { "tcp-incoming-rcvbuf", required_argument, NULL, GETOPT_VAL_TCP_INCOMING_RCVBUF },
-        { "tcp-outgoing-sndbuf", required_argument, NULL, GETOPT_VAL_TCP_OUTGOING_SNDBUF },
-        { "tcp-outgoing-rcvbuf", required_argument, NULL, GETOPT_VAL_TCP_OUTGOING_RCVBUF },
-        { "fast-open",   no_argument,       NULL, GETOPT_VAL_FAST_OPEN   },
-        { "no-delay",    no_argument,       NULL, GETOPT_VAL_NODELAY     },
-        { "acl",         required_argument, NULL, GETOPT_VAL_ACL         },
-        { "mtu",         required_argument, NULL, GETOPT_VAL_MTU         },
-        { "mptcp",       no_argument,       NULL, GETOPT_VAL_MPTCP       },
-        { "plugin",      required_argument, NULL, GETOPT_VAL_PLUGIN      },
-        { "plugin-opts", required_argument, NULL, GETOPT_VAL_PLUGIN_OPTS },
-        { "password",    required_argument, NULL, GETOPT_VAL_PASSWORD    },
-        { "key",         required_argument, NULL, GETOPT_VAL_KEY         },
-        { "help",        no_argument,       NULL, GETOPT_VAL_HELP        },
-        { NULL,          0,                 NULL, 0                      }
-    };
-
-    opterr = 0;
-
-    USE_TTY();
-
-#ifdef __ANDROID__
-    while ((c = getopt_long(argc, argv, "f:s:p:l:k:t:m:i:c:b:a:n:S:huUvV6A",
-                            long_options, NULL)) != -1) {
-#else
-    while ((c = getopt_long(argc, argv, "f:s:p:l:k:t:m:i:c:b:a:n:huUv6A",
-                            long_options, NULL)) != -1) {
-#endif
-        switch (c) {
-        case GETOPT_VAL_FAST_OPEN:
-            fast_open = 1;
-            break;
-        case GETOPT_VAL_ACL:
-            LOGI("initializing acl...");
-            acl = !init_acl(optarg);
-            break;
-        case GETOPT_VAL_MTU:
-            mtu = atoi(optarg);
-            LOGI("set MTU to %d", mtu);
-            break;
-        case GETOPT_VAL_MPTCP:
-            mptcp = get_mptcp(1);
-            if (mptcp)
-                LOGI("enable multipath TCP (%s)", mptcp > 0 ? "out-of-tree" : "upstream");
-            break;
-        case GETOPT_VAL_NODELAY:
-            no_delay = 1;
-            LOGI("enable TCP no-delay");
-            break;
-        case GETOPT_VAL_PLUGIN:
-            plugin = optarg;
-            break;
-        case GETOPT_VAL_PLUGIN_OPTS:
-            plugin_opts = optarg;
-            break;
-        case GETOPT_VAL_KEY:
-            key = optarg;
-            break;
-        case GETOPT_VAL_REUSE_PORT:
-            reuse_port = 1;
-            break;
-        case GETOPT_VAL_TCP_INCOMING_SNDBUF:
-            tcp_incoming_sndbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_INCOMING_RCVBUF:
-            tcp_incoming_rcvbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_OUTGOING_SNDBUF:
-            tcp_outgoing_sndbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_OUTGOING_RCVBUF:
-            tcp_outgoing_rcvbuf = atoi(optarg);
-            break;
-        case 's':
-            if (remote_num < MAX_REMOTE_NUM) {
-                parse_addr(optarg, &remote_addr[remote_num++]);
-            }
-            break;
-        case 'p':
-            remote_port = optarg;
-            break;
-        case 'l':
-            local_port = optarg;
-            break;
-        case GETOPT_VAL_PASSWORD:
-        case 'k':
-            password = optarg;
-            break;
-        case 'f':
-            pid_flags = 1;
-            pid_path  = optarg;
-            break;
-        case 't':
-            timeout = optarg;
-            break;
-        case 'm':
-            method = optarg;
-            break;
-        case 'c':
-            conf_path = optarg;
-            break;
-        case 'i':
-            iface = optarg;
-            break;
-        case 'b':
-            local_addr = optarg;
-            break;
-        case 'a':
-            user = optarg;
-            break;
-#ifdef HAVE_SETRLIMIT
-        case 'n':
-            nofile = atoi(optarg);
-            break;
-#endif
-        case 'u':
-            mode = TCP_AND_UDP;
-            break;
-        case 'U':
-            mode = UDP_ONLY;
-            break;
-        case 'v':
-            verbose = 1;
-            break;
-        case 'h':
-        case GETOPT_VAL_HELP:
-            usage();
-            exit(EXIT_SUCCESS);
-        case '6':
-            ipv6first = 1;
-            break;
-#ifdef __ANDROID__
-        case 'S':
-            stat_path = optarg;
-            break;
-        case 'V':
-            vpn = 1;
-            break;
-#endif
-        case 'A':
-            FATAL("One time auth has been deprecated. Try AEAD ciphers instead.");
-            break;
-        case '?':
-            // The option character is not recognized.
-            LOGE("Unrecognized option: %s", optarg);
-            opterr = 1;
-            break;
-        }
-    }
-
-    if (opterr) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-    if (argc == 1) {
-        if (conf_path == NULL) {
-            conf_path = get_default_conf();
-        }
-    }
-    if (conf_path != NULL) {
-        jconf_t *conf = read_jconf(conf_path);
-        if (remote_num == 0) {
-            remote_num = conf->remote_num;
-            for (i = 0; i < remote_num; i++)
-                remote_addr[i] = conf->remote_addr[i];
-        }
-        if (remote_port == NULL) {
-            remote_port = conf->remote_port;
-        }
-        if (local_addr == NULL) {
-            local_addr = conf->local_addr;
-        }
-        if (local_port == NULL) {
-            local_port = conf->local_port;
-        }
-        if (password == NULL) {
-            password = conf->password;
-        }
-        if (key == NULL) {
-            key = conf->key;
-        }
-        if (method == NULL) {
-            method = conf->method;
-        }
-        if (timeout == NULL) {
-            timeout = conf->timeout;
-        }
-        if (user == NULL) {
-            user = conf->user;
-        }
-        if (plugin == NULL) {
-            plugin = conf->plugin;
-        }
-        if (plugin_opts == NULL) {
-            plugin_opts = conf->plugin_opts;
-        }
-        if (reuse_port == 0) {
-            reuse_port = conf->reuse_port;
-        }
-        if (tcp_incoming_sndbuf == 0) {
-            tcp_incoming_sndbuf = conf->tcp_incoming_sndbuf;
-        }
-        if (tcp_incoming_rcvbuf == 0) {
-            tcp_incoming_rcvbuf = conf->tcp_incoming_rcvbuf;
-        }
-        if (tcp_outgoing_sndbuf == 0) {
-            tcp_outgoing_sndbuf = conf->tcp_outgoing_sndbuf;
-        }
-        if (tcp_outgoing_rcvbuf == 0) {
-            tcp_outgoing_rcvbuf = conf->tcp_outgoing_rcvbuf;
-        }
-        if (fast_open == 0) {
-            fast_open = conf->fast_open;
-        }
-        if (mode == TCP_ONLY) {
-            mode = conf->mode;
-        }
-        if (mtu == 0) {
-            mtu = conf->mtu;
-        }
-        if (mptcp == 0) {
-            mptcp = conf->mptcp;
-        }
-        if (no_delay == 0) {
-            no_delay = conf->no_delay;
-        }
-#ifdef HAVE_SETRLIMIT
-        if (nofile == 0) {
-            nofile = conf->nofile;
-        }
-#endif
-        if (ipv6first == 0) {
-            ipv6first = conf->ipv6_first;
-        }
-        if (acl == 0 && conf->acl != NULL) {
-            LOGI("initializing acl...");
-            acl = !init_acl(conf->acl);
-        }
-    }
-
-    if (remote_num == 0) {
-        fprintf(stderr, "remote_num is 0\n");
-        exit(EXIT_FAILURE);
-    }
-    if (!remote_port) {
-        fprintf(stderr, "remote_port is NULL\n");
-        exit(EXIT_FAILURE);
-    }
-#ifndef HAVE_LAUNCHD
-    if (!local_port) {
-        fprintf(stderr, "local_port is NULL\n");
-        exit(EXIT_FAILURE);
-    }
-#endif
-    if (!password && !key) {
-        fprintf(stderr, "both password and key are NULL\n");
-        exit(EXIT_FAILURE);
-    }
-
-#ifdef __MINGW32__
-    winsock_init();
-#endif
-
-    if (tcp_incoming_sndbuf != 0 && tcp_incoming_sndbuf < SOCKET_BUF_SIZE) {
-        tcp_incoming_sndbuf = 0;
-    }
-
-    if (tcp_incoming_sndbuf != 0) {
-        LOGI("set TCP incoming connection send buffer size to %d", tcp_incoming_sndbuf);
-    }
-
-    if (tcp_incoming_rcvbuf != 0 && tcp_incoming_rcvbuf < SOCKET_BUF_SIZE) {
-        tcp_incoming_rcvbuf = 0;
-    }
-
-    if (tcp_incoming_rcvbuf != 0) {
-        LOGI("set TCP incoming connection receive buffer size to %d", tcp_incoming_rcvbuf);
-    }
-
-    if (tcp_outgoing_sndbuf != 0 && tcp_outgoing_sndbuf < SOCKET_BUF_SIZE) {
-        tcp_outgoing_sndbuf = 0;
-    }
-
-    if (tcp_outgoing_sndbuf != 0) {
-        LOGI("set TCP outgoing connection send buffer size to %d", tcp_outgoing_sndbuf);
-    }
-
-    if (tcp_outgoing_rcvbuf != 0 && tcp_outgoing_rcvbuf < SOCKET_BUF_SIZE) {
-        tcp_outgoing_rcvbuf = 0;
-    }
-
-    if (tcp_outgoing_rcvbuf != 0) {
-        LOGI("set TCP outgoing connection receive buffer size to %d", tcp_outgoing_rcvbuf);
-    }
-
-    if (plugin != NULL) {
-        uint16_t port = get_local_port();
-        if (port == 0) {
-            FATAL("failed to find a free port");
-        }
-        snprintf(tmp_port, 8, "%d", port);
-        if (is_ipv6only(remote_addr, remote_num, ipv6first)) {
-            plugin_host = "::1";
-        } else {
-            plugin_host = "127.0.0.1";
-        }
-        plugin_port = tmp_port;
-
-#ifdef __MINGW32__
-        memset(&plugin_watcher, 0, sizeof(plugin_watcher));
-        plugin_watcher.port = get_local_port();
-        if (plugin_watcher.port == 0) {
-            LOGE("failed to assign a control port for plugin");
-        }
-#endif
-
-        LOGI("plugin \"%s\" enabled", plugin);
-    }
-
-    if (method == NULL) {
-        method = "chacha20-ietf-poly1305";
-    }
-
-    if (timeout == NULL) {
-        timeout = "60";
-    }
-
-#ifdef HAVE_SETRLIMIT
-    /*
-     * no need to check the return value here since we will show
-     * the user an error message if setrlimit(2) fails
-     */
-    if (nofile > 1024) {
-        if (verbose) {
-            LOGI("setting NOFILE to %d", nofile);
-        }
-        set_nofile(nofile);
-    }
-#endif
-
-    if (local_addr == NULL) {
-        if (is_ipv6only(remote_addr, remote_num, ipv6first)) {
-            local_addr = "::1";
-        } else {
-            local_addr = "127.0.0.1";
-        }
-    }
-
-    USE_SYSLOG(argv[0], pid_flags);
-    if (pid_flags) {
-        daemonize(pid_path);
-    }
-
-    if (fast_open == 1) {
-#ifdef TCP_FASTOPEN
-        LOGI("using tcp fast open");
-#else
-        LOGE("tcp fast open is not supported by this environment");
-        fast_open = 0;
-#endif
-    }
-
-    if (no_delay) {
-        LOGI("enable TCP no-delay");
-    }
-
-    if (ipv6first) {
-        LOGI("resolving hostname to IPv6 address first");
-    }
-
-#ifdef __MINGW32__
-    // Listen on plugin control port
-    if (plugin != NULL && plugin_watcher.port != 0) {
-        SOCKET fd;
-        fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-        if (fd != INVALID_SOCKET) {
-            plugin_watcher.valid = 0;
-            do {
-                struct sockaddr_in addr;
-                memset(&addr, 0, sizeof(addr));
-                addr.sin_family      = AF_INET;
-                addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-                addr.sin_port        = htons(plugin_watcher.port);
-                if (bind(fd, (struct sockaddr *)&addr, sizeof(addr))) {
-                    LOGE("failed to bind plugin control port");
-                    break;
-                }
-                if (listen(fd, 1)) {
-                    LOGE("failed to listen on plugin control port");
-                    break;
-                }
-                plugin_watcher.fd = fd;
-                ev_io_init(&plugin_watcher.io, plugin_watcher_cb, fd, EV_READ);
-                ev_io_start(EV_DEFAULT, &plugin_watcher.io);
-                plugin_watcher.valid = 1;
-            } while (0);
-            if (!plugin_watcher.valid) {
-                closesocket(fd);
-                plugin_watcher.port = 0;
-            }
-        }
-    }
-#endif
-
-    if (plugin != NULL) {
-        int len          = 0;
-        size_t buf_size  = 256 * remote_num;
-        char *remote_str = ss_malloc(buf_size);
-
-        snprintf(remote_str, buf_size, "%s", remote_addr[0].host);
-        len = strlen(remote_str);
-        for (int i = 1; i < remote_num; i++) {
-            snprintf(remote_str + len, buf_size - len, "|%s", remote_addr[i].host);
-            len = strlen(remote_str);
-        }
-        int err = start_plugin(plugin, plugin_opts, remote_str,
-                               remote_port, plugin_host, plugin_port,
-#ifdef __MINGW32__
-                               plugin_watcher.port,
-#endif
-                               MODE_CLIENT);
-        if (err) {
-            ERROR("start_plugin");
-            FATAL("failed to start the plugin");
-        }
-    }
-
-#ifndef __MINGW32__
-    // ignore SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGABRT, SIG_IGN);
-#endif
-
-    // Setup keys
-    LOGI("initializing ciphers... %s", method);
-    crypto = crypto_init(password, key, method);
-    if (crypto == NULL)
-        FATAL("failed to initialize ciphers");
-
-    // Setup proxy context
-    listen_ctx_t listen_ctx;
-    listen_ctx.remote_num  = 0;
-    listen_ctx.remote_addr = ss_malloc(sizeof(struct sockaddr *) * remote_num);
-    memset(listen_ctx.remote_addr, 0, sizeof(struct sockaddr *) * remote_num);
-    for (i = 0; i < remote_num; i++) {
-        char *host = remote_addr[i].host;
-        char *port = remote_addr[i].port == NULL ? remote_port :
-                     remote_addr[i].port;
-        if (plugin != NULL) {
-            host = plugin_host;
-            port = plugin_port;
-        }
-        struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
-        memset(storage, 0, sizeof(struct sockaddr_storage));
-        if (get_sockaddr(host, port, storage, 1, ipv6first) == -1) {
-            FATAL("failed to resolve the provided hostname");
-        }
-        listen_ctx.remote_addr[i] = (struct sockaddr *)storage;
-        ++listen_ctx.remote_num;
-
-        if (plugin != NULL)
-            break;
-    }
-    listen_ctx.timeout = atoi(timeout);
-    listen_ctx.iface   = iface;
-    listen_ctx.mptcp   = mptcp;
-
-    // Setup signal handler
-    ev_signal_init(&sigint_watcher, signal_cb, SIGINT);
-    ev_signal_init(&sigterm_watcher, signal_cb, SIGTERM);
-    ev_signal_start(EV_DEFAULT, &sigint_watcher);
-    ev_signal_start(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-    ev_signal_init(&sigchld_watcher, signal_cb, SIGCHLD);
-    ev_signal_start(EV_DEFAULT, &sigchld_watcher);
-#endif
-
-    if (ss_is_ipv6addr(local_addr))
-        LOGI("listening at [%s]:%s", local_addr, local_port);
-    else
-        LOGI("listening at %s:%s", local_addr, local_port);
-
-    struct ev_loop *loop = EV_DEFAULT;
-
-    if (mode != UDP_ONLY) {
-        // Setup socket
-        int listenfd;
-#ifdef HAVE_LAUNCHD
-        listenfd = launch_or_create(local_addr, local_port);
-#else
-        listenfd = create_and_bind(local_addr, local_port);
-#endif
-        if (listenfd == -1) {
-            FATAL("bind() error");
-        }
-        if (listen(listenfd, SOMAXCONN) == -1) {
-            FATAL("listen() error");
-        }
-        setnonblocking(listenfd);
-
-        listen_ctx.fd = listenfd;
-
-        ev_io_init(&listen_ctx.io, accept_cb, listenfd, EV_READ);
-        ev_io_start(loop, &listen_ctx.io);
-    }
-
-    // Setup UDP
-    if (mode != TCP_ONLY) {
-        LOGI("udprelay enabled");
-        char *host                       = remote_addr[0].host;
-        char *port                       = remote_addr[0].port == NULL ? remote_port : remote_addr[0].port;
-        struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
-        memset(storage, 0, sizeof(struct sockaddr_storage));
-        if (get_sockaddr(host, port, storage, 1, ipv6first) == -1) {
-            FATAL("failed to resolve the provided hostname");
-        }
-        struct sockaddr *addr = (struct sockaddr *)storage;
-        udp_fd = init_udprelay(local_addr, local_port, addr,
-                               get_sockaddr_len(addr), mtu, crypto, listen_ctx.timeout, iface);
-    }
-
-#ifdef HAVE_LAUNCHD
-    if (local_port == NULL)
-        LOGI("listening through launchd");
-    else
-#endif
-
-#ifndef __MINGW32__
-    // setuid
-    if (user != NULL && !run_as(user)) {
-        FATAL("failed to switch user");
-    }
-
-    if (geteuid() == 0) {
-        LOGI("running from root user");
-    }
-#endif
-
-    // Init connections
-    cork_dllist_init(&connections);
-
-    // Enter the loop
-    ev_run(loop, 0);
-
-    if (verbose) {
-        LOGI("closed gracefully");
-    }
-
-    // Clean up
-    if (plugin != NULL) {
-        stop_plugin();
-    }
-
-    if (mode != UDP_ONLY) {
-        ev_io_stop(loop, &listen_ctx.io);
-        free_connections(loop);
-
-        for (i = 0; i < listen_ctx.remote_num; i++)
-            ss_free(listen_ctx.remote_addr[i]);
-        ss_free(listen_ctx.remote_addr);
-    }
-
-    if (mode != TCP_ONLY) {
-        free_udprelay();
-    }
-
-#ifdef __MINGW32__
-    if (plugin_watcher.valid) {
-        closesocket(plugin_watcher.fd);
-    }
-
-    winsock_cleanup();
-#endif
-
-    return ret_val;
-}
-
-#else
-
-int
-_start_ss_local_server(profile_t profile, ss_local_callback callback, void *udata)
-{
-    srand(time(NULL));
-
-    char *remote_host = profile.remote_host;
-    char *local_addr  = profile.local_addr;
-    char *method      = profile.method;
-    char *password    = profile.password;
-    char *log         = profile.log;
-    int remote_port   = profile.remote_port;
-    int local_port    = profile.local_port;
-    int timeout       = profile.timeout;
-    int mtu           = 0;
-    int mptcp         = 0;
-
-    mode      = profile.mode;
-    fast_open = profile.fast_open;
-    verbose   = profile.verbose;
-    mtu       = profile.mtu;
-    mptcp     = profile.mptcp;
-
-    char local_port_str[16];
-    char remote_port_str[16];
-    sprintf(local_port_str, "%d", local_port);
-    sprintf(remote_port_str, "%d", remote_port);
-
-#ifdef __MINGW32__
-    winsock_init();
-#endif
-
-    USE_LOGFILE(log);
-
-    if (profile.acl != NULL) {
-        LOGI("initializing acl...");
-        acl = !init_acl(profile.acl);
-    }
-
-    if (local_addr == NULL) {
-        local_addr = "127.0.0.1";
-    }
-
-#ifndef __MINGW32__
-    // ignore SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGABRT, SIG_IGN);
-#endif
-
-    ev_signal_init(&sigint_watcher, signal_cb, SIGINT);
-    ev_signal_init(&sigterm_watcher, signal_cb, SIGTERM);
-    ev_signal_start(EV_DEFAULT, &sigint_watcher);
-    ev_signal_start(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-    ev_signal_init(&sigusr1_watcher, signal_cb, SIGUSR1);
-    ev_signal_start(EV_DEFAULT, &sigusr1_watcher);
-#endif
-
-    // Setup keys
-    LOGI("initializing ciphers... %s", method);
-    crypto = crypto_init(password, NULL, method);
-    if (crypto == NULL)
-        FATAL("failed to init ciphers");
-
-    struct sockaddr_storage storage;
-    memset(&storage, 0, sizeof(struct sockaddr_storage));
-    if (get_sockaddr(remote_host, remote_port_str, &storage, 0, ipv6first) == -1) {
-        return -1;
-    }
-
-    // Setup proxy context
-    struct ev_loop *loop = EV_DEFAULT;
-
-    struct sockaddr *remote_addr_tmp[MAX_REMOTE_NUM];
-    listen_ctx_t listen_ctx;
-    listen_ctx.remote_num     = 1;
-    listen_ctx.remote_addr    = remote_addr_tmp;
-    listen_ctx.remote_addr[0] = (struct sockaddr *)(&storage);
-    listen_ctx.timeout        = timeout;
-    listen_ctx.iface          = NULL;
-    listen_ctx.mptcp          = mptcp;
-
-    if (ss_is_ipv6addr(local_addr))
-        LOGI("listening at [%s]:%s", local_addr, local_port_str);
-    else
-        LOGI("listening at %s:%s", local_addr, local_port_str);
-
-    if (mode != UDP_ONLY) {
-        // Setup socket
-        int listenfd;
-        listenfd = create_and_bind(local_addr, local_port_str);
-        if (listenfd == -1) {
-            ERROR("bind()");
-            return -1;
-        }
-        if (listen(listenfd, SOMAXCONN) == -1) {
-            ERROR("listen()");
-            return -1;
-        }
-        setnonblocking(listenfd);
-
-        listen_ctx.fd = listenfd;
-
-        ev_io_init(&listen_ctx.io, accept_cb, listenfd, EV_READ);
-        ev_io_start(loop, &listen_ctx.io);
-    }
-
-    // Setup UDP
-    if (mode != TCP_ONLY) {
-        LOGI("udprelay enabled");
-        struct sockaddr *addr = (struct sockaddr *)(&storage);
-        udp_fd = init_udprelay(local_addr, local_port_str, addr,
-                               get_sockaddr_len(addr), mtu, crypto, timeout, NULL);
-    }
-
-    // Init connections
-    cork_dllist_init(&connections);
-
-    if (callback) {
-        callback(listen_ctx.fd, udp_fd, udata);
-    }
-
-    // Enter the loop
-    ev_run(loop, 0);
-
-    if (verbose) {
-        LOGI("closed gracefully");
-    }
-
-    // Clean up
-    if (mode != UDP_ONLY) {
-        ev_io_stop(loop, &listen_ctx.io);
-        free_connections(loop);
-        close(listen_ctx.fd);
-    }
-
-    if (mode != TCP_ONLY) {
-        free_udprelay();
-    }
-
-#ifdef __MINGW32__
-    winsock_cleanup();
-#endif
-
-    return ret_val;
-}
-
-int
-start_ss_local_server(profile_t profile)
-{
-    return _start_ss_local_server(profile, NULL, NULL);
-}
-
-int
-start_ss_local_server_with_callback(profile_t profile, ss_local_callback callback, void *udata)
-{
-    return _start_ss_local_server(profile, callback, udata);
-}
-
-#endif
diff --git a/src/local.h b/src/local.h
deleted file mode 100644
index 96ee92a..0000000
--- a/src/local.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * local.h - Define the client's buffers and callbacks
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _LOCAL_H
-#define _LOCAL_H
-
-#include <libcork/ds.h>
-
-#ifdef HAVE_LIBEV_EV_H
-#include <libev/ev.h>
-#else
-#include <ev.h>
-#endif
-
-#ifdef __MINGW32__
-#include "winsock.h"
-#endif
-
-#include "crypto.h"
-#include "jconf.h"
-
-#include "common.h"
-
-typedef struct listen_ctx {
-    ev_io io;
-    char *iface;
-    int remote_num;
-    int timeout;
-    int fd;
-    int mptcp;
-    struct sockaddr **remote_addr;
-} listen_ctx_t;
-
-typedef struct server_ctx {
-    ev_io io;
-    int connected;
-    struct server *server;
-} server_ctx_t;
-
-typedef struct server {
-    int fd;
-    int stage;
-
-    cipher_ctx_t *e_ctx;
-    cipher_ctx_t *d_ctx;
-    struct server_ctx *recv_ctx;
-    struct server_ctx *send_ctx;
-    struct listen_ctx *listener;
-    struct remote *remote;
-
-    buffer_t *buf;
-    buffer_t *abuf;
-
-    ev_timer delayed_connect_watcher;
-
-    struct cork_dllist_item entries;
-} server_t;
-
-typedef struct remote_ctx {
-    ev_io io;
-    ev_timer watcher;
-
-    int connected;
-    struct remote *remote;
-} remote_ctx_t;
-
-typedef struct remote {
-    int fd;
-    int direct;
-    int addr_len;
-    uint32_t counter;
-#ifdef TCP_FASTOPEN_WINSOCK
-    OVERLAPPED olap;
-    int connect_ex_done;
-#endif
-
-    buffer_t *buf;
-
-    struct remote_ctx *recv_ctx;
-    struct remote_ctx *send_ctx;
-    struct server *server;
-    struct sockaddr_storage addr;
-} remote_t;
-
-#endif // _LOCAL_H
diff --git a/src/manager.c b/src/manager.c
deleted file mode 100644
index 8a229d0..0000000
--- a/src/manager.c
+++ /dev/null
@@ -1,1292 +0,0 @@
-/*
- * server.c - Provide shadowsocks service
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <locale.h>
-#include <signal.h>
-#include <string.h>
-#include <strings.h>
-#include <time.h>
-#include <unistd.h>
-#include <getopt.h>
-#include <math.h>
-#include <ctype.h>
-#include <limits.h>
-#include <dirent.h>
-
-#include <netdb.h>
-#include <errno.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#include <pthread.h>
-#include <sys/un.h>
-#include <sys/socket.h>
-#include <pwd.h>
-#include <libcork/core.h>
-
-#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
-#include <net/if.h>
-#include <sys/ioctl.h>
-#define SET_INTERFACE
-#endif
-
-#include "json.h"
-#include "utils.h"
-#include "netutils.h"
-#include "manager.h"
-
-#ifndef BUF_SIZE
-#define BUF_SIZE 65535
-#endif
-
-int verbose          = 0;
-char *executable     = "ss-server";
-char *working_dir    = NULL;
-int working_dir_size = 0;
-
-static struct cork_hash_table *server_table;
-
-static int
-setnonblocking(int fd)
-{
-    int flags;
-    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
-        flags = 0;
-    }
-    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-}
-
-static void
-destroy_server(struct server *server)
-{
-// function used to free memories alloced in **get_server**
-    if (server->method)
-        ss_free(server->method);
-    if (server->plugin)
-        ss_free(server->plugin);
-    if (server->plugin_opts)
-        ss_free(server->plugin_opts);
-    if (server->mode)
-        ss_free(server->mode);
-}
-
-static void
-build_config(char *prefix, struct manager_ctx *manager, struct server *server)
-{
-    char *path    = NULL;
-    int path_size = strlen(prefix) + strlen(server->port) + 20;
-
-    path = ss_malloc(path_size);
-    snprintf(path, path_size, "%s/.shadowsocks_%s.conf", prefix, server->port);
-    FILE *f = fopen(path, "w+");
-    if (f == NULL) {
-        if (verbose) {
-            LOGE("unable to open config file");
-        }
-        ss_free(path);
-        return;
-    }
-    fprintf(f, "{\n");
-    fprintf(f, "\"server_port\":%d,\n", atoi(server->port));
-    fprintf(f, "\"password\":\"%s\"", server->password);
-    if (server->method)
-        fprintf(f, ",\n\"method\":\"%s\"", server->method);
-    else if (manager->method)
-        fprintf(f, ",\n\"method\":\"%s\"", manager->method);
-    if (server->fast_open[0])
-        fprintf(f, ",\n\"fast_open\": %s", server->fast_open);
-    else if (manager->fast_open)
-        fprintf(f, ",\n\"fast_open\": true");
-    if (server->no_delay[0])
-        fprintf(f, ",\n\"no_delay\": %s", server->no_delay);
-    else if (manager->no_delay)
-        fprintf(f, ",\n\"no_delay\": true");
-    if (manager->reuse_port)
-        fprintf(f, ",\n\"reuse_port\": true");
-    if (server->mode)
-        fprintf(f, ",\n\"mode\":\"%s\"", server->mode);
-    if (server->plugin)
-        fprintf(f, ",\n\"plugin\":\"%s\"", server->plugin);
-    if (server->plugin_opts)
-        fprintf(f, ",\n\"plugin_opts\":\"%s\"", server->plugin_opts);
-    fprintf(f, "\n}\n");
-    fclose(f);
-    ss_free(path);
-}
-
-static char *
-construct_command_line(struct manager_ctx *manager, struct server *server)
-{
-    static char cmd[BUF_SIZE];
-    int i;
-    int port;
-
-    port = atoi(server->port);
-
-    build_config(working_dir, manager, server);
-
-    memset(cmd, 0, BUF_SIZE);
-    snprintf(cmd, BUF_SIZE,
-             "%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf",
-             executable, manager->manager_address, working_dir, port, working_dir, port);
-
-    if (manager->acl != NULL) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " --acl %s", manager->acl);
-    }
-    if (manager->timeout != NULL) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -t %s", manager->timeout);
-    }
-#ifdef HAVE_SETRLIMIT
-    if (manager->nofile) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -n %d", manager->nofile);
-    }
-#endif
-    if (manager->user != NULL) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -a %s", manager->user);
-    }
-    if (manager->verbose) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -v");
-    }
-    if (server->mode == NULL && manager->mode == UDP_ONLY) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -U");
-    }
-    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -u");
-    }
-    if (manager->iface) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -i \"%s\"", manager->iface);
-    }
-    if (server->fast_open[0] == 0 && manager->fast_open) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " --fast-open");
-    }
-    if (server->no_delay[0] == 0 && manager->no_delay) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " --no-delay");
-    }
-    if (manager->ipv6first) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -6");
-    }
-    if (manager->mtu) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " --mtu %d", manager->mtu);
-    }
-    if (server->plugin == NULL && manager->plugin) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " --plugin \"%s\"", manager->plugin);
-    }
-    if (server->plugin_opts == NULL && manager->plugin_opts) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " --plugin-opts \"%s\"", manager->plugin_opts);
-    }
-    if (manager->nameservers) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -d \"%s\"", manager->nameservers);
-    }
-    for (i = 0; i < manager->host_num; i++) {
-        int len = strlen(cmd);
-        snprintf(cmd + len, BUF_SIZE - len, " -s %s", manager->hosts[i]);
-    }
-
-    if (verbose) {
-        LOGI("cmd: %s", cmd);
-    }
-
-    return cmd;
-}
-
-static char *
-get_data(char *buf, int len)
-{
-    char *data;
-    int pos = 0;
-
-    while (pos < len && buf[pos] != '{')
-        pos++;
-    if (pos == len) {
-        return NULL;
-    }
-    data = buf + pos - 1;
-
-    return data;
-}
-
-static char *
-get_action(char *buf, int len)
-{
-    char *action;
-    int pos = 0;
-
-    while (pos < len && isspace((unsigned char)buf[pos]))
-        pos++;
-    if (pos == len) {
-        return NULL;
-    }
-    action = buf + pos;
-
-    while (pos < len && (!isspace((unsigned char)buf[pos]) && buf[pos] != ':'))
-        pos++;
-    buf[pos] = '\0';
-
-    return action;
-}
-
-static struct server *
-get_server(char *buf, int len)
-{
-    char *data = get_data(buf, len);
-    char error_buf[512];
-
-    if (data == NULL) {
-        LOGE("No data found");
-        return NULL;
-    }
-
-    json_settings settings = { 0 };
-    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);
-
-    if (obj == NULL) {
-        LOGE("%s", error_buf);
-        return NULL;
-    }
-
-    struct server *server = ss_malloc(sizeof(struct server));
-    memset(server, 0, sizeof(struct server));
-    if (obj->type == json_object) {
-        int i = 0;
-        for (i = 0; i < obj->u.object.length; i++) {
-            char *name        = obj->u.object.values[i].name;
-            json_value *value = obj->u.object.values[i].value;
-            if (strcmp(name, "server_port") == 0) {
-                if (value->type == json_string) {
-                    strncpy(server->port, value->u.string.ptr, 7);
-                } else if (value->type == json_integer) {
-                    snprintf(server->port, 8, "%" PRIu64 "", value->u.integer);
-                }
-            } else if (strcmp(name, "password") == 0) {
-                if (value->type == json_string) {
-                    strncpy(server->password, value->u.string.ptr, 127);
-                }
-            } else if (strcmp(name, "method") == 0) {
-                if (value->type == json_string) {
-                    server->method = strdup(value->u.string.ptr);
-                }
-            } else if (strcmp(name, "fast_open") == 0) {
-                if (value->type == json_boolean) {
-                    strncpy(server->fast_open, (value->u.boolean ? "true" : "false"), 8);
-                }
-            } else if (strcmp(name, "no_delay") == 0) {
-                if (value->type == json_boolean) {
-                    strncpy(server->no_delay, (value->u.boolean ? "true" : "false"), 8);
-                }
-            } else if (strcmp(name, "plugin") == 0) {
-                if (value->type == json_string) {
-                    server->plugin = strdup(value->u.string.ptr);
-                }
-            } else if (strcmp(name, "plugin_opts") == 0) {
-                if (value->type == json_string) {
-                    server->plugin_opts = strdup(value->u.string.ptr);
-                }
-            } else if (strcmp(name, "mode") == 0) {
-                if (value->type == json_string) {
-                    server->mode = strdup(value->u.string.ptr);
-                }
-            } else {
-                LOGE("invalid data: %s", data);
-                break;
-            }
-        }
-    }
-
-    json_value_free(obj);
-    return server;
-}
-
-static int
-parse_traffic(char *buf, int len, char *port, uint64_t *traffic)
-{
-    char *data = get_data(buf, len);
-    char error_buf[512];
-    json_settings settings = { 0 };
-
-    if (data == NULL) {
-        LOGE("No data found");
-        return -1;
-    }
-
-    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);
-    if (obj == NULL) {
-        LOGE("%s", error_buf);
-        return -1;
-    }
-
-    if (obj->type == json_object) {
-        int i = 0;
-        for (i = 0; i < obj->u.object.length; i++) {
-            char *name        = obj->u.object.values[i].name;
-            json_value *value = obj->u.object.values[i].value;
-            if (value->type == json_integer) {
-                strncpy(port, name, 7);
-                *traffic = value->u.integer;
-            }
-        }
-    }
-
-    json_value_free(obj);
-    return 0;
-}
-
-static int
-create_and_bind(const char *host, const char *port, int protocol)
-{
-    struct addrinfo hints;
-    struct addrinfo *result, *rp, *ipv4v6bindall;
-    int s, listen_sock = -1;
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_family   = AF_UNSPEC;                  /* Return IPv4 and IPv6 choices */
-    hints.ai_socktype = protocol == IPPROTO_TCP ?
-                        SOCK_STREAM : SOCK_DGRAM;   /* We want a TCP or UDP socket */
-    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; /* For wildcard IP address */
-    hints.ai_protocol = protocol;
-
-    s = getaddrinfo(host, port, &hints, &result);
-
-    if (s != 0) {
-        LOGE("getaddrinfo: %s", gai_strerror(s));
-        return -1;
-    }
-
-    rp = result;
-
-    /*
-     * On Linux, with net.ipv6.bindv6only = 0 (the default), getaddrinfo(NULL) with
-     * AI_PASSIVE returns 0.0.0.0 and :: (in this order). AI_PASSIVE was meant to
-     * return a list of addresses to listen on, but it is impossible to listen on
-     * 0.0.0.0 and :: at the same time, if :: implies dualstack mode.
-     */
-    if (!host) {
-        ipv4v6bindall = result;
-
-        /* Loop over all address infos found until a IPV6 address is found. */
-        while (ipv4v6bindall) {
-            if (ipv4v6bindall->ai_family == AF_INET6) {
-                rp = ipv4v6bindall; /* Take first IPV6 address available */
-                break;
-            }
-            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */
-        }
-    }
-
-    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {
-        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
-        if (listen_sock == -1) {
-            continue;
-        }
-
-        if (rp->ai_family == AF_INET6) {
-            int ipv6only = host ? 1 : 0;
-            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));
-        }
-
-        int opt = 1;
-        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-
-        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);
-        if (s == 0) {
-            /* We managed to bind successfully! */
-
-            close(listen_sock);
-
-            break;
-        } else {
-            ERROR("bind");
-        }
-    }
-
-    if (result != NULL) {
-        freeaddrinfo(result);
-    }
-
-    if (rp == NULL) {
-        LOGE("Could not bind");
-        return -1;
-    }
-
-    return listen_sock;
-}
-
-static int
-check_port(struct manager_ctx *manager, struct server *server)
-{
-    bool both_tcp_udp = manager->mode == TCP_AND_UDP;
-    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);
-    int bind_err      = 0;
-
-    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));
-    memset(sock_fds, 0, fd_count * sizeof(int));
-
-    /* try to bind each interface */
-    for (int i = 0; i < manager->host_num; i++) {
-        LOGI("try to bind interface: %s, port: %s", manager->hosts[i], server->port);
-
-        if (manager->mode == UDP_ONLY) {
-            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);
-        } else {
-            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);
-        }
-
-        if (both_tcp_udp) {
-            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);
-        }
-
-        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {
-            bind_err = -1;
-            break;
-        }
-    }
-
-    /* clean socks */
-    for (int i = 0; i < fd_count; i++)
-        if (sock_fds[i] > 0) {
-            close(sock_fds[i]);
-        }
-
-    ss_free(sock_fds);
-
-    return bind_err == -1 ? -1 : 0;
-}
-
-static int
-add_server(struct manager_ctx *manager, struct server *server)
-{
-    int ret = check_port(manager, server);
-
-    if (ret == -1) {
-        LOGE("port is not available, please check.");
-        return -1;
-    }
-
-    bool new = false;
-    cork_hash_table_put(server_table, (void *)server->port, (void *)server, &new, NULL, NULL);
-
-    char *cmd = construct_command_line(manager, server);
-    if (system(cmd) == -1) {
-        ERROR("add_server_system");
-        return -1;
-    }
-
-    return 0;
-}
-
-static void
-kill_server(char *prefix, char *pid_file)
-{
-    char *path = NULL;
-    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;
-    path = ss_malloc(path_size);
-    snprintf(path, path_size, "%s/%s", prefix, pid_file);
-    FILE *f = fopen(path, "r");
-    if (f == NULL) {
-        if (verbose) {
-            LOGE("unable to open pid file");
-        }
-        ss_free(path);
-        return;
-    }
-    if (fscanf(f, "%d", &pid) != EOF) {
-        kill(pid, SIGTERM);
-    }
-    fclose(f);
-    remove(path);
-    ss_free(path);
-}
-
-static void
-stop_server(char *prefix, char *port)
-{
-    char *path = NULL;
-    int pid, path_size = strlen(prefix) + strlen(port) + 20;
-    path = ss_malloc(path_size);
-    snprintf(path, path_size, "%s/.shadowsocks_%s.pid", prefix, port);
-    FILE *f = fopen(path, "r");
-    if (f == NULL) {
-        if (verbose) {
-            LOGE("unable to open pid file");
-        }
-        ss_free(path);
-        return;
-    }
-    if (fscanf(f, "%d", &pid) != EOF) {
-        kill(pid, SIGTERM);
-    }
-    fclose(f);
-    ss_free(path);
-}
-
-static void
-remove_server(char *prefix, char *port)
-{
-    char *old_port            = NULL;
-    struct server *old_server = NULL;
-
-    cork_hash_table_delete(server_table, (void *)port, (void **)&old_port, (void **)&old_server);
-
-    if (old_server != NULL) {
-        destroy_server(old_server);
-        ss_free(old_server);
-    }
-
-    stop_server(prefix, port);
-}
-
-static void
-update_stat(char *port, uint64_t traffic)
-{
-    if (verbose) {
-        LOGI("update traffic %" PRIu64 " for port %s", traffic, port);
-    }
-    void *ret = cork_hash_table_get(server_table, (void *)port);
-    if (ret != NULL) {
-        struct server *server = (struct server *)ret;
-        server->traffic = traffic;
-    }
-}
-
-static void
-manager_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    struct manager_ctx *manager = (struct manager_ctx *)w;
-    socklen_t len;
-    ssize_t r;
-    struct sockaddr_un claddr;
-    char buf[BUF_SIZE];
-
-    memset(buf, 0, BUF_SIZE);
-
-    len = sizeof(struct sockaddr_un);
-    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);
-    if (r == -1) {
-        ERROR("manager_recvfrom");
-        return;
-    }
-
-    if (r > BUF_SIZE / 2) {
-        LOGE("too large request: %d", (int)r);
-        return;
-    }
-
-    // properly terminate string which recvfrom does not do
-    buf[r] = '\0';
-
-    char *action = get_action(buf, r);
-    if (action == NULL) {
-        return;
-    }
-
-    if (strcmp(action, "add") == 0) {
-        struct server *server = get_server(buf, r);
-
-        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {
-            LOGE("invalid command: %s:%s", buf, get_data(buf, r));
-            if (server != NULL) {
-                destroy_server(server);
-                ss_free(server);
-            }
-            goto ERROR_MSG;
-        }
-
-        remove_server(working_dir, server->port);
-        int ret = add_server(manager, server);
-
-        char *msg;
-        int msg_len;
-
-        if (ret == -1) {
-            msg     = "port is not available";
-            msg_len = 21;
-        } else {
-            msg     = "ok";
-            msg_len = 2;
-        }
-
-        if (sendto(manager->fd, msg, msg_len, 0, (struct sockaddr *)&claddr, len) != 2) {
-            ERROR("add_sendto");
-        }
-    } else if (strcmp(action, "list") == 0) {
-        struct cork_hash_table_iterator iter;
-        struct cork_hash_table_entry  *entry;
-        char buf[BUF_SIZE];
-        memset(buf, 0, BUF_SIZE);
-        sprintf(buf, "[");
-
-        cork_hash_table_iterator_init(server_table, &iter);
-        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {
-            struct server *server = (struct server *)entry->value;
-            char *method          = server->method ? server->method : manager->method;
-            size_t pos            = strlen(buf);
-            size_t entry_len      = strlen(server->port) + strlen(server->password) + strlen(method);
-            if (pos > BUF_SIZE - entry_len - 50) {
-                if (sendto(manager->fd, buf, pos, 0, (struct sockaddr *)&claddr, len)
-                    != pos) {
-                    ERROR("list_sendto");
-                }
-                memset(buf, 0, BUF_SIZE);
-                pos = 0;
-            }
-            sprintf(buf + pos, "\n\t{\"server_port\":\"%s\",\"password\":\"%s\",\"method\":\"%s\"},",
-                    server->port, server->password, method);
-        }
-
-        size_t pos = strlen(buf);
-        strcpy(buf + max(pos - 1, 1), "\n]"); // Remove trailing ","
-        pos = strlen(buf);
-        if (sendto(manager->fd, buf, pos, 0, (struct sockaddr *)&claddr, len)
-            != pos) {
-            ERROR("list_sendto");
-        }
-    } else if (strcmp(action, "remove") == 0) {
-        struct server *server = get_server(buf, r);
-
-        if (server == NULL || server->port[0] == 0) {
-            LOGE("invalid command: %s:%s", buf, get_data(buf, r));
-            if (server != NULL) {
-                destroy_server(server);
-                ss_free(server);
-            }
-            goto ERROR_MSG;
-        }
-
-        remove_server(working_dir, server->port);
-        destroy_server(server);
-        ss_free(server);
-
-        char msg[3] = "ok";
-        if (sendto(manager->fd, msg, 2, 0, (struct sockaddr *)&claddr, len) != 2) {
-            ERROR("remove_sendto");
-        }
-    } else if (strcmp(action, "stat") == 0) {
-        char port[8];
-        uint64_t traffic = 0;
-
-        if (parse_traffic(buf, r, port, &traffic) == -1) {
-            LOGE("invalid command: %s:%s", buf, get_data(buf, r));
-            return;
-        }
-
-        update_stat(port, traffic);
-
-    } else if (strcmp(action, "ping") == 0) {
-        struct cork_hash_table_entry *entry;
-        struct cork_hash_table_iterator server_iter;
-
-        char buf[BUF_SIZE];
-
-        memset(buf, 0, BUF_SIZE);
-        sprintf(buf, "stat: {");
-
-        cork_hash_table_iterator_init(server_table, &server_iter);
-
-        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {
-            struct server *server = (struct server *)entry->value;
-            size_t pos            = strlen(buf);
-            if (pos > BUF_SIZE / 2) {
-                buf[pos - 1] = '}';
-                if (sendto(manager->fd, buf, pos, 0, (struct sockaddr *)&claddr, len)
-                    != pos) {
-                    ERROR("ping_sendto");
-                }
-                memset(buf, 0, BUF_SIZE);
-            } else {
-                sprintf(buf + pos, "\"%s\":%" PRIu64 ",", server->port, server->traffic);
-            }
-        }
-
-        size_t pos = strlen(buf);
-        if (pos > 7) {
-            buf[pos - 1] = '}';
-        } else {
-            buf[pos] = '}';
-            pos++;
-        }
-
-        if (sendto(manager->fd, buf, pos, 0, (struct sockaddr *)&claddr, len)
-            != pos) {
-            ERROR("ping_sendto");
-        }
-    }
-
-    return;
-
-ERROR_MSG:
-    strcpy(buf, "err");
-    if (sendto(manager->fd, buf, 3, 0, (struct sockaddr *)&claddr, len) != 3) {
-        ERROR("error_sendto");
-    }
-}
-
-static void
-signal_cb(EV_P_ ev_signal *w, int revents)
-{
-    if (revents & EV_SIGNAL) {
-        switch (w->signum) {
-        case SIGINT:
-        case SIGTERM:
-            ev_unloop(EV_A_ EVUNLOOP_ALL);
-        }
-    }
-}
-
-int
-create_server_socket(const char *host, const char *port)
-{
-    struct addrinfo hints;
-    struct addrinfo *result, *rp, *ipv4v6bindall;
-    int s, server_sock;
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_family   = AF_UNSPEC;               /* Return IPv4 and IPv6 choices */
-    hints.ai_socktype = SOCK_DGRAM;              /* We want a UDP socket */
-    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; /* For wildcard IP address */
-    hints.ai_protocol = IPPROTO_UDP;
-
-    s = getaddrinfo(host, port, &hints, &result);
-    if (s != 0) {
-        LOGE("getaddrinfo: %s", gai_strerror(s));
-        return -1;
-    }
-
-    rp = result;
-
-    /*
-     * On Linux, with net.ipv6.bindv6only = 0 (the default), getaddrinfo(NULL) with
-     * AI_PASSIVE returns 0.0.0.0 and :: (in this order). AI_PASSIVE was meant to
-     * return a list of addresses to listen on, but it is impossible to listen on
-     * 0.0.0.0 and :: at the same time, if :: implies dualstack mode.
-     */
-    if (!host) {
-        ipv4v6bindall = result;
-
-        /* Loop over all address infos found until a IPV6 address is found. */
-        while (ipv4v6bindall) {
-            if (ipv4v6bindall->ai_family == AF_INET6) {
-                rp = ipv4v6bindall; /* Take first IPV6 address available */
-                break;
-            }
-            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */
-        }
-    }
-
-    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {
-        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
-        if (server_sock == -1) {
-            continue;
-        }
-
-        if (rp->ai_family == AF_INET6) {
-            int ipv6only = host ? 1 : 0;
-            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));
-        }
-
-        int opt = 1;
-        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
-
-        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);
-        if (s == 0) {
-            /* We managed to bind successfully! */
-            break;
-        } else {
-            ERROR("bind");
-        }
-
-        close(server_sock);
-    }
-
-    if (result != NULL) {
-        freeaddrinfo(result);
-    }
-
-    if (rp == NULL) {
-        LOGE("cannot bind");
-        return -1;
-    }
-
-    return server_sock;
-}
-
-int
-main(int argc, char **argv)
-{
-    int i, c;
-    int pid_flags         = 0;
-    char *acl             = NULL;
-    char *user            = NULL;
-    char *password        = NULL;
-    char *timeout         = NULL;
-    char *method          = NULL;
-    char *pid_path        = NULL;
-    char *conf_path       = NULL;
-    char *iface           = NULL;
-    char *manager_address = NULL;
-    char *plugin          = NULL;
-    char *plugin_opts     = NULL;
-    char *workdir         = NULL;
-
-    int fast_open  = 0;
-    int no_delay   = 0;
-    int reuse_port = 0;
-    int mode       = TCP_ONLY;
-    int mtu        = 0;
-    int ipv6first  = 0;
-
-#ifdef HAVE_SETRLIMIT
-    static int nofile = 0;
-#endif
-
-    int server_num = 0;
-    char *server_host[MAX_REMOTE_NUM];
-
-    char *nameservers = NULL;
-
-    jconf_t *conf = NULL;
-
-    static struct option long_options[] = {
-        { "fast-open",       no_argument,       NULL, GETOPT_VAL_FAST_OPEN   },
-        { "no-delay",        no_argument,       NULL, GETOPT_VAL_NODELAY     },
-        { "reuse-port",      no_argument,       NULL, GETOPT_VAL_REUSE_PORT  },
-        { "acl",             required_argument, NULL, GETOPT_VAL_ACL         },
-        { "manager-address", required_argument, NULL,
-          GETOPT_VAL_MANAGER_ADDRESS },
-        { "executable",      required_argument, NULL,
-          GETOPT_VAL_EXECUTABLE },
-        { "mtu",             required_argument, NULL, GETOPT_VAL_MTU         },
-        { "plugin",          required_argument, NULL, GETOPT_VAL_PLUGIN      },
-        { "plugin-opts",     required_argument, NULL, GETOPT_VAL_PLUGIN_OPTS },
-        { "password",        required_argument, NULL, GETOPT_VAL_PASSWORD    },
-        { "workdir",         required_argument, NULL, GETOPT_VAL_WORKDIR     },
-        { "help",            no_argument,       NULL, GETOPT_VAL_HELP        },
-        { NULL,              0,                 NULL, 0                      }
-    };
-
-    opterr = 0;
-
-    USE_TTY();
-
-    while ((c = getopt_long(argc, argv, "f:s:l:k:t:m:c:i:d:a:n:D:6huUvA",
-                            long_options, NULL)) != -1)
-        switch (c) {
-        case GETOPT_VAL_REUSE_PORT:
-            reuse_port = 1;
-            break;
-        case GETOPT_VAL_FAST_OPEN:
-            fast_open = 1;
-            break;
-        case GETOPT_VAL_NODELAY:
-            no_delay = 1;
-            break;
-        case GETOPT_VAL_ACL:
-            acl = optarg;
-            break;
-        case GETOPT_VAL_MANAGER_ADDRESS:
-            manager_address = optarg;
-            break;
-        case GETOPT_VAL_EXECUTABLE:
-            executable = optarg;
-            break;
-        case GETOPT_VAL_MTU:
-            mtu = atoi(optarg);
-            break;
-        case GETOPT_VAL_PLUGIN:
-            plugin = optarg;
-            break;
-        case GETOPT_VAL_PLUGIN_OPTS:
-            plugin_opts = optarg;
-            break;
-        case 's':
-            if (server_num < MAX_REMOTE_NUM) {
-                server_host[server_num++] = optarg;
-            }
-            break;
-        case GETOPT_VAL_PASSWORD:
-        case 'k':
-            password = optarg;
-            break;
-        case 'f':
-            pid_flags = 1;
-            pid_path  = optarg;
-            break;
-        case 't':
-            timeout = optarg;
-            break;
-        case 'm':
-            method = optarg;
-            break;
-        case 'c':
-            conf_path = optarg;
-            break;
-        case 'i':
-            iface = optarg;
-            break;
-        case 'd':
-            nameservers = optarg;
-            break;
-        case 'a':
-            user = optarg;
-            break;
-        case 'u':
-            mode = TCP_AND_UDP;
-            break;
-        case 'U':
-            mode = UDP_ONLY;
-            break;
-        case '6':
-            ipv6first = 1;
-            break;
-        case GETOPT_VAL_WORKDIR:
-        case 'D':
-            workdir = optarg;
-            break;
-        case 'v':
-            verbose = 1;
-            break;
-        case GETOPT_VAL_HELP:
-        case 'h':
-            usage();
-            exit(EXIT_SUCCESS);
-#ifdef HAVE_SETRLIMIT
-        case 'n':
-            nofile = atoi(optarg);
-            break;
-#endif
-        case 'A':
-            FATAL("One time auth has been deprecated. Try AEAD ciphers instead.");
-            break;
-        case '?':
-            // The option character is not recognized.
-            LOGE("Unrecognized option: %s", optarg);
-            opterr = 1;
-            break;
-        }
-
-    if (opterr) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-    if (conf_path != NULL) {
-        conf = read_jconf(conf_path);
-        if (server_num == 0) {
-            server_num = conf->remote_num;
-            for (i = 0; i < server_num; i++)
-                server_host[i] = conf->remote_addr[i].host;
-        }
-        if (password == NULL) {
-            password = conf->password;
-        }
-        if (method == NULL) {
-            method = conf->method;
-        }
-        if (timeout == NULL) {
-            timeout = conf->timeout;
-        }
-        if (user == NULL) {
-            user = conf->user;
-        }
-        if (fast_open == 0) {
-            fast_open = conf->fast_open;
-        }
-        if (no_delay == 0) {
-            no_delay = conf->no_delay;
-        }
-        if (reuse_port == 0) {
-            reuse_port = conf->reuse_port;
-        }
-        if (nameservers == NULL) {
-            nameservers = conf->nameserver;
-        }
-        if (mode == TCP_ONLY) {
-            mode = conf->mode;
-        }
-        if (mtu == 0) {
-            mtu = conf->mtu;
-        }
-        if (plugin == NULL) {
-            plugin = conf->plugin;
-        }
-        if (plugin_opts == NULL) {
-            plugin_opts = conf->plugin_opts;
-        }
-        if (ipv6first == 0) {
-            ipv6first = conf->ipv6_first;
-        }
-        if (workdir == NULL) {
-            workdir = conf->workdir;
-        }
-        if (acl == NULL) {
-            acl = conf->acl;
-        }
-        if (manager_address == NULL) {
-            manager_address = conf->manager_address;
-        }
-#ifdef HAVE_SETRLIMIT
-        if (nofile == 0) {
-            nofile = conf->nofile;
-        }
-#endif
-    }
-
-    if (server_num == 0) {
-        server_host[server_num++] = "0.0.0.0";
-    }
-
-    if (method == NULL) {
-        method = "table";
-    }
-
-    if (timeout == NULL) {
-        timeout = "60";
-    }
-
-    USE_SYSLOG(argv[0], pid_flags);
-    if (pid_flags) {
-        daemonize(pid_path);
-    }
-
-    if (server_num == 0) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-    if (fast_open == 1) {
-#ifdef TCP_FASTOPEN
-        LOGI("using tcp fast open");
-#else
-        LOGE("tcp fast open is not supported by this environment");
-#endif
-    }
-
-    if (no_delay == 1) {
-        LOGI("using tcp no-delay");
-    }
-
-#ifndef __MINGW32__
-    // setuid
-    if (user != NULL && !run_as(user)) {
-        FATAL("failed to switch user");
-    }
-
-    if (geteuid() == 0) {
-        LOGI("running from root user");
-    }
-#endif
-
-    struct passwd *pw = getpwuid(getuid());
-
-    if (workdir == NULL || strlen(workdir) == 0) {
-        workdir = pw->pw_dir;
-        // If home dir is still not defined or set to nologin/nonexistent, fall back to /tmp
-        if (workdir == NULL || strlen(workdir) == 0 || strstr(workdir, "nologin") || strstr(workdir, "nonexistent")) {
-            workdir = "/tmp";
-        }
-
-        working_dir_size = strlen(workdir) + 15;
-        working_dir      = ss_malloc(working_dir_size);
-        snprintf(working_dir, working_dir_size, "%s/.shadowsocks", workdir);
-    } else {
-        working_dir_size = strlen(workdir) + 2;
-        working_dir      = ss_malloc(working_dir_size);
-        snprintf(working_dir, working_dir_size, "%s", workdir);
-    }
-    LOGI("working directory points to %s", working_dir);
-
-    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
-    if (err != 0 && errno != EEXIST) {
-        ERROR("mkdir");
-        ss_free(working_dir);
-        FATAL("unable to create working directory");
-    }
-
-    if (manager_address == NULL) {
-        size_t manager_address_size = strlen(workdir) + 20;
-        manager_address = ss_malloc(manager_address_size);
-        snprintf(manager_address, manager_address_size, "%s/.ss-manager.socks", workdir);
-        LOGI("using the default manager address: %s", manager_address);
-    }
-
-    // ignore SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGCHLD, SIG_IGN);
-    signal(SIGABRT, SIG_IGN);
-
-    struct ev_signal sigint_watcher;
-    struct ev_signal sigterm_watcher;
-    ev_signal_init(&sigint_watcher, signal_cb, SIGINT);
-    ev_signal_init(&sigterm_watcher, signal_cb, SIGTERM);
-    ev_signal_start(EV_DEFAULT, &sigint_watcher);
-    ev_signal_start(EV_DEFAULT, &sigterm_watcher);
-
-    struct manager_ctx manager;
-    memset(&manager, 0, sizeof(struct manager_ctx));
-
-    manager.reuse_port      = reuse_port;
-    manager.fast_open       = fast_open;
-    manager.no_delay        = no_delay;
-    manager.verbose         = verbose;
-    manager.mode            = mode;
-    manager.password        = password;
-    manager.timeout         = timeout;
-    manager.method          = method;
-    manager.iface           = iface;
-    manager.acl             = acl;
-    manager.user            = user;
-    manager.manager_address = manager_address;
-    manager.hosts           = server_host;
-    manager.host_num        = server_num;
-    manager.nameservers     = nameservers;
-    manager.mtu             = mtu;
-    manager.plugin          = plugin;
-    manager.plugin_opts     = plugin_opts;
-    manager.ipv6first       = ipv6first;
-    manager.workdir         = workdir;
-#ifdef HAVE_SETRLIMIT
-    manager.nofile = nofile;
-#endif
-
-    // initialize ev loop
-    struct ev_loop *loop = EV_DEFAULT;
-
-    // Clean up all existed processes
-    DIR *dp;
-    struct dirent *ep;
-    dp = opendir(working_dir);
-    if (dp != NULL) {
-        while ((ep = readdir(dp)) != NULL) {
-            size_t len = strlen(ep->d_name);
-            if (strcmp(ep->d_name + len - 3, "pid") == 0) {
-                kill_server(working_dir, ep->d_name);
-                if (verbose)
-                    LOGI("kill %s", ep->d_name);
-            }
-        }
-        closedir(dp);
-    } else {
-        ss_free(working_dir);
-        FATAL("Couldn't open the directory");
-    }
-
-    server_table = cork_string_hash_table_new(MAX_PORT_NUM, 0);
-
-    if (conf != NULL) {
-        for (i = 0; i < conf->port_password_num; i++) {
-            struct server *server = ss_malloc(sizeof(struct server));
-            memset(server, 0, sizeof(struct server));
-            strncpy(server->port, conf->port_password[i].port, 7);
-            strncpy(server->password, conf->port_password[i].password, 127);
-            add_server(&manager, server);
-        }
-    }
-
-    int sfd;
-    ss_addr_t ip_addr = { .host = NULL, .port = NULL };
-    parse_addr(manager_address, &ip_addr);
-
-    if (ip_addr.host == NULL || ip_addr.port == NULL) {
-        struct sockaddr_un svaddr;
-        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /*  Create server socket */
-        if (sfd == -1) {
-            ss_free(working_dir);
-            FATAL("socket");
-        }
-
-        setnonblocking(sfd);
-
-        if (remove(manager_address) == -1 && errno != ENOENT) {
-            ERROR("bind");
-            ss_free(working_dir);
-            exit(EXIT_FAILURE);
-        }
-
-        memset(&svaddr, 0, sizeof(struct sockaddr_un));
-        svaddr.sun_family = AF_UNIX;
-        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);
-
-        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {
-            ERROR("bind");
-            ss_free(working_dir);
-            exit(EXIT_FAILURE);
-        }
-    } else {
-        sfd = create_server_socket(ip_addr.host, ip_addr.port);
-        if (sfd == -1) {
-            ss_free(working_dir);
-            FATAL("socket");
-        }
-    }
-
-    manager.fd = sfd;
-    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);
-    ev_io_start(loop, &manager.io);
-
-    // start ev loop
-    ev_run(loop, 0);
-
-    if (verbose) {
-        LOGI("closed gracefully");
-    }
-
-    // Clean up
-    struct cork_hash_table_entry *entry;
-    struct cork_hash_table_iterator server_iter;
-
-    cork_hash_table_iterator_init(server_table, &server_iter);
-
-    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {
-        struct server *server = (struct server *)entry->value;
-        stop_server(working_dir, server->port);
-    }
-
-    ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-    ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-    ss_free(working_dir);
-    free_addr(&ip_addr);
-
-    return 0;
-}
diff --git a/src/manager.h b/src/manager.h
deleted file mode 100644
index d5aa832..0000000
--- a/src/manager.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * server.h - Define shadowsocks server's buffers and callbacks
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _MANAGER_H
-#define _MANAGER_H
-
-#include <time.h>
-#include <libcork/ds.h>
-
-#ifdef HAVE_LIBEV_EV_H
-#include <libev/ev.h>
-#else
-#include <ev.h>
-#endif
-
-#include "jconf.h"
-
-#include "common.h"
-
-struct manager_ctx {
-    ev_io io;
-    int fd;
-    int fast_open;
-    int no_delay;
-    int reuse_port;
-    int verbose;
-    int mode;
-    char *password;
-    char *key;
-    char *timeout;
-    char *method;
-    char *iface;
-    char *acl;
-    char *user;
-    char *plugin;
-    char *plugin_opts;
-    char *manager_address;
-    char **hosts;
-    int host_num;
-    char *nameservers;
-    int mtu;
-    int ipv6first;
-    char *workdir;
-#ifdef HAVE_SETRLIMIT
-    int nofile;
-#endif
-};
-
-struct server {
-    char port[8];
-    char password[128];
-    char fast_open[8];
-    char no_delay[8];
-    char *mode;
-    char *method;
-    char *plugin;
-    char *plugin_opts;
-    uint64_t traffic;
-};
-
-#endif // _MANAGER_H
diff --git a/src/netutils.c b/src/netutils.c
index 8c7329a..7b32805 100644
--- a/src/netutils.c
+++ b/src/netutils.c
@@ -28,14 +28,12 @@
 #include "config.h"
 #endif
 
-#ifndef __MINGW32__
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <netinet/in.h>
 #include <unistd.h>
-#endif
 
-#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
+#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H)
 #include <net/if.h>
 #include <sys/ioctl.h>
 #define SET_INTERFACE
@@ -149,10 +147,6 @@ get_sockaddr(char *host, char *port,
         }
         return 0;
     } else {
-#ifdef __ANDROID__
-        extern int vpn;
-        assert(!vpn);   // protecting DNS packets isn't supported yet
-#endif
         struct addrinfo hints;
         struct addrinfo *result, *rp;
 
diff --git a/src/plugin.c b/src/plugin.c
index b67a9a4..4dba96c 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -25,12 +25,10 @@
 #endif
 
 #include <string.h>
-#ifndef __MINGW32__
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
 #include <netinet/in.h>
-#endif
 
 #include <libcork/core.h>
 #include <libcork/os.h>
@@ -41,20 +39,12 @@
 
 #define CMD_RESRV_LEN 128
 
-#ifndef __MINGW32__
 #define TEMPDIR "/tmp/"
-#else
-#define TEMPDIR
-#endif
 
 static int exit_code;
 static struct cork_env *env        = NULL;
 static struct cork_exec *exec      = NULL;
 static struct cork_subprocess *sub = NULL;
-#ifdef __MINGW32__
-static uint16_t sub_control_port = 0;
-void cork_subprocess_set_control(struct cork_subprocess *self, uint16_t port);
-#endif
 
 static int
 plugin_log__data(struct cork_stream_consumer *vself,
@@ -224,9 +214,6 @@ start_obfsproxy(const char *plugin,
 
     cork_exec_set_env(exec, env);
     sub = cork_subprocess_new_exec(exec, NULL, NULL, &exit_code);
-#ifdef __MINGW32__
-    cork_subprocess_set_control(sub, sub_control_port);
-#endif
     ret = cork_subprocess_start(sub);
     ss_free(opts_dump);
     free(buf);
@@ -240,16 +227,11 @@ start_plugin(const char *plugin,
              const char *remote_port,
              const char *local_host,
              const char *local_port,
-#ifdef __MINGW32__
-             uint16_t control_port,
-#endif
              enum plugin_mode mode)
 {
-#ifndef __MINGW32__
     char *new_path = NULL;
     const char *current_path;
     size_t new_path_len;
-#endif
     int ret;
 
     if (plugin == NULL)
@@ -258,20 +240,14 @@ start_plugin(const char *plugin,
     if (strlen(plugin) == 0)
         return 0;
 
-#ifndef __MINGW32__
     /*
      * Add current dir to PATH, so we can search plugin in current dir
      */
     env          = cork_env_clone_current();
     current_path = cork_env_get(env, "PATH");
     if (current_path != NULL) {
-#ifdef HAVE_GET_CURRENT_DIR_NAME
         char *cwd = get_current_dir_name();
         if (cwd) {
-#else
-        char cwd[PATH_MAX];
-        if (getcwd(cwd, PATH_MAX) != NULL) {
-#endif
             new_path_len = strlen(current_path) + strlen(cwd) + 2;
             new_path     = ss_malloc(new_path_len);
             snprintf(new_path, new_path_len, "%s:%s", cwd, current_path);
@@ -282,9 +258,6 @@ start_plugin(const char *plugin,
     }
     if (new_path != NULL)
         cork_env_add(env, "PATH", new_path);
-#else
-    sub_control_port = control_port;
-#endif
 
     if (!strncmp(plugin, "obfsproxy", strlen("obfsproxy")))
         ret = start_obfsproxy(plugin, plugin_opts, remote_host, remote_port,
@@ -292,9 +265,7 @@ start_plugin(const char *plugin,
     else
         ret = start_ss_plugin(plugin, plugin_opts, remote_host, remote_port,
                               local_host, local_port, mode);
-#ifndef __MINGW32__
     ss_free(new_path);
-#endif
     env = NULL;
     return ret;
 }
@@ -334,11 +305,9 @@ stop_plugin()
 {
     if (sub != NULL) {
         cork_subprocess_abort(sub);
-#ifndef __MINGW32__
         if (cork_subprocess_wait(sub) == -1) {
             LOGI("error on terminating the plugin.");
         }
-#endif
         cork_subprocess_free(sub);
     }
 }
diff --git a/src/plugin.h b/src/plugin.h
index 1a6d4b4..bf2acd5 100644
--- a/src/plugin.h
+++ b/src/plugin.h
@@ -69,9 +69,6 @@ int start_plugin(const char *plugin,
                  const char *remote_port,
                  const char *local_host,
                  const char *local_port,
-#ifdef __MINGW32__
-                 uint16_t control_port,
-#endif
                  enum plugin_mode mode);
 uint16_t get_local_port();
 void stop_plugin();
diff --git a/src/resolv.c b/src/resolv.c
deleted file mode 100644
index 8d203fd..0000000
--- a/src/resolv.c
+++ /dev/null
@@ -1,497 +0,0 @@
-/*
- * Copyright (c) 2014, Dustin Lundquist <dustin@null-ptr.net>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#ifndef __MINGW32__
-#include <netdb.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <errno.h>
-#include <unistd.h>
-#else
-#include "winsock.h" // Should be before <ares.h>
-#endif
-#include <ares.h>
-
-#ifdef HAVE_LIBEV_EV_H
-#include <libev/ev.h>
-#else
-#include <ev.h>
-#endif
-
-#include <libcork/core.h>
-
-#include "resolv.h"
-#include "utils.h"
-#include "netutils.h"
-
-#ifdef __MINGW32__
-#define CONV_STATE_CB (ares_sock_state_cb)
-#else
-#define CONV_STATE_CB
-#endif
-
-/*
- * Implement DNS resolution interface using libc-ares
- */
-
-#define SS_NUM_IOS 6
-#define SS_INVALID_FD -1
-#define SS_TIMER_AFTER 1.0
-
-struct resolv_ctx {
-    struct ev_io ios[SS_NUM_IOS];
-    struct ev_timer timer;
-    ev_tstamp last_tick;
-
-    ares_channel channel;
-    struct ares_options options;
-};
-
-struct resolv_query {
-    int requests[2];
-    size_t response_count;
-    struct sockaddr **responses;
-
-    void (*client_cb)(struct sockaddr *, void *);
-    void (*free_cb)(void *);
-
-    uint16_t port;
-
-    void *data;
-
-    int is_closed;
-};
-
-extern int verbose;
-
-static struct resolv_ctx default_ctx;
-static struct ev_loop *default_loop;
-
-enum {
-    MODE_IPV4_FIRST = 0,
-    MODE_IPV6_FIRST = 1
-} RESOLV_MODE;
-
-static int resolv_mode = MODE_IPV4_FIRST;
-
-static void resolv_sock_cb(struct ev_loop *, struct ev_io *, int);
-static void resolv_timer_cb(struct ev_loop *, struct ev_timer *, int);
-static void resolv_sock_state_cb(void *, int, int, int);
-
-static void dns_query_v4_cb(void *, int, int, struct hostent *);
-static void dns_query_v6_cb(void *, int, int, struct hostent *);
-
-static void process_client_callback(struct resolv_query *);
-static inline int all_requests_are_null(struct resolv_query *);
-static struct sockaddr *choose_ipv4_first(struct resolv_query *);
-static struct sockaddr *choose_ipv6_first(struct resolv_query *);
-static struct sockaddr *choose_any(struct resolv_query *);
-
-/*
- * DNS UDP socket activity callback
- */
-static void
-resolv_sock_cb(EV_P_ ev_io *w, int revents)
-{
-    ares_socket_t rfd = ARES_SOCKET_BAD, wfd = ARES_SOCKET_BAD;
-
-    if (revents & EV_READ)
-        rfd = w->fd;
-    if (revents & EV_WRITE)
-        wfd = w->fd;
-
-    default_ctx.last_tick = ev_now(default_loop);
-
-    ares_process_fd(default_ctx.channel, rfd, wfd);
-}
-
-int
-resolv_init(struct ev_loop *loop, char *nameservers, int ipv6first)
-{
-    int status;
-
-    if (ipv6first)
-        resolv_mode = MODE_IPV6_FIRST;
-    else
-        resolv_mode = MODE_IPV4_FIRST;
-
-    default_loop = loop;
-
-    if ((status = ares_library_init(ARES_LIB_INIT_ALL)) != ARES_SUCCESS) {
-        LOGE("c-ares error: %s", ares_strerror(status));
-        FATAL("failed to initialize c-ares");
-    }
-
-    memset(&default_ctx, 0, sizeof(struct resolv_ctx));
-
-    default_ctx.options.sock_state_cb_data = &default_ctx;
-    default_ctx.options.sock_state_cb      = CONV_STATE_CB resolv_sock_state_cb;
-    default_ctx.options.timeout            = 3000;
-    default_ctx.options.tries              = 2;
-
-    status = ares_init_options(&default_ctx.channel, &default_ctx.options,
-#if ARES_VERSION_MAJOR >= 1 && ARES_VERSION_MINOR >= 12
-                               ARES_OPT_NOROTATE |
-#endif
-                               ARES_OPT_TIMEOUTMS | ARES_OPT_TRIES | ARES_OPT_SOCK_STATE_CB);
-
-    if (status != ARES_SUCCESS) {
-        FATAL("failed to initialize c-ares");
-    }
-
-    if (nameservers != NULL) {
-#if ARES_VERSION_MAJOR >= 1 && ARES_VERSION_MINOR >= 11
-        status = ares_set_servers_ports_csv(default_ctx.channel, nameservers);
-#else
-        status = ares_set_servers_csv(default_ctx.channel, nameservers);
-#endif
-    }
-
-    if (status != ARES_SUCCESS) {
-        FATAL("failed to set nameservers");
-    }
-
-    for (int i = 0; i < SS_NUM_IOS; i++)
-        ev_io_init(&default_ctx.ios[i], resolv_sock_cb, SS_INVALID_FD, 0);
-
-    default_ctx.last_tick = ev_now(default_loop);
-    ev_init(&default_ctx.timer, resolv_timer_cb);
-    resolv_timer_cb(default_loop, &default_ctx.timer, 0);
-
-    return 0;
-}
-
-void
-resolv_shutdown(struct ev_loop *loop)
-{
-    ev_timer_stop(default_loop, &default_ctx.timer);
-    for (int i = 0; i < SS_NUM_IOS; i++)
-        ev_io_stop(default_loop, &default_ctx.ios[i]);
-
-    ares_cancel(default_ctx.channel);
-    ares_destroy(default_ctx.channel);
-
-    ares_library_cleanup();
-}
-
-void
-resolv_start(const char *hostname, uint16_t port,
-             void (*client_cb)(struct sockaddr *, void *),
-             void (*free_cb)(void *), void *data)
-{
-    /*
-     * Wrap c-ares's call back in our own
-     */
-    struct resolv_query *query = ss_malloc(sizeof(struct resolv_query));
-
-    memset(query, 0, sizeof(struct resolv_query));
-
-    query->port           = port;
-    query->client_cb      = client_cb;
-    query->response_count = 0;
-    query->responses      = NULL;
-    query->data           = data;
-    query->free_cb        = free_cb;
-
-    query->requests[0] = AF_INET;
-    query->requests[1] = AF_INET6;
-
-    ares_gethostbyname(default_ctx.channel, hostname, AF_INET, dns_query_v4_cb, query);
-    ares_gethostbyname(default_ctx.channel, hostname, AF_INET6, dns_query_v6_cb, query);
-}
-
-/*
- * Wrapper for client callback we provide to c-ares
- */
-static void
-dns_query_v4_cb(void *arg, int status, int timeouts, struct hostent *he)
-{
-    int i, n;
-    struct resolv_query *query = (struct resolv_query *)arg;
-
-    if (status == ARES_EDESTRUCTION) {
-        return;
-    }
-
-    if (!he || status != ARES_SUCCESS) {
-        if (verbose) {
-            LOGI("failed to lookup v4 address %s", ares_strerror(status));
-        }
-        goto CLEANUP;
-    }
-
-    if (verbose) {
-        LOGI("found address name v4 address %s", he->h_name);
-    }
-
-    n = 0;
-    while (he->h_addr_list[n])
-        n++;
-
-    if (n > 0) {
-        struct sockaddr **new_responses = ss_realloc(query->responses,
-                                                     (query->response_count + n)
-                                                     * sizeof(struct sockaddr *));
-
-        if (new_responses == NULL) {
-            LOGE("failed to allocate memory for additional DNS responses");
-        } else {
-            query->responses = new_responses;
-
-            for (i = 0; i < n; i++) {
-                struct sockaddr_in *sa = ss_malloc(sizeof(struct sockaddr_in));
-                memset(sa, 0, sizeof(struct sockaddr_in));
-                sa->sin_family = AF_INET;
-                sa->sin_port   = query->port;
-                memcpy(&sa->sin_addr, he->h_addr_list[i], he->h_length);
-
-                query->responses[query->response_count] = (struct sockaddr *)sa;
-                if (query->responses[query->response_count] == NULL) {
-                    LOGE("failed to allocate memory for DNS query result address");
-                } else {
-                    query->response_count++;
-                }
-            }
-        }
-    }
-
-CLEANUP:
-
-    query->requests[0] = 0; /* mark A query as being completed */
-
-    /* Once all requests have completed, call client callback */
-    if (all_requests_are_null(query)) {
-        return process_client_callback(query);
-    }
-}
-
-static void
-dns_query_v6_cb(void *arg, int status, int timeouts, struct hostent *he)
-{
-    int i, n;
-    struct resolv_query *query = (struct resolv_query *)arg;
-
-    if (status == ARES_EDESTRUCTION) {
-        return;
-    }
-
-    if (!he || status != ARES_SUCCESS) {
-        if (verbose) {
-            LOGI("failed to lookup v6 address %s", ares_strerror(status));
-        }
-        goto CLEANUP;
-    }
-
-    if (verbose) {
-        LOGI("found address name v6 address %s", he->h_name);
-    }
-
-    n = 0;
-    while (he->h_addr_list[n])
-        n++;
-
-    if (n > 0) {
-        struct sockaddr **new_responses = ss_realloc(query->responses,
-                                                     (query->response_count + n)
-                                                     * sizeof(struct sockaddr *));
-
-        if (new_responses == NULL) {
-            LOGE("failed to allocate memory for additional DNS responses");
-        } else {
-            query->responses = new_responses;
-
-            for (i = 0; i < n; i++) {
-                struct sockaddr_in6 *sa = ss_malloc(sizeof(struct sockaddr_in6));
-                memset(sa, 0, sizeof(struct sockaddr_in6));
-                sa->sin6_family = AF_INET6;
-                sa->sin6_port   = query->port;
-                memcpy(&sa->sin6_addr, he->h_addr_list[i], he->h_length);
-
-                query->responses[query->response_count] = (struct sockaddr *)sa;
-                if (query->responses[query->response_count] == NULL) {
-                    LOGE("failed to allocate memory for DNS query result address");
-                } else {
-                    query->response_count++;
-                }
-            }
-        }
-    }
-
-CLEANUP:
-
-    query->requests[1] = 0; /* mark A query as being completed */
-
-    /* Once all requests have completed, call client callback */
-    if (all_requests_are_null(query)) {
-        return process_client_callback(query);
-    }
-}
-
-/*
- * Called once all requests have been completed
- */
-static void
-process_client_callback(struct resolv_query *query)
-{
-    struct sockaddr *best_address = NULL;
-
-    if (resolv_mode == MODE_IPV4_FIRST) {
-        best_address = choose_ipv4_first(query);
-    } else if (resolv_mode == MODE_IPV6_FIRST) {
-        best_address = choose_ipv6_first(query);
-    } else {
-        best_address = choose_any(query);
-    }
-
-    query->client_cb(best_address, query->data);
-
-    for (int i = 0; i < query->response_count; i++)
-        ss_free(query->responses[i]);
-
-    ss_free(query->responses);
-
-    if (query->free_cb != NULL)
-        query->free_cb(query->data);
-    else
-        ss_free(query->data);
-
-    ss_free(query);
-}
-
-static struct sockaddr *
-choose_ipv4_first(struct resolv_query *query)
-{
-    for (int i = 0; i < query->response_count; i++)
-        if (query->responses[i]->sa_family == AF_INET) {
-            return query->responses[i];
-        }
-
-    return choose_any(query);
-}
-
-static struct sockaddr *
-choose_ipv6_first(struct resolv_query *query)
-{
-    for (int i = 0; i < query->response_count; i++)
-        if (query->responses[i]->sa_family == AF_INET6) {
-            return query->responses[i];
-        }
-
-    return choose_any(query);
-}
-
-static struct sockaddr *
-choose_any(struct resolv_query *query)
-{
-    if (query->response_count >= 1) {
-        return query->responses[0];
-    }
-
-    return NULL;
-}
-
-static inline int
-all_requests_are_null(struct resolv_query *query)
-{
-    int result = 1;
-
-    for (int i = 0; i < sizeof(query->requests) / sizeof(query->requests[0]);
-         i++)
-        result = result && query->requests[i] == 0;
-
-    return result;
-}
-
-/*
- *  Timer callback
- */
-static void
-resolv_timer_cb(struct ev_loop *loop, struct ev_timer *w, int revents)
-{
-    struct resolv_ctx *ctx = cork_container_of(w, struct resolv_ctx, timer);
-
-    ev_tstamp now   = ev_now(default_loop);
-    ev_tstamp after = ctx->last_tick - now + SS_TIMER_AFTER;
-
-    if (after < 0.0) {
-        ctx->last_tick = now;
-        ares_process_fd(ctx->channel, ARES_SOCKET_BAD, ARES_SOCKET_BAD);
-
-        ev_timer_set(w, SS_TIMER_AFTER, 0.0);
-    } else {
-        ev_timer_set(w, after, 0.0);
-    }
-
-    ev_timer_start(loop, w);
-}
-
-/*
- * Handle c-ares events
- */
-static void
-resolv_sock_state_cb(void *data, int s, int read, int write)
-{
-    struct resolv_ctx *ctx = (struct resolv_ctx *)data;
-    int events             = (read ? EV_READ : 0) | (write ? EV_WRITE : 0);
-
-    int i = 0, ffi = -1;
-    for (; i < SS_NUM_IOS; i++) {
-        if (ctx->ios[i].fd == s) {
-            break;
-        }
-
-        if (ffi < 0 && ctx->ios[i].fd == SS_INVALID_FD) {
-            // first free index
-            ffi = i;
-        }
-    }
-
-    if (i < SS_NUM_IOS) {
-        ev_io_stop(default_loop, &ctx->ios[i]);
-    } else if (ffi > -1) {
-        i = ffi;
-    } else {
-        LOGE("failed to find free I/O watcher slot for DNS query");
-        // last resort: stop io and re-use slot, will cause timeout
-        i = 0;
-        ev_io_stop(default_loop, &ctx->ios[i]);
-    }
-
-    if (events) {
-        ev_io_set(&ctx->ios[i], s, events);
-        ev_io_start(default_loop, &ctx->ios[i]);
-    } else {
-        ev_io_set(&ctx->ios[i], SS_INVALID_FD, 0);
-    }
-}
diff --git a/src/resolv.h b/src/resolv.h
deleted file mode 100644
index e211abc..0000000
--- a/src/resolv.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2014, Dustin Lundquist <dustin@null-ptr.net>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef RESOLV_H
-#define RESOLV_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <stdint.h>
-#ifndef __MINGW32__
-#include <sys/socket.h>
-#endif
-
-struct resolv_query;
-
-int resolv_init(struct ev_loop *, char *, int);
-void resolv_start(const char *hostname, uint16_t port,
-                  void (*client_cb)(struct sockaddr *, void *),
-                  void (*free_cb)(void *), void *data);
-void resolv_shutdown(struct ev_loop *);
-
-#endif
diff --git a/src/rule.c b/src/rule.c
deleted file mode 100644
index 737013e..0000000
--- a/src/rule.c
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (c) 2011 and 2012, Dustin Lundquist <dustin@null-ptr.net>
- * Copyright (c) 2011 Manuel Kasper <mk@neon1.net>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <stdio.h>
-#include <string.h>
-
-#include "rule.h"
-#include "utils.h"
-
-static void free_rule(rule_t *);
-
-rule_t *
-new_rule()
-{
-    rule_t *rule;
-
-    rule = calloc(1, sizeof(rule_t));
-    if (rule == NULL) {
-        ERROR("malloc");
-        return NULL;
-    }
-
-    return rule;
-}
-
-int
-accept_rule_arg(rule_t *rule, const char *arg)
-{
-    if (rule->pattern == NULL) {
-        rule->pattern = strdup(arg);
-        if (rule->pattern == NULL) {
-            ERROR("strdup failed");
-            return -1;
-        }
-    } else {
-        LOGE("Unexpected table rule argument: %s", arg);
-        return -1;
-    }
-
-    return 1;
-}
-
-void
-add_rule(struct cork_dllist *rules, rule_t *rule)
-{
-    cork_dllist_add(rules, &rule->entries);
-}
-
-int
-init_rule(rule_t *rule)
-{
-    if (rule->pattern_re == NULL) {
-        const char *reerr;
-        int reerroffset;
-
-        rule->pattern_re =
-            pcre_compile(rule->pattern, 0, &reerr, &reerroffset, NULL);
-        if (rule->pattern_re == NULL) {
-            LOGE("Regex compilation of \"%s\" failed: %s, offset %d",
-                 rule->pattern, reerr, reerroffset);
-            return 0;
-        }
-    }
-
-    return 1;
-}
-
-rule_t *
-lookup_rule(const struct cork_dllist *rules, const char *name, size_t name_len)
-{
-    struct cork_dllist_item *curr, *next;
-
-    if (name == NULL) {
-        name     = "";
-        name_len = 0;
-    }
-
-    cork_dllist_foreach_void(rules, curr, next) {
-        rule_t *rule = cork_container_of(curr, rule_t, entries);
-        if (pcre_exec(rule->pattern_re, NULL,
-                      name, name_len, 0, 0, NULL, 0) >= 0)
-            return rule;
-    }
-
-    return NULL;
-}
-
-void
-remove_rule(rule_t *rule)
-{
-    cork_dllist_remove(&rule->entries);
-    free_rule(rule);
-}
-
-static void
-free_rule(rule_t *rule)
-{
-    if (rule == NULL)
-        return;
-
-    ss_free(rule->pattern);
-    if (rule->pattern_re != NULL)
-        pcre_free(rule->pattern_re);
-    ss_free(rule);
-}
diff --git a/src/rule.h b/src/rule.h
deleted file mode 100644
index 015bc42..0000000
--- a/src/rule.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (c) 2011 and 2012, Dustin Lundquist <dustin@null-ptr.net>
- * Copyright (c) 2011 Manuel Kasper <mk@neon1.net>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef RULE_H
-#define RULE_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <libcork/ds.h>
-
-#ifdef HAVE_PCRE_H
-#include <pcre.h>
-#elif HAVE_PCRE_PCRE_H
-#include <pcre/pcre.h>
-#endif
-
-typedef struct rule {
-    char *pattern;
-
-    /* Runtime fields */
-    pcre *pattern_re;
-
-    struct cork_dllist_item entries;
-} rule_t;
-
-void add_rule(struct cork_dllist *, rule_t *);
-int init_rule(rule_t *);
-rule_t *lookup_rule(const struct cork_dllist *, const char *, size_t);
-void remove_rule(rule_t *);
-rule_t *new_rule();
-int accept_rule_arg(rule_t *, const char *);
-
-#endif
diff --git a/src/server.c b/src/server.c
deleted file mode 100644
index 73b6599..0000000
--- a/src/server.c
+++ /dev/null
@@ -1,2428 +0,0 @@
-/*
- * server.c - Provide shadowsocks service
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <locale.h>
-#include <signal.h>
-#include <string.h>
-#include <strings.h>
-#include <time.h>
-#include <unistd.h>
-#include <getopt.h>
-#include <math.h>
-#ifndef __MINGW32__
-#include <netdb.h>
-#include <errno.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <pthread.h>
-#include <sys/un.h>
-#endif
-#include <libcork/core.h>
-
-#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
-#include <net/if.h>
-#include <sys/ioctl.h>
-#define SET_INTERFACE
-#endif
-
-#ifdef USE_NFTABLES
-#include <ctype.h>
-#include <linux/netfilter.h>
-#include <linux/netfilter/nf_tables.h>
-#include <libmnl/libmnl.h>
-#include <libnftnl/set.h>
-/* the datatypes enum is picked from libnftables/datatype.h
-   to avoid to depend libnftables */
-enum datatypes {
-    TYPE_IPADDR = 7,
-    TYPE_IP6ADDR
-};
-#endif
-
-#include "netutils.h"
-#include "utils.h"
-#include "acl.h"
-#include "plugin.h"
-#include "server.h"
-#include "winsock.h"
-#include "resolv.h"
-
-#ifndef EAGAIN
-#define EAGAIN EWOULDBLOCK
-#endif
-
-#ifndef EWOULDBLOCK
-#define EWOULDBLOCK EAGAIN
-#endif
-
-#ifndef SSMAXCONN
-#define SSMAXCONN 1024
-#endif
-
-#ifdef USE_NFCONNTRACK_TOS
-
-#ifndef MARK_MAX_PACKET
-#define MARK_MAX_PACKET 10
-#endif
-
-#ifndef MARK_MASK_PREFIX
-#define MARK_MASK_PREFIX 0xDC00
-#endif
-
-#endif
-
-static void signal_cb(EV_P_ ev_signal *w, int revents);
-static void accept_cb(EV_P_ ev_io *w, int revents);
-static void server_send_cb(EV_P_ ev_io *w, int revents);
-static void server_recv_cb(EV_P_ ev_io *w, int revents);
-static void remote_recv_cb(EV_P_ ev_io *w, int revents);
-static void remote_send_cb(EV_P_ ev_io *w, int revents);
-static void server_timeout_cb(EV_P_ ev_timer *watcher, int revents);
-
-static remote_t *new_remote(int fd);
-static server_t *new_server(int fd, listen_ctx_t *listener);
-static remote_t *connect_to_remote(EV_P_ struct addrinfo *res,
-                                   server_t *server);
-
-static void free_remote(remote_t *remote);
-static void close_and_free_remote(EV_P_ remote_t *remote);
-static void free_server(server_t *server);
-static void close_and_free_server(EV_P_ server_t *server);
-static void resolv_cb(struct sockaddr *addr, void *data);
-static void resolv_free_cb(void *data);
-
-int verbose    = 0;
-int reuse_port = 0;
-int tcp_incoming_sndbuf = 0;
-int tcp_incoming_rcvbuf = 0;
-int tcp_outgoing_sndbuf = 0;
-int tcp_outgoing_rcvbuf = 0;
-
-int is_bind_local_addr = 0;
-struct sockaddr_storage local_addr_v4;
-struct sockaddr_storage local_addr_v6;
-
-static crypto_t *crypto;
-
-static int acl       = 0;
-static int mode      = TCP_ONLY;
-static int ipv6first = 0;
-int fast_open        = 0;
-static int no_delay  = 0;
-static int ret_val   = 0;
-
-#ifdef HAVE_SETRLIMIT
-static int nofile = 0;
-#endif
-static int remote_conn = 0;
-static int server_conn = 0;
-
-static char *plugin       = NULL;
-static char *remote_port  = NULL;
-static char *manager_addr = NULL;
-uint64_t tx               = 0;
-uint64_t rx               = 0;
-
-#ifndef __MINGW32__
-ev_timer stat_update_watcher;
-#endif
-
-static struct ev_signal sigint_watcher;
-static struct ev_signal sigterm_watcher;
-#ifndef __MINGW32__
-static struct ev_signal sigchld_watcher;
-#else
-static struct plugin_watcher_t {
-    ev_io io;
-    SOCKET fd;
-    uint16_t port;
-    int valid;
-} plugin_watcher;
-#endif
-
-static struct cork_dllist connections;
-
-#ifndef __MINGW32__
-static void
-stat_update_cb(EV_P_ ev_timer *watcher, int revents)
-{
-    struct sockaddr_un svaddr, claddr;
-    int sfd = -1;
-    size_t msgLen;
-    char resp[SOCKET_BUF_SIZE];
-
-    if (verbose) {
-        LOGI("update traffic stat: tx: %" PRIu64 " rx: %" PRIu64 "", tx, rx);
-    }
-
-    snprintf(resp, SOCKET_BUF_SIZE, "stat: {\"%s\":%" PRIu64 "}", remote_port, tx + rx);
-    msgLen = strlen(resp) + 1;
-
-    ss_addr_t ip_addr = { .host = NULL, .port = NULL };
-    parse_addr(manager_addr, &ip_addr);
-
-    if (ip_addr.host == NULL || ip_addr.port == NULL) {
-        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
-        if (sfd == -1) {
-            ERROR("stat_socket");
-            return;
-        }
-
-        memset(&claddr, 0, sizeof(struct sockaddr_un));
-        claddr.sun_family = AF_UNIX;
-        snprintf(claddr.sun_path, sizeof(claddr.sun_path), "/tmp/shadowsocks.%s", remote_port);
-
-        unlink(claddr.sun_path);
-
-        if (bind(sfd, (struct sockaddr *)&claddr, sizeof(struct sockaddr_un)) == -1) {
-            ERROR("stat_bind");
-            close(sfd);
-            return;
-        }
-
-        memset(&svaddr, 0, sizeof(struct sockaddr_un));
-        svaddr.sun_family = AF_UNIX;
-        strncpy(svaddr.sun_path, manager_addr, sizeof(svaddr.sun_path) - 1);
-
-        if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&svaddr,
-                   sizeof(struct sockaddr_un)) != msgLen) {
-            ERROR("stat_sendto");
-            close(sfd);
-            return;
-        }
-
-        unlink(claddr.sun_path);
-    } else {
-        struct sockaddr_storage storage;
-        memset(&storage, 0, sizeof(struct sockaddr_storage));
-        if (get_sockaddr(ip_addr.host, ip_addr.port, &storage, 0, ipv6first) == -1) {
-            ERROR("failed to parse the manager addr");
-            return;
-        }
-
-        sfd = socket(storage.ss_family, SOCK_DGRAM, 0);
-
-        if (sfd == -1) {
-            ERROR("stat_socket");
-            return;
-        }
-
-        size_t addr_len = get_sockaddr_len((struct sockaddr *)&storage);
-        if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&storage,
-                   addr_len) != msgLen) {
-            ERROR("stat_sendto");
-            close(sfd);
-            return;
-        }
-    }
-
-    close(sfd);
-}
-
-#endif
-
-static void
-free_connections(struct ev_loop *loop)
-{
-    struct cork_dllist_item *curr, *next;
-    cork_dllist_foreach_void(&connections, curr, next) {
-        server_t *server = cork_container_of(curr, server_t, entries);
-        remote_t *remote = server->remote;
-        close_and_free_server(loop, server);
-        close_and_free_remote(loop, remote);
-    }
-}
-
-static char *
-get_peer_name(int fd)
-{
-    static char peer_name[INET6_ADDRSTRLEN] = { 0 };
-    struct sockaddr_storage addr;
-    socklen_t len = sizeof(struct sockaddr_storage);
-    memset(&addr, 0, len);
-    memset(peer_name, 0, INET6_ADDRSTRLEN);
-    int err = getpeername(fd, (struct sockaddr *)&addr, &len);
-    if (err == 0) {
-        if (addr.ss_family == AF_INET) {
-            struct sockaddr_in *s = (struct sockaddr_in *)&addr;
-            inet_ntop(AF_INET, &s->sin_addr, peer_name, INET_ADDRSTRLEN);
-        } else if (addr.ss_family == AF_INET6) {
-            struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;
-            inet_ntop(AF_INET6, &s->sin6_addr, peer_name, INET6_ADDRSTRLEN);
-        }
-    } else {
-        return NULL;
-    }
-    return peer_name;
-}
-
-static void
-stop_server(EV_P_ server_t *server)
-{
-    server->stage = STAGE_STOP;
-}
-
-#ifdef USE_NFTABLES
-struct nftbl_set_info {
-    uint32_t family;
-    char *table;
-    char *name;
-    uint32_t type;
-}* nftbl_badip_sets[16];
-
-static struct nftnl_set *
-nftbl_build_set(const char* table, const char* name, void* addr, size_t len)
-{
-    struct nftnl_set *set = nftnl_set_alloc();
-    if (set == NULL) return NULL;
-    nftnl_set_set_str(set, NFTNL_SET_TABLE, table);
-    nftnl_set_set_str(set, NFTNL_SET_NAME, name);
-
-    struct nftnl_set_elem *elem = nftnl_set_elem_alloc();
-    if (elem == NULL) {
-        nftnl_set_free(set);
-        return NULL;
-    }
-    nftnl_set_elem_set(elem, NFTNL_SET_ELEM_KEY, addr, len);
-    nftnl_set_elem_add(set, elem);
-    return set;
-}
-
-static uint32_t
-nftbl_build_nlmsg(void* buf, size_t *len, uint32_t family,
-                  struct nftnl_set *set)
-{
-    uint32_t seq = time(NULL);
-    struct nlmsghdr *nlh;
-    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(buf, *len);
-    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq);
-    mnl_nlmsg_batch_next(batch);
-    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
-                                NFT_MSG_NEWSETELEM, family,
-                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
-                                ++seq);
-    nftnl_set_elems_nlmsg_build_payload(nlh, set);
-    mnl_nlmsg_batch_next(batch);
-    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq + 1);
-    mnl_nlmsg_batch_next(batch);
-    *len = mnl_nlmsg_batch_size(batch);
-    mnl_nlmsg_batch_stop(batch);
-    return seq;
-}
-
-static int
-nftbl_send_request(void *request, size_t len, uint32_t seq,
-                   mnl_cb_t cb, void *data)
-{
-    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
-    if (nl == NULL) return -1;
-
-    int ret = -1;
-    uint8_t buf[MNL_SOCKET_BUFFER_SIZE];
-    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) == 0 &&
-        mnl_socket_sendto(nl, request, len) >= 0) {
-        uint32_t portid = mnl_socket_get_portid(nl);
-        while ((ret = mnl_socket_recvfrom(nl, buf, sizeof(buf))) > 0) {
-            ret = mnl_cb_run(buf, ret, seq, portid, cb, data);
-            if (ret != MNL_CB_OK)
-                break;
-        }
-        mnl_socket_close(nl);
-    }
-    return ret;
-}
-
-static void
-nftbl_report_addr(const struct sockaddr* addr)
-{
-    uint32_t type;
-    void* data;
-    size_t size;
-    if (addr->sa_family == AF_INET) {
-        type = TYPE_IPADDR;
-        data = &((struct sockaddr_in*)addr)->sin_addr;
-        size = sizeof(struct in_addr);
-    } else if (addr->sa_family == AF_INET6) {
-        type = TYPE_IP6ADDR;
-        data = &((struct sockaddr_in6*)addr)->sin6_addr;
-        size = sizeof(struct in6_addr);
-    } else {
-        return;
-    }
-
-    char buf[MNL_SOCKET_BUFFER_SIZE];
-    for (int i = 0; nftbl_badip_sets[i]; ++i) {
-        struct nftbl_set_info* si = nftbl_badip_sets[i];
-        struct nftnl_set *set;
-        if (si->type == type &&
-            (set = nftbl_build_set(si->table, si->name, data, size))) {
-            size_t len = sizeof(buf);
-            uint32_t seq = nftbl_build_nlmsg(buf, &len, si->family, set);
-            nftnl_set_free(set);
-            if (nftbl_send_request(buf, len, seq, NULL, NULL) < 0 &&
-                errno != EEXIST)
-                ERROR("nftbl_report_addr");
-        }
-    }
-}
-
-static int
-nftbl_check_cb(const struct nlmsghdr *nlh, void *data)
-{
-    struct nftnl_set *set = (struct nftnl_set*)data;
-    if (nftnl_set_nlmsg_parse(nlh, set) < 0)
-        return MNL_CB_ERROR;
-
-    uint32_t type = nftnl_set_get_u32(set, NFTNL_SET_KEY_TYPE);
-    if (type != TYPE_IPADDR && type != TYPE_IP6ADDR)
-        return MNL_CB_OK;
-
-    uint32_t len;
-    const char *name = nftnl_set_get_data(set, NFTNL_SET_NAME, &len);
-    for (int i = 0; nftbl_badip_sets[i]; ++i) {
-        struct nftbl_set_info* si = nftbl_badip_sets[i];
-        if (!memcmp(name, si->name, len)) {
-            name = nftnl_set_get_data(set, NFTNL_SET_TABLE, &len);
-            if (!si->table) {
-                size_t l = strlen(si->name) + 1;
-                si = realloc(si, sizeof(*si) + l + len);
-                si->name = (char*)(si + 1);
-                si->table = memcpy(si->name + l, name, len);
-                nftbl_badip_sets[i] = si;
-            } else if (memcmp(name, si->table, len)) {
-                continue;  /* table name not match */
-            }
-            si->family = nftnl_set_get_u32(set, NFTNL_SET_FAMILY);
-            si->type = type;
-        }
-    }
-    return MNL_CB_OK;
-}
-
-static int
-nftbl_check(void)
-{
-    struct nftnl_set *set = nftnl_set_alloc();
-    if (!set) return -1;
-
-    int ret;
-    char buf[MNL_SOCKET_BUFFER_SIZE];
-    uint32_t seq = time(NULL);
-    struct nlmsghdr *nlh;
-    nlh = nftnl_set_nlmsg_build_hdr(buf, NFT_MSG_GETSET, NFPROTO_UNSPEC,
-                                    NLM_F_DUMP|NLM_F_ACK, seq);
-    nftnl_set_nlmsg_build_payload(nlh, set);
-    ret = nftbl_send_request(nlh, nlh->nlmsg_len, seq, nftbl_check_cb, set);
-    nftnl_set_free(set);
-    if (ret < 0) return ret;
-
-    for (int i = 0; nftbl_badip_sets[i]; ++i) {
-        struct nftbl_set_info* si = nftbl_badip_sets[i];
-        if (si->family == NFPROTO_UNSPEC) {
-            if (si->table)
-                LOGE("set '%s' not found in table '%s'", si->name, si->table);
-            else
-                LOGE("set '%s' not found", si->name);
-            ret = -1;
-        }
-    }
-    if (ret < 0)
-        FATAL("Check nftables configuration.");
-    return ret;
-}
-
-static int
-nftbl_init(const char* set_str)
-{
-    struct nftbl_set_info* si;
-    const char *p0 = set_str, *p = p0, *d = NULL;
-    int i = 0;
-    do {
-        if (*p == ':') {
-            d = p;
-        } else if (*p == ',' || *p == '\0') {
-            size_t l = p - p0 + 1;
-            si = malloc(sizeof(*si) + l);
-            memset(si, 0, sizeof(*si));
-            si->name = memcpy(si + 1, p0, l);
-            si->name[l - 1] = '\0';
-            if (d) {
-                si->table = si->name;
-                si->name = si->table + (d - p0);
-                *(si->name++) = '\0';
-                d = NULL;
-            }
-            nftbl_badip_sets[i++] = si;
-            if (i == sizeof(nftbl_badip_sets) / sizeof(*si) - 1)
-                break;
-            while (*p && isspace(*(++p)));
-            p0 = p;
-        }
-    } while (*(p++));
-    return nftbl_check();
-}
-#endif
-
-static void
-report_addr(int fd, const char *info)
-{
-    char *peer_name;
-    peer_name = get_peer_name(fd);
-    if (peer_name != NULL) {
-        LOGE("failed to handshake with %s: %s", peer_name, info);
-    }
-
-#ifdef USE_NFTABLES
-    struct sockaddr_in6 addr;
-    socklen_t len = sizeof(struct sockaddr_in6);
-    if (!getpeername(fd, (struct sockaddr *)&addr, &len))
-        nftbl_report_addr((struct sockaddr *)&addr);
-#endif
-}
-
-int
-setfastopen(int fd)
-{
-    int s = 0;
-#ifdef TCP_FASTOPEN
-    if (fast_open) {
-#if defined(__APPLE__) || defined(__MINGW32__)
-        int opt = 1;
-#else
-        int opt = 5;
-#endif
-        s = setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &opt, sizeof(opt));
-
-        if (s == -1) {
-            if (errno == EPROTONOSUPPORT || errno == ENOPROTOOPT) {
-                LOGE("fast open is not supported on this platform");
-                fast_open = 0;
-            } else {
-                ERROR("setsockopt");
-            }
-        }
-    }
-#endif
-    return s;
-}
-
-#ifndef __MINGW32__
-int
-setnonblocking(int fd)
-{
-    int flags;
-    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
-        flags = 0;
-    }
-    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-}
-
-#endif
-
-int
-create_and_bind(const char *host, const char *port, int mptcp)
-{
-    struct addrinfo hints;
-    struct addrinfo *result, *rp, *ipv4v6bindall;
-    int s, listen_sock = -1;
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_family   = AF_UNSPEC;               /* Return IPv4 and IPv6 choices */
-    hints.ai_socktype = SOCK_STREAM;             /* We want a TCP socket */
-    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; /* For wildcard IP address */
-    hints.ai_protocol = IPPROTO_TCP;
-
-    result = NULL;
-
-    s = getaddrinfo(host, port, &hints, &result);
-
-    if (s != 0) {
-        LOGE("failed to resolve server name %s", host);
-        return -1;
-    }
-
-    if (result == NULL) {
-        LOGE("Cannot bind");
-        return -1;
-    }
-
-    rp = result;
-
-    /*
-     * On Linux, with net.ipv6.bindv6only = 0 (the default), getaddrinfo(NULL) with
-     * AI_PASSIVE returns 0.0.0.0 and :: (in this order). AI_PASSIVE was meant to
-     * return a list of addresses to listen on, but it is impossible to listen on
-     * 0.0.0.0 and :: at the same time, if :: implies dualstack mode.
-     */
-    if (!host) {
-        ipv4v6bindall = result;
-
-        /* Loop over all address infos found until a IPV6 address is found. */
-        while (ipv4v6bindall) {
-            if (ipv4v6bindall->ai_family == AF_INET6) {
-                rp = ipv4v6bindall; /* Take first IPV6 address available */
-                break;
-            }
-            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */
-        }
-    }
-
-    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {
-        int protocol = rp->ai_protocol;
-        if (mptcp < 0) {
-            protocol = IPPROTO_MPTCP; // Enable upstream MPTCP
-        }
-        listen_sock = socket(rp->ai_family, rp->ai_socktype, protocol);
-        if (listen_sock == -1) {
-            continue;
-        }
-
-        if (rp->ai_family == AF_INET6) {
-            int opt = host ? 1 : 0;
-            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt));
-        }
-
-        int opt = 1;
-        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-        if (reuse_port) {
-            int err = set_reuseport(listen_sock);
-            if (err == 0) {
-                LOGI("tcp port reuse enabled");
-            }
-        }
-
-        // Enable out-of-tree mptcp
-        if (mptcp == 1) {
-            int i = 0;
-            while ((mptcp = mptcp_enabled_values[i]) > 0) {
-                int err = setsockopt(listen_sock, IPPROTO_TCP, mptcp, &opt, sizeof(opt));
-                if (err != -1) {
-                    break;
-                }
-                i++;
-            }
-            if (mptcp == 0) {
-                ERROR("failed to enable out-of-tree multipath TCP");
-            }
-        }
-
-        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);
-        if (s == 0) {
-            /* We managed to bind successfully! */
-            break;
-        } else {
-            ERROR("bind");
-            FATAL("failed to bind address");
-        }
-
-        close(listen_sock);
-        listen_sock = -1;
-    }
-
-    freeaddrinfo(result);
-
-    return listen_sock;
-}
-
-static remote_t *
-connect_to_remote(EV_P_ struct addrinfo *res,
-                  server_t *server)
-{
-    int sockfd;
-#ifdef SET_INTERFACE
-    const char *iface = server->listen_ctx->iface;
-#endif
-
-    if (acl) {
-        char ipstr[INET6_ADDRSTRLEN];
-        memset(ipstr, 0, INET6_ADDRSTRLEN);
-
-        if (res->ai_addr->sa_family == AF_INET) {
-            struct sockaddr_in s;
-            memcpy(&s, res->ai_addr, sizeof(struct sockaddr_in));
-            inet_ntop(AF_INET, &s.sin_addr, ipstr, INET_ADDRSTRLEN);
-        } else if (res->ai_addr->sa_family == AF_INET6) {
-            struct sockaddr_in6 s;
-            memcpy(&s, res->ai_addr, sizeof(struct sockaddr_in6));
-            inet_ntop(AF_INET6, &s.sin6_addr, ipstr, INET6_ADDRSTRLEN);
-        }
-
-        if (outbound_block_match_host(ipstr) == 1) {
-            if (verbose)
-                LOGI("outbound blocked %s", ipstr);
-            return NULL;
-        }
-    }
-
-    // initialize remote socks
-    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-    if (sockfd == -1) {
-        ERROR("socket");
-        close(sockfd);
-        return NULL;
-    }
-
-    int opt = 1;
-    setsockopt(sockfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
-
-    if (tcp_outgoing_sndbuf > 0) {
-        setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &tcp_outgoing_sndbuf, sizeof(int));
-    }
-
-    if (tcp_outgoing_rcvbuf > 0) {
-        setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &tcp_outgoing_rcvbuf, sizeof(int));
-    }
-
-    // setup remote socks
-
-    if (setnonblocking(sockfd) == -1)
-        ERROR("setnonblocking");
-
-    if (is_bind_local_addr) {
-        struct sockaddr_storage *local_addr =
-            res->ai_family == AF_INET ? &local_addr_v4 : &local_addr_v6;
-        if (res->ai_family == local_addr->ss_family) {
-            if (bind_to_addr(local_addr, sockfd) == -1) {
-                ERROR("bind_to_addr");
-                FATAL("cannot bind socket");
-                return NULL;
-            }
-        }
-    }
-
-#ifdef SET_INTERFACE
-    if (iface) {
-        if (setinterface(sockfd, iface) == -1) {
-            ERROR("setinterface");
-            close(sockfd);
-            return NULL;
-        }
-    }
-#endif
-
-    remote_t *remote = new_remote(sockfd);
-
-    if (fast_open) {
-#if defined(MSG_FASTOPEN) && !defined(TCP_FASTOPEN_CONNECT)
-        int s = -1;
-        s = sendto(sockfd, server->buf->data + server->buf->idx, server->buf->len,
-                   MSG_FASTOPEN, res->ai_addr, res->ai_addrlen);
-#elif defined(TCP_FASTOPEN_WINSOCK)
-        DWORD s   = -1;
-        DWORD err = 0;
-        do {
-            int optval = 1;
-            // Set fast open option
-            if (setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN,
-                           &optval, sizeof(optval)) != 0) {
-                ERROR("setsockopt");
-                break;
-            }
-            // Load ConnectEx function
-            LPFN_CONNECTEX ConnectEx = winsock_getconnectex();
-            if (ConnectEx == NULL) {
-                LOGE("Cannot load ConnectEx() function");
-                err = WSAENOPROTOOPT;
-                break;
-            }
-            // ConnectEx requires a bound socket
-            if (winsock_dummybind(sockfd, res->ai_addr) != 0) {
-                ERROR("bind");
-                break;
-            }
-            // Call ConnectEx to send data
-            memset(&remote->olap, 0, sizeof(remote->olap));
-            remote->connect_ex_done = 0;
-            if (ConnectEx(sockfd, res->ai_addr, res->ai_addrlen,
-                          server->buf->data + server->buf->idx,
-                          server->buf->len, &s, &remote->olap)) {
-                remote->connect_ex_done = 1;
-                break;
-            }
-            // XXX: ConnectEx pending, check later in remote_send
-            if (WSAGetLastError() == ERROR_IO_PENDING) {
-                err = CONNECT_IN_PROGRESS;
-                break;
-            }
-            ERROR("ConnectEx");
-        } while (0);
-        // Set error number
-        if (err) {
-            SetLastError(err);
-        }
-#else
-        int s = -1;
-#if defined(TCP_FASTOPEN_CONNECT)
-        int optval = 1;
-        if (setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT,
-                       (void *)&optval, sizeof(optval)) < 0)
-            FATAL("failed to set TCP_FASTOPEN_CONNECT");
-        s = connect(sockfd, res->ai_addr, res->ai_addrlen);
-#elif defined(CONNECT_DATA_IDEMPOTENT)
-        struct sockaddr_in sa;
-        memcpy(&sa, res->ai_addr, sizeof(struct sockaddr_in));
-        sa.sin_len = sizeof(struct sockaddr_in);
-        sa_endpoints_t endpoints;
-        memset((char *)&endpoints, 0, sizeof(endpoints));
-        endpoints.sae_dstaddr    = (struct sockaddr *)&sa;
-        endpoints.sae_dstaddrlen = res->ai_addrlen;
-
-        s = connectx(sockfd, &endpoints, SAE_ASSOCID_ANY, CONNECT_DATA_IDEMPOTENT,
-                     NULL, 0, NULL, NULL);
-#else
-        FATAL("fast open is not enabled in this build");
-#endif
-        if (s == 0)
-            s = send(sockfd, server->buf->data + server->buf->idx, server->buf->len, 0);
-#endif
-        if (s == -1) {
-            if (errno == CONNECT_IN_PROGRESS) {
-                // The remote server doesn't support tfo or it's the first connection to the server.
-                // It will automatically fall back to conventional TCP.
-            } else if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
-                       errno == ENOPROTOOPT) {
-                // Disable fast open as it's not supported
-                fast_open = 0;
-                LOGE("fast open is not supported on this platform");
-            } else {
-                ERROR("fast_open_connect");
-            }
-        } else {
-            server->buf->idx += s;
-            server->buf->len -= s;
-        }
-    }
-
-    if (!fast_open) {
-        int r = connect(sockfd, res->ai_addr, res->ai_addrlen);
-
-        if (r == -1 && errno != CONNECT_IN_PROGRESS) {
-            ERROR("connect");
-            close_and_free_remote(EV_A_ remote);
-            return NULL;
-        }
-    }
-
-    return remote;
-}
-
-#ifdef USE_NFCONNTRACK_TOS
-int
-setMarkDscpCallback(enum nf_conntrack_msg_type type, struct nf_conntrack *ct, void *data)
-{
-    server_t *server            = (server_t *)data;
-    struct dscptracker *tracker = server->tracker;
-
-    tracker->mark = nfct_get_attr_u32(ct, ATTR_MARK);
-    if ((tracker->mark & 0xff00) == MARK_MASK_PREFIX) {
-        // Extract DSCP value from mark value
-        tracker->dscp = tracker->mark & 0x00ff;
-        int tos = (tracker->dscp) << 2;
-        if (setsockopt(server->fd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) != 0) {
-            ERROR("iptable setsockopt IP_TOS");
-        }
-    }
-    return NFCT_CB_CONTINUE;
-}
-
-void
-conntrackQuery(server_t *server)
-{
-    struct dscptracker *tracker = server->tracker;
-    if (tracker && tracker->ct) {
-        // Trying query mark from nf conntrack
-        struct nfct_handle *h = nfct_open(CONNTRACK, 0);
-        if (h) {
-            nfct_callback_register(h, NFCT_T_ALL, setMarkDscpCallback, (void *)server);
-            int x = nfct_query(h, NFCT_Q_GET, tracker->ct);
-            if (x == -1) {
-                LOGE("QOS: Failed to retrieve connection mark %s", strerror(errno));
-            }
-            nfct_close(h);
-        } else {
-            LOGE("QOS: Failed to open conntrack handle for upstream netfilter mark retrieval.");
-        }
-    }
-}
-
-void
-setTosFromConnmark(remote_t *remote, server_t *server)
-{
-    if (server->tracker && server->tracker->ct) {
-        if (server->tracker->mark == 0 && server->tracker->packet_count < MARK_MAX_PACKET) {
-            server->tracker->packet_count++;
-            conntrackQuery(server);
-        }
-    } else {
-        socklen_t len;
-        struct sockaddr_storage sin;
-        len = sizeof(sin);
-        if (getpeername(remote->fd, (struct sockaddr *)&sin, &len) == 0) {
-            struct sockaddr_storage from_addr;
-            len = sizeof from_addr;
-            if (getsockname(remote->fd, (struct sockaddr *)&from_addr, &len) == 0) {
-                if ((server->tracker = (struct dscptracker *)ss_malloc(sizeof(struct dscptracker)))) {
-                    if ((server->tracker->ct = nfct_new())) {
-                        // Build conntrack query SELECT
-                        if (from_addr.ss_family == AF_INET) {
-                            struct sockaddr_in *src = (struct sockaddr_in *)&from_addr;
-                            struct sockaddr_in *dst = (struct sockaddr_in *)&sin;
-
-                            nfct_set_attr_u8(server->tracker->ct, ATTR_L3PROTO, AF_INET);
-                            nfct_set_attr_u32(server->tracker->ct, ATTR_IPV4_DST, dst->sin_addr.s_addr);
-                            nfct_set_attr_u32(server->tracker->ct, ATTR_IPV4_SRC, src->sin_addr.s_addr);
-                            nfct_set_attr_u16(server->tracker->ct, ATTR_PORT_DST, dst->sin_port);
-                            nfct_set_attr_u16(server->tracker->ct, ATTR_PORT_SRC, src->sin_port);
-                        } else if (from_addr.ss_family == AF_INET6) {
-                            struct sockaddr_in6 *src = (struct sockaddr_in6 *)&from_addr;
-                            struct sockaddr_in6 *dst = (struct sockaddr_in6 *)&sin;
-
-                            nfct_set_attr_u8(server->tracker->ct, ATTR_L3PROTO, AF_INET6);
-                            nfct_set_attr(server->tracker->ct, ATTR_IPV6_DST, dst->sin6_addr.s6_addr);
-                            nfct_set_attr(server->tracker->ct, ATTR_IPV6_SRC, src->sin6_addr.s6_addr);
-                            nfct_set_attr_u16(server->tracker->ct, ATTR_PORT_DST, dst->sin6_port);
-                            nfct_set_attr_u16(server->tracker->ct, ATTR_PORT_SRC, src->sin6_port);
-                        }
-                        nfct_set_attr_u8(server->tracker->ct, ATTR_L4PROTO, IPPROTO_TCP);
-                        conntrackQuery(server);
-                    } else {
-                        LOGE("Failed to allocate new conntrack for upstream netfilter mark retrieval.");
-                        server->tracker->ct = NULL;
-                    }
-                }
-            }
-        }
-    }
-}
-
-#endif
-
-static void
-server_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
-    remote_t *remote              = NULL;
-
-    buffer_t *buf = server->buf;
-
-    if (server->stage == STAGE_STREAM) {
-        remote = server->remote;
-        buf    = remote->buf;
-
-        // Only timer the watcher if a valid connection is established
-        ev_timer_again(EV_A_ & server->recv_ctx->watcher);
-    }
-
-    ssize_t r = recv(server->fd, buf->data, SOCKET_BUF_SIZE, 0);
-
-    if (r == 0) {
-        // connection closed
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else if (r == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data
-            // continue to wait for recv
-            return;
-        } else {
-            ERROR("server recv");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    // Ignore any new packet if the server is stopped
-    if (server->stage == STAGE_STOP) {
-        return;
-    }
-
-    tx      += r;
-    buf->len = r;
-
-    int err = crypto->decrypt(buf, server->d_ctx, SOCKET_BUF_SIZE);
-
-    if (err == CRYPTO_ERROR) {
-        report_addr(server->fd, "authentication error");
-        stop_server(EV_A_ server);
-        return;
-    } else if (err == CRYPTO_NEED_MORE) {
-        if (server->stage != STAGE_STREAM) {
-            server->frag++;
-        }
-        return;
-    }
-
-    // handshake and transmit data
-    if (server->stage == STAGE_STREAM) {
-        int s = send(remote->fd, remote->buf->data, remote->buf->len, 0);
-        if (s == -1) {
-            if (errno == EAGAIN || errno == EWOULDBLOCK) {
-                // no data, wait for send
-                remote->buf->idx = 0;
-                ev_io_stop(EV_A_ & server_recv_ctx->io);
-                ev_io_start(EV_A_ & remote->send_ctx->io);
-            } else {
-                ERROR("server_recv_send");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-        } else if (s < remote->buf->len) {
-            remote->buf->len -= s;
-            remote->buf->idx  = s;
-            ev_io_stop(EV_A_ & server_recv_ctx->io);
-            ev_io_start(EV_A_ & remote->send_ctx->io);
-        }
-        return;
-    } else if (server->stage == STAGE_INIT) {
-        /*
-         * Shadowsocks TCP Relay Header:
-         *
-         *    +------+----------+----------+
-         *    | ATYP | DST.ADDR | DST.PORT |
-         *    +------+----------+----------+
-         *    |  1   | Variable |    2     |
-         *    +------+----------+----------+
-         *
-         */
-
-        int offset     = 0;
-        int need_query = 0;
-        char atyp      = server->buf->data[offset++];
-        char host[255] = { 0 };
-        uint16_t port  = 0;
-        struct addrinfo info;
-        struct sockaddr_storage storage;
-        memset(&info, 0, sizeof(struct addrinfo));
-        memset(&storage, 0, sizeof(struct sockaddr_storage));
-
-        // get remote addr and port
-        if ((atyp & ADDRTYPE_MASK) == 1) {
-            // IP V4
-            struct sockaddr_in *addr = (struct sockaddr_in *)&storage;
-            size_t in_addr_len       = sizeof(struct in_addr);
-            addr->sin_family = AF_INET;
-            if (server->buf->len >= in_addr_len + 3) {
-                memcpy(&addr->sin_addr, server->buf->data + offset, in_addr_len);
-                inet_ntop(AF_INET, (const void *)(server->buf->data + offset),
-                          host, INET_ADDRSTRLEN);
-                offset += in_addr_len;
-            } else {
-                report_addr(server->fd, "invalid length for ipv4 address");
-                stop_server(EV_A_ server);
-                return;
-            }
-            memcpy(&addr->sin_port, server->buf->data + offset, sizeof(uint16_t));
-            info.ai_family   = AF_INET;
-            info.ai_socktype = SOCK_STREAM;
-            info.ai_protocol = IPPROTO_TCP;
-            info.ai_addrlen  = sizeof(struct sockaddr_in);
-            info.ai_addr     = (struct sockaddr *)addr;
-        } else if ((atyp & ADDRTYPE_MASK) == 3) {
-            // Domain name
-            uint8_t name_len = *(uint8_t *)(server->buf->data + offset);
-            if (name_len + 4 <= server->buf->len) {
-                memcpy(host, server->buf->data + offset + 1, name_len);
-                offset += name_len + 1;
-            } else {
-                report_addr(server->fd, "invalid host name length");
-                stop_server(EV_A_ server);
-                return;
-            }
-            if (acl && outbound_block_match_host(host) == 1) {
-                if (verbose)
-                    LOGI("outbound blocked %s", host);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-            struct cork_ip ip;
-            if (cork_ip_init(&ip, host) != -1) {
-                info.ai_socktype = SOCK_STREAM;
-                info.ai_protocol = IPPROTO_TCP;
-                if (ip.version == 4) {
-                    struct sockaddr_in *addr = (struct sockaddr_in *)&storage;
-                    inet_pton(AF_INET, host, &(addr->sin_addr));
-                    memcpy(&addr->sin_port, server->buf->data + offset, sizeof(uint16_t));
-                    addr->sin_family = AF_INET;
-                    info.ai_family   = AF_INET;
-                    info.ai_addrlen  = sizeof(struct sockaddr_in);
-                    info.ai_addr     = (struct sockaddr *)addr;
-                } else if (ip.version == 6) {
-                    struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&storage;
-                    inet_pton(AF_INET6, host, &(addr->sin6_addr));
-                    memcpy(&addr->sin6_port, server->buf->data + offset, sizeof(uint16_t));
-                    addr->sin6_family = AF_INET6;
-                    info.ai_family    = AF_INET6;
-                    info.ai_addrlen   = sizeof(struct sockaddr_in6);
-                    info.ai_addr      = (struct sockaddr *)addr;
-                }
-            } else {
-                if (!validate_hostname(host, name_len)) {
-                    report_addr(server->fd, "invalid host name");
-                    stop_server(EV_A_ server);
-                    return;
-                }
-                need_query = 1;
-            }
-        } else if ((atyp & ADDRTYPE_MASK) == 4) {
-            // IP V6
-            struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&storage;
-            size_t in6_addr_len       = sizeof(struct in6_addr);
-            addr->sin6_family = AF_INET6;
-            if (server->buf->len >= in6_addr_len + 3) {
-                memcpy(&addr->sin6_addr, server->buf->data + offset, in6_addr_len);
-                inet_ntop(AF_INET6, (const void *)(server->buf->data + offset),
-                          host, INET6_ADDRSTRLEN);
-                offset += in6_addr_len;
-            } else {
-                LOGE("invalid header with addr type %d", atyp);
-                report_addr(server->fd, "invalid length for ipv6 address");
-                stop_server(EV_A_ server);
-                return;
-            }
-            memcpy(&addr->sin6_port, server->buf->data + offset, sizeof(uint16_t));
-            info.ai_family   = AF_INET6;
-            info.ai_socktype = SOCK_STREAM;
-            info.ai_protocol = IPPROTO_TCP;
-            info.ai_addrlen  = sizeof(struct sockaddr_in6);
-            info.ai_addr     = (struct sockaddr *)addr;
-        }
-
-        if (offset == 1) {
-            report_addr(server->fd, "invalid address type");
-            stop_server(EV_A_ server);
-            return;
-        }
-
-        port = ntohs(load16_be(server->buf->data + offset));
-
-        offset += 2;
-
-        if (server->buf->len < offset) {
-            report_addr(server->fd, "invalid request length");
-            stop_server(EV_A_ server);
-            return;
-        } else {
-            server->buf->len -= offset;
-            server->buf->idx = offset;
-        }
-
-        if (verbose) {
-            if ((atyp & ADDRTYPE_MASK) == 4)
-                LOGI("[%s] connect to [%s]:%d", remote_port, host, ntohs(port));
-            else
-                LOGI("[%s] connect to %s:%d", remote_port, host, ntohs(port));
-        }
-
-        if (!need_query) {
-            remote_t *remote = connect_to_remote(EV_A_ & info, server);
-
-            if (remote == NULL) {
-                LOGE("connect error");
-                close_and_free_server(EV_A_ server);
-                return;
-            } else {
-                server->remote = remote;
-                remote->server = server;
-
-                // XXX: should handle buffer carefully
-                if (server->buf->len > 0) {
-                    brealloc(remote->buf, server->buf->len, SOCKET_BUF_SIZE);
-                    memcpy(remote->buf->data, server->buf->data + server->buf->idx,
-                           server->buf->len);
-                    remote->buf->len = server->buf->len;
-                    remote->buf->idx = 0;
-                    server->buf->len = 0;
-                    server->buf->idx = 0;
-                }
-
-                // waiting on remote connected event
-                ev_io_stop(EV_A_ & server_recv_ctx->io);
-                ev_io_start(EV_A_ & remote->send_ctx->io);
-            }
-        } else {
-            ev_io_stop(EV_A_ & server_recv_ctx->io);
-
-            query_t *query = ss_malloc(sizeof(query_t));
-            memset(query, 0, sizeof(query_t));
-            query->server = server;
-            server->query = query;
-            snprintf(query->hostname, MAX_HOSTNAME_LEN, "%s", host);
-
-            server->stage = STAGE_RESOLVE;
-            resolv_start(host, port, resolv_cb, resolv_free_cb, query);
-        }
-
-        return;
-    }
-    // should not reach here
-    FATAL("server context error");
-}
-
-static void
-server_send_cb(EV_P_ ev_io *w, int revents)
-{
-    server_ctx_t *server_send_ctx = (server_ctx_t *)w;
-    server_t *server              = server_send_ctx->server;
-    remote_t *remote              = server->remote;
-
-    if (remote == NULL) {
-        LOGE("invalid server");
-        close_and_free_server(EV_A_ server);
-        return;
-    }
-
-    if (server->buf->len == 0) {
-        // close and free
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else {
-        // has data to send
-        ssize_t s = send(server->fd, server->buf->data + server->buf->idx,
-                         server->buf->len, 0);
-        if (s == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("server_send_send");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        } else if (s < server->buf->len) {
-            // partly sent, move memory, wait for the next time to send
-            server->buf->len -= s;
-            server->buf->idx += s;
-            return;
-        } else {
-            // all sent out, wait for reading
-            server->buf->len = 0;
-            server->buf->idx = 0;
-            ev_io_stop(EV_A_ & server_send_ctx->io);
-            if (remote != NULL) {
-                ev_io_start(EV_A_ & remote->recv_ctx->io);
-                return;
-            } else {
-                LOGE("invalid remote");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-        }
-    }
-}
-
-static void
-server_timeout_cb(EV_P_ ev_timer *watcher, int revents)
-{
-    server_ctx_t *server_ctx
-        = cork_container_of(watcher, server_ctx_t, watcher);
-    server_t *server = server_ctx->server;
-    remote_t *remote = server->remote;
-
-    if (verbose) {
-        LOGI("TCP connection timeout");
-    }
-
-    close_and_free_remote(EV_A_ remote);
-    close_and_free_server(EV_A_ server);
-}
-
-static void
-resolv_free_cb(void *data)
-{
-    query_t *query = (query_t *)data;
-
-    if (query != NULL) {
-        if (query->server != NULL)
-            query->server->query = NULL;
-        ss_free(query);
-    }
-}
-
-static void
-resolv_cb(struct sockaddr *addr, void *data)
-{
-    query_t *query   = (query_t *)data;
-    server_t *server = query->server;
-
-    if (server == NULL)
-        return;
-
-    struct ev_loop *loop = server->listen_ctx->loop;
-
-    if (addr == NULL) {
-        LOGE("unable to resolve %s", query->hostname);
-        close_and_free_server(EV_A_ server);
-    } else {
-        if (verbose) {
-            LOGI("successfully resolved %s", query->hostname);
-        }
-
-        struct addrinfo info;
-        memset(&info, 0, sizeof(struct addrinfo));
-        info.ai_socktype = SOCK_STREAM;
-        info.ai_protocol = IPPROTO_TCP;
-        info.ai_addr     = addr;
-
-        if (addr->sa_family == AF_INET) {
-            info.ai_family  = AF_INET;
-            info.ai_addrlen = sizeof(struct sockaddr_in);
-        } else if (addr->sa_family == AF_INET6) {
-            info.ai_family  = AF_INET6;
-            info.ai_addrlen = sizeof(struct sockaddr_in6);
-        }
-
-        remote_t *remote = connect_to_remote(EV_A_ & info, server);
-
-        if (remote == NULL) {
-            close_and_free_server(EV_A_ server);
-        } else {
-            server->remote = remote;
-            remote->server = server;
-
-            // XXX: should handle buffer carefully
-            if (server->buf->len > 0) {
-                brealloc(remote->buf, server->buf->len, SOCKET_BUF_SIZE);
-                memcpy(remote->buf->data, server->buf->data + server->buf->idx,
-                       server->buf->len);
-                remote->buf->len = server->buf->len;
-                remote->buf->idx = 0;
-                server->buf->len = 0;
-                server->buf->idx = 0;
-            }
-
-            // listen to remote connected event
-            ev_io_start(EV_A_ & remote->send_ctx->io);
-        }
-    }
-}
-
-static void
-remote_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_recv_ctx->remote;
-    server_t *server              = remote->server;
-
-    if (server == NULL) {
-        LOGE("invalid server");
-        close_and_free_remote(EV_A_ remote);
-        return;
-    }
-
-    ev_timer_again(EV_A_ & server->recv_ctx->watcher);
-
-    ssize_t r = recv(remote->fd, server->buf->data, SOCKET_BUF_SIZE, 0);
-
-    if (r == 0) {
-        // connection closed
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else if (r == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data
-            // continue to wait for recv
-            return;
-        } else {
-            ERROR("remote recv");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    rx += r;
-
-    // Ignore any new packet if the server is stopped
-    if (server->stage == STAGE_STOP) {
-        return;
-    }
-
-    server->buf->len = r;
-    int err = crypto->encrypt(server->buf, server->e_ctx, SOCKET_BUF_SIZE);
-
-    if (err) {
-        LOGE("invalid password or cipher");
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    }
-
-#ifdef USE_NFCONNTRACK_TOS
-    setTosFromConnmark(remote, server);
-#endif
-    int s = send(server->fd, server->buf->data, server->buf->len, 0);
-
-    if (s == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data, wait for send
-            server->buf->idx = 0;
-            ev_io_stop(EV_A_ & remote_recv_ctx->io);
-            ev_io_start(EV_A_ & server->send_ctx->io);
-        } else {
-            ERROR("remote_recv_send");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    } else if (s < server->buf->len) {
-        server->buf->len -= s;
-        server->buf->idx  = s;
-        ev_io_stop(EV_A_ & remote_recv_ctx->io);
-        ev_io_start(EV_A_ & server->send_ctx->io);
-    }
-
-    // Disable TCP_NODELAY after the first response are sent
-    if (!remote->recv_ctx->connected && !no_delay) {
-        int opt = 0;
-        setsockopt(server->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-        setsockopt(remote->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-    }
-    remote->recv_ctx->connected = 1;
-}
-
-static void
-remote_send_cb(EV_P_ ev_io *w, int revents)
-{
-    remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_send_ctx->remote;
-    server_t *server              = remote->server;
-
-    if (server == NULL) {
-        LOGE("invalid server");
-        close_and_free_remote(EV_A_ remote);
-        return;
-    }
-
-    if (!remote_send_ctx->connected) {
-#ifdef TCP_FASTOPEN_WINSOCK
-        if (fast_open) {
-            // Check if ConnectEx is done
-            if (!remote->connect_ex_done) {
-                DWORD numBytes;
-                DWORD flags;
-                // Non-blocking way to fetch ConnectEx result
-                if (WSAGetOverlappedResult(remote->fd, &remote->olap,
-                                           &numBytes, FALSE, &flags)) {
-                    remote->buf->len       -= numBytes;
-                    remote->buf->idx        = numBytes;
-                    remote->connect_ex_done = 1;
-                } else if (WSAGetLastError() == WSA_IO_INCOMPLETE) {
-                    // XXX: ConnectEx still not connected, wait for next time
-                    return;
-                } else {
-                    ERROR("WSAGetOverlappedResult");
-                    // not connected
-                    close_and_free_remote(EV_A_ remote);
-                    close_and_free_server(EV_A_ server);
-                    return;
-                }
-            }
-
-            // Make getpeername work
-            if (setsockopt(remote->fd, SOL_SOCKET,
-                           SO_UPDATE_CONNECT_CONTEXT, NULL, 0) != 0) {
-                ERROR("setsockopt");
-            }
-        }
-#endif
-        struct sockaddr_storage addr;
-        socklen_t len = sizeof(struct sockaddr_storage);
-        memset(&addr, 0, len);
-
-        int r = getpeername(remote->fd, (struct sockaddr *)&addr, &len);
-
-        if (r == 0) {
-            remote_send_ctx->connected = 1;
-
-            if (remote->buf->len == 0) {
-                server->stage = STAGE_STREAM;
-                ev_io_stop(EV_A_ & remote_send_ctx->io);
-                ev_io_start(EV_A_ & server->recv_ctx->io);
-                ev_io_start(EV_A_ & remote->recv_ctx->io);
-                return;
-            }
-        } else {
-            ERROR("getpeername");
-            // not connected
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    if (remote->buf->len == 0) {
-        // close and free
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else {
-        // has data to send
-        ssize_t s = send(remote->fd, remote->buf->data + remote->buf->idx,
-                         remote->buf->len, 0);
-        if (s == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("remote_send_send");
-                // close and free
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        } else if (s < remote->buf->len) {
-            // partly sent, move memory, wait for the next time to send
-            remote->buf->len -= s;
-            remote->buf->idx += s;
-            return;
-        } else {
-            // all sent out, wait for reading
-            remote->buf->len = 0;
-            remote->buf->idx = 0;
-            ev_io_stop(EV_A_ & remote_send_ctx->io);
-            if (server != NULL) {
-                ev_io_start(EV_A_ & server->recv_ctx->io);
-                if (server->stage != STAGE_STREAM) {
-                    server->stage = STAGE_STREAM;
-                    ev_io_start(EV_A_ & remote->recv_ctx->io);
-                }
-            } else {
-                LOGE("invalid server");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        }
-    }
-}
-
-static remote_t *
-new_remote(int fd)
-{
-    if (verbose) {
-        remote_conn++;
-        LOGI("new connection to remote, %d opened remote connections", remote_conn);
-    }
-
-    remote_t *remote = ss_malloc(sizeof(remote_t));
-    memset(remote, 0, sizeof(remote_t));
-
-    remote->recv_ctx = ss_malloc(sizeof(remote_ctx_t));
-    remote->send_ctx = ss_malloc(sizeof(remote_ctx_t));
-    remote->buf      = ss_malloc(sizeof(buffer_t));
-    balloc(remote->buf, SOCKET_BUF_SIZE);
-    memset(remote->recv_ctx, 0, sizeof(remote_ctx_t));
-    memset(remote->send_ctx, 0, sizeof(remote_ctx_t));
-    remote->fd                  = fd;
-    remote->recv_ctx->remote    = remote;
-    remote->recv_ctx->connected = 0;
-    remote->send_ctx->remote    = remote;
-    remote->send_ctx->connected = 0;
-    remote->server              = NULL;
-
-    ev_io_init(&remote->recv_ctx->io, remote_recv_cb, fd, EV_READ);
-    ev_io_init(&remote->send_ctx->io, remote_send_cb, fd, EV_WRITE);
-
-    return remote;
-}
-
-static void
-free_remote(remote_t *remote)
-{
-    if (remote->server != NULL) {
-        remote->server->remote = NULL;
-    }
-    if (remote->buf != NULL) {
-        bfree(remote->buf);
-        ss_free(remote->buf);
-    }
-    ss_free(remote->recv_ctx);
-    ss_free(remote->send_ctx);
-    ss_free(remote);
-}
-
-static void
-close_and_free_remote(EV_P_ remote_t *remote)
-{
-    if (remote != NULL) {
-        ev_io_stop(EV_A_ & remote->send_ctx->io);
-        ev_io_stop(EV_A_ & remote->recv_ctx->io);
-        close(remote->fd);
-        free_remote(remote);
-        if (verbose) {
-            remote_conn--;
-            LOGI("close a connection to remote, %d opened remote connections", remote_conn);
-        }
-    }
-}
-
-static server_t *
-new_server(int fd, listen_ctx_t *listener)
-{
-    if (verbose) {
-        server_conn++;
-        LOGI("new connection from client, %d opened client connections", server_conn);
-    }
-
-    server_t *server;
-    server = ss_malloc(sizeof(server_t));
-
-    memset(server, 0, sizeof(server_t));
-
-    server->recv_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->send_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->buf      = ss_malloc(sizeof(buffer_t));
-    memset(server->recv_ctx, 0, sizeof(server_ctx_t));
-    memset(server->send_ctx, 0, sizeof(server_ctx_t));
-    balloc(server->buf, SOCKET_BUF_SIZE);
-    server->fd                  = fd;
-    server->recv_ctx->server    = server;
-    server->recv_ctx->connected = 0;
-    server->send_ctx->server    = server;
-    server->send_ctx->connected = 0;
-    server->stage               = STAGE_INIT;
-    server->frag                = 0;
-    server->query               = NULL;
-    server->listen_ctx          = listener;
-    server->remote              = NULL;
-
-    server->e_ctx = ss_malloc(sizeof(cipher_ctx_t));
-    server->d_ctx = ss_malloc(sizeof(cipher_ctx_t));
-    crypto->ctx_init(crypto->cipher, server->e_ctx, 1);
-    crypto->ctx_init(crypto->cipher, server->d_ctx, 0);
-
-    int timeout = max(MIN_TCP_IDLE_TIMEOUT, server->listen_ctx->timeout);
-    ev_io_init(&server->recv_ctx->io, server_recv_cb, fd, EV_READ);
-    ev_io_init(&server->send_ctx->io, server_send_cb, fd, EV_WRITE);
-    ev_timer_init(&server->recv_ctx->watcher, server_timeout_cb,
-                  timeout, timeout);
-
-    cork_dllist_add(&connections, &server->entries);
-
-    return server;
-}
-
-static void
-free_server(server_t *server)
-{
-#ifdef USE_NFCONNTRACK_TOS
-    if (server->tracker) {
-        struct dscptracker *tracker = server->tracker;
-        struct nf_conntrack *ct     = server->tracker->ct;
-        server->tracker = NULL;
-        if (ct) {
-            nfct_destroy(ct);
-        }
-        free(tracker);
-    }
-#endif
-    cork_dllist_remove(&server->entries);
-
-    if (server->remote != NULL) {
-        server->remote->server = NULL;
-    }
-    if (server->e_ctx != NULL) {
-        crypto->ctx_release(server->e_ctx);
-        ss_free(server->e_ctx);
-    }
-    if (server->d_ctx != NULL) {
-        crypto->ctx_release(server->d_ctx);
-        ss_free(server->d_ctx);
-    }
-    if (server->buf != NULL) {
-        bfree(server->buf);
-        ss_free(server->buf);
-    }
-
-    ss_free(server->recv_ctx);
-    ss_free(server->send_ctx);
-    ss_free(server);
-}
-
-static void
-close_and_free_server(EV_P_ server_t *server)
-{
-    if (server != NULL) {
-        if (server->query != NULL) {
-            server->query->server = NULL;
-            server->query         = NULL;
-        }
-        ev_io_stop(EV_A_ & server->send_ctx->io);
-        ev_io_stop(EV_A_ & server->recv_ctx->io);
-        ev_timer_stop(EV_A_ & server->recv_ctx->watcher);
-        close(server->fd);
-        free_server(server);
-        if (verbose) {
-            server_conn--;
-            LOGI("close a connection from client, %d opened client connections", server_conn);
-        }
-    }
-}
-
-static void
-signal_cb(EV_P_ ev_signal *w, int revents)
-{
-    if (revents & EV_SIGNAL) {
-        switch (w->signum) {
-#ifndef __MINGW32__
-        case SIGCHLD:
-            if (!is_plugin_running()) {
-                LOGE("plugin service exit unexpectedly");
-                ret_val = -1;
-            } else
-                return;
-#endif
-        case SIGINT:
-        case SIGTERM:
-            ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-            ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-            ev_signal_stop(EV_DEFAULT, &sigchld_watcher);
-#else
-            ev_io_stop(EV_DEFAULT, &plugin_watcher.io);
-#endif
-            ev_unloop(EV_A_ EVUNLOOP_ALL);
-        }
-    }
-}
-
-#ifdef __MINGW32__
-static void
-plugin_watcher_cb(EV_P_ ev_io *w, int revents)
-{
-    char buf[1];
-    SOCKET fd = accept(plugin_watcher.fd, NULL, NULL);
-    if (fd == INVALID_SOCKET) {
-        return;
-    }
-    recv(fd, buf, 1, 0);
-    closesocket(fd);
-    LOGE("plugin service exit unexpectedly");
-    ret_val = -1;
-    ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-    ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-    ev_io_stop(EV_DEFAULT, &plugin_watcher.io);
-    ev_unloop(EV_A_ EVUNLOOP_ALL);
-}
-
-#endif
-
-static void
-accept_cb(EV_P_ ev_io *w, int revents)
-{
-    listen_ctx_t *listener = (listen_ctx_t *)w;
-    int serverfd           = accept(listener->fd, NULL, NULL);
-    if (serverfd == -1) {
-        ERROR("accept");
-        return;
-    }
-
-    char *peer_name = get_peer_name(serverfd);
-    if (peer_name != NULL) {
-        if (acl) {
-            if ((get_acl_mode() == BLACK_LIST && acl_match_host(peer_name) == 1)
-                || (get_acl_mode() == WHITE_LIST && acl_match_host(peer_name) >= 0)) {
-                LOGE("Access denied from %s", peer_name);
-                close(serverfd);
-                return;
-            }
-        }
-    }
-
-    int opt = 1;
-    setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-
-    if (tcp_incoming_sndbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &tcp_incoming_sndbuf, sizeof(int));
-    }
-
-    if (tcp_incoming_rcvbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &tcp_incoming_rcvbuf, sizeof(int));
-    }
-
-    setnonblocking(serverfd);
-
-    server_t *server = new_server(serverfd, listener);
-    ev_io_start(EV_A_ & server->recv_ctx->io);
-    ev_timer_start(EV_A_ & server->recv_ctx->watcher);
-}
-
-int
-main(int argc, char **argv)
-{
-    int i, c;
-    int pid_flags   = 0;
-    int mptcp       = 0;
-    int mtu         = 0;
-    char *user      = NULL;
-    char *password  = NULL;
-    char *key       = NULL;
-    char *timeout   = NULL;
-    char *method    = NULL;
-    char *pid_path  = NULL;
-    char *conf_path = NULL;
-    char *iface     = NULL;
-
-    char *server_port = NULL;
-    char *plugin_opts = NULL;
-    char *plugin_host = NULL;
-    char *plugin_port = NULL;
-    char tmp_port[8];
-    char *nameservers = NULL;
-
-    int server_num = 0;
-    ss_addr_t server_addr[MAX_REMOTE_NUM];
-    memset(server_addr, 0, sizeof(ss_addr_t) * MAX_REMOTE_NUM);
-    memset(&local_addr_v4, 0, sizeof(struct sockaddr_storage));
-    memset(&local_addr_v6, 0, sizeof(struct sockaddr_storage));
-
-    static struct option long_options[] = {
-        { "fast-open",       no_argument,       NULL, GETOPT_VAL_FAST_OPEN   },
-        { "reuse-port",      no_argument,       NULL, GETOPT_VAL_REUSE_PORT  },
-        { "tcp-incoming-sndbuf", required_argument, NULL, GETOPT_VAL_TCP_INCOMING_SNDBUF },
-        { "tcp-incoming-rcvbuf", required_argument, NULL, GETOPT_VAL_TCP_INCOMING_RCVBUF },
-        { "tcp-outgoing-sndbuf", required_argument, NULL, GETOPT_VAL_TCP_OUTGOING_SNDBUF },
-        { "tcp-outgoing-rcvbuf", required_argument, NULL, GETOPT_VAL_TCP_OUTGOING_RCVBUF },
-        { "no-delay",        no_argument,       NULL, GETOPT_VAL_NODELAY     },
-        { "acl",             required_argument, NULL, GETOPT_VAL_ACL         },
-        { "manager-address", required_argument, NULL,
-          GETOPT_VAL_MANAGER_ADDRESS },
-        { "mtu",             required_argument, NULL, GETOPT_VAL_MTU         },
-        { "help",            no_argument,       NULL, GETOPT_VAL_HELP        },
-        { "plugin",          required_argument, NULL, GETOPT_VAL_PLUGIN      },
-        { "plugin-opts",     required_argument, NULL, GETOPT_VAL_PLUGIN_OPTS },
-        { "password",        required_argument, NULL, GETOPT_VAL_PASSWORD    },
-        { "key",             required_argument, NULL, GETOPT_VAL_KEY         },
-#ifdef __linux__
-        { "mptcp",           no_argument,       NULL, GETOPT_VAL_MPTCP       },
-#ifdef USE_NFTABLES
-        { "nftables-sets",   required_argument, NULL, GETOPT_VAL_NFTABLES_SETS },
-#endif
-#endif
-        { NULL,              0,                 NULL, 0                      }
-    };
-
-    opterr = 0;
-
-    USE_TTY();
-
-    while ((c = getopt_long(argc, argv, "f:s:p:l:k:t:m:b:c:i:d:a:n:huUv6A",
-                            long_options, NULL)) != -1) {
-        switch (c) {
-        case GETOPT_VAL_FAST_OPEN:
-            fast_open = 1;
-            break;
-        case GETOPT_VAL_NODELAY:
-            no_delay = 1;
-            LOGI("enable TCP no-delay");
-            break;
-        case GETOPT_VAL_ACL:
-            LOGI("initializing acl...");
-            acl = !init_acl(optarg);
-            break;
-        case GETOPT_VAL_MANAGER_ADDRESS:
-            manager_addr = optarg;
-            break;
-        case GETOPT_VAL_MTU:
-            mtu = atoi(optarg);
-            LOGI("set MTU to %d", mtu);
-            break;
-        case GETOPT_VAL_PLUGIN:
-            plugin = optarg;
-            break;
-        case GETOPT_VAL_PLUGIN_OPTS:
-            plugin_opts = optarg;
-            break;
-        case GETOPT_VAL_MPTCP:
-            mptcp = get_mptcp(1);
-            if (mptcp)
-                LOGI("enable multipath TCP (%s)", mptcp > 0 ? "out-of-tree" : "upstream");
-            break;
-        case GETOPT_VAL_KEY:
-            key = optarg;
-            break;
-        case GETOPT_VAL_REUSE_PORT:
-            reuse_port = 1;
-            break;
-        case GETOPT_VAL_TCP_INCOMING_SNDBUF:
-            tcp_incoming_sndbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_INCOMING_RCVBUF:
-            tcp_incoming_rcvbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_OUTGOING_SNDBUF:
-            tcp_outgoing_sndbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_OUTGOING_RCVBUF:
-            tcp_outgoing_rcvbuf = atoi(optarg);
-            break;
-#ifdef USE_NFTABLES
-        case GETOPT_VAL_NFTABLES_SETS:
-            nftbl_init(optarg);
-            break;
-#endif
-        case 's':
-            if (server_num < MAX_REMOTE_NUM) {
-                parse_addr(optarg, &server_addr[server_num++]);
-            }
-            break;
-        case 'b':
-            is_bind_local_addr += parse_local_addr(&local_addr_v4, &local_addr_v6, optarg);
-            break;
-        case 'p':
-            server_port = optarg;
-            break;
-        case GETOPT_VAL_PASSWORD:
-        case 'k':
-            password = optarg;
-            break;
-        case 'f':
-            pid_flags = 1;
-            pid_path  = optarg;
-            break;
-        case 't':
-            timeout = optarg;
-            break;
-        case 'm':
-            method = optarg;
-            break;
-        case 'c':
-            conf_path = optarg;
-            break;
-        case 'i':
-            iface = optarg;
-            break;
-        case 'd':
-            nameservers = optarg;
-            break;
-        case 'a':
-            user = optarg;
-            break;
-#ifdef HAVE_SETRLIMIT
-        case 'n':
-            nofile = atoi(optarg);
-            break;
-#endif
-        case 'u':
-            mode = TCP_AND_UDP;
-            break;
-        case 'U':
-            mode = UDP_ONLY;
-            break;
-        case 'v':
-            verbose = 1;
-            break;
-        case GETOPT_VAL_HELP:
-        case 'h':
-            usage();
-            exit(EXIT_SUCCESS);
-        case '6':
-            ipv6first = 1;
-            break;
-        case 'A':
-            FATAL("One time auth has been deprecated. Try AEAD ciphers instead.");
-            break;
-        case '?':
-            // The option character is not recognized.
-            LOGE("Unrecognized option: %s", optarg);
-            opterr = 1;
-            break;
-        }
-    }
-
-    if (opterr) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-    if (argc == 1) {
-        if (conf_path == NULL) {
-            conf_path = get_default_conf();
-        }
-    }
-
-    if (conf_path != NULL) {
-        jconf_t *conf = read_jconf(conf_path);
-        if (server_num == 0) {
-            server_num = conf->remote_num;
-            for (i = 0; i < server_num; i++)
-                server_addr[i] = conf->remote_addr[i];
-        }
-        if (server_port == NULL) {
-            server_port = conf->remote_port;
-        }
-        if (password == NULL) {
-            password = conf->password;
-        }
-        if (key == NULL) {
-            key = conf->key;
-        }
-        if (method == NULL) {
-            method = conf->method;
-        }
-        if (timeout == NULL) {
-            timeout = conf->timeout;
-        }
-        if (user == NULL) {
-            user = conf->user;
-        }
-        if (plugin == NULL) {
-            plugin = conf->plugin;
-        }
-        if (plugin_opts == NULL) {
-            plugin_opts = conf->plugin_opts;
-        }
-        if (mode == TCP_ONLY) {
-            mode = conf->mode;
-        }
-        if (mtu == 0) {
-            mtu = conf->mtu;
-        }
-        if (mptcp == 0) {
-            mptcp = conf->mptcp;
-        }
-        if (no_delay == 0) {
-            no_delay = conf->no_delay;
-        }
-        if (reuse_port == 0) {
-            reuse_port = conf->reuse_port;
-        }
-        if (tcp_incoming_sndbuf == 0) {
-            tcp_incoming_sndbuf = conf->tcp_incoming_sndbuf;
-        }
-        if (tcp_incoming_rcvbuf == 0) {
-            tcp_incoming_rcvbuf = conf->tcp_incoming_rcvbuf;
-        }
-        if (tcp_outgoing_sndbuf == 0) {
-            tcp_outgoing_sndbuf = conf->tcp_outgoing_sndbuf;
-        }
-        if (tcp_outgoing_rcvbuf == 0) {
-            tcp_outgoing_rcvbuf = conf->tcp_outgoing_rcvbuf;
-        }
-        if (fast_open == 0) {
-            fast_open = conf->fast_open;
-        }
-        if (is_bind_local_addr == 0) {
-            is_bind_local_addr += parse_local_addr(&local_addr_v4, &local_addr_v6, conf->local_addr);
-        }
-        if (is_bind_local_addr == 0) {
-            is_bind_local_addr += parse_local_addr(&local_addr_v4, &local_addr_v6, conf->local_addr_v4);
-            is_bind_local_addr += parse_local_addr(&local_addr_v4, &local_addr_v6, conf->local_addr_v6);
-        }
-#ifdef HAVE_SETRLIMIT
-        if (nofile == 0) {
-            nofile = conf->nofile;
-        }
-#endif
-        if (nameservers == NULL) {
-            nameservers = conf->nameserver;
-        }
-        if (ipv6first == 0) {
-            ipv6first = conf->ipv6_first;
-        }
-        if (acl == 0 && conf->acl != NULL) {
-            LOGI("initializing acl...");
-            acl = !init_acl(conf->acl);
-        }
-    }
-
-    if (tcp_incoming_sndbuf != 0 && tcp_incoming_sndbuf < SOCKET_BUF_SIZE) {
-        tcp_incoming_sndbuf = 0;
-    }
-
-    if (tcp_incoming_sndbuf != 0) {
-        LOGI("set TCP incoming connection send buffer size to %d", tcp_incoming_sndbuf);
-    }
-
-    if (tcp_incoming_rcvbuf != 0 && tcp_incoming_rcvbuf < SOCKET_BUF_SIZE) {
-        tcp_incoming_rcvbuf = 0;
-    }
-
-    if (tcp_incoming_rcvbuf != 0) {
-        LOGI("set TCP incoming connection receive buffer size to %d", tcp_incoming_rcvbuf);
-    }
-
-    if (tcp_outgoing_sndbuf != 0 && tcp_outgoing_sndbuf < SOCKET_BUF_SIZE) {
-        tcp_outgoing_sndbuf = 0;
-    }
-
-    if (tcp_outgoing_sndbuf != 0) {
-        LOGI("set TCP outgoing connection send buffer size to %d", tcp_outgoing_sndbuf);
-    }
-
-    if (tcp_outgoing_rcvbuf != 0 && tcp_outgoing_rcvbuf < SOCKET_BUF_SIZE) {
-        tcp_outgoing_rcvbuf = 0;
-    }
-
-    if (tcp_outgoing_rcvbuf != 0) {
-        LOGI("set TCP outgoing connection receive buffer size to %d", tcp_outgoing_rcvbuf);
-    }
-
-    if (server_num == 0) {
-        server_addr[server_num++].host = "0.0.0.0";
-    }
-
-    if (server_num == 0 || server_port == NULL
-        || (password == NULL && key == NULL)) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-    if (is_ipv6only(server_addr, server_num, ipv6first)) {
-        plugin_host = "::1";
-    } else {
-        plugin_host = "127.0.0.1";
-    }
-
-    remote_port = server_port;
-
-#ifdef __MINGW32__
-    winsock_init();
-#endif
-
-    if (plugin != NULL) {
-        uint16_t port = get_local_port();
-        if (port == 0) {
-            FATAL("failed to find a free port");
-        }
-        snprintf(tmp_port, 8, "%d", port);
-        plugin_port = server_port;
-        server_port = tmp_port;
-
-#ifdef __MINGW32__
-        memset(&plugin_watcher, 0, sizeof(plugin_watcher));
-        plugin_watcher.port = get_local_port();
-        if (plugin_watcher.port == 0) {
-            LOGE("failed to assign a control port for plugin");
-        }
-#endif
-    }
-
-    if (method == NULL) {
-        method = "chacha20-ietf-poly1305";
-    }
-
-    if (timeout == NULL) {
-        timeout = "60";
-    }
-
-#ifdef HAVE_SETRLIMIT
-    /*
-     * no need to check the return value here since we will show
-     * the user an error message if setrlimit(2) fails
-     */
-    if (nofile > 1024) {
-        if (verbose) {
-            LOGI("setting NOFILE to %d", nofile);
-        }
-        set_nofile(nofile);
-    }
-#endif
-
-    USE_SYSLOG(argv[0], pid_flags);
-    if (pid_flags) {
-        daemonize(pid_path);
-    }
-
-    if (ipv6first) {
-        LOGI("resolving hostname to IPv6 address first");
-    }
-
-    if (fast_open == 1) {
-#ifdef TCP_FASTOPEN
-        LOGI("using tcp fast open");
-#else
-        LOGE("tcp fast open is not supported by this environment");
-        fast_open = 0;
-#endif
-    }
-
-    if (plugin != NULL) {
-        LOGI("plugin \"%s\" enabled", plugin);
-    }
-
-    if (mode != TCP_ONLY) {
-        LOGI("UDP relay enabled");
-    }
-
-    if (mode == UDP_ONLY) {
-        LOGI("TCP relay disabled");
-    }
-
-    if (no_delay) {
-        LOGI("enable TCP no-delay");
-    }
-
-#ifndef __MINGW32__
-    // ignore SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGABRT, SIG_IGN);
-#endif
-
-    ev_signal_init(&sigint_watcher, signal_cb, SIGINT);
-    ev_signal_init(&sigterm_watcher, signal_cb, SIGTERM);
-    ev_signal_start(EV_DEFAULT, &sigint_watcher);
-    ev_signal_start(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-    ev_signal_init(&sigchld_watcher, signal_cb, SIGCHLD);
-    ev_signal_start(EV_DEFAULT, &sigchld_watcher);
-#endif
-
-    // setup keys
-    LOGI("initializing ciphers... %s", method);
-    crypto = crypto_init(password, key, method);
-    if (crypto == NULL)
-        FATAL("failed to initialize ciphers");
-
-    // initialize ev loop
-    struct ev_loop *loop = EV_DEFAULT;
-
-    // setup dns
-    resolv_init(loop, nameservers, ipv6first);
-
-    if (nameservers != NULL)
-        LOGI("using nameserver: %s", nameservers);
-
-#ifdef __MINGW32__
-    // Listen on plugin control port
-    if (plugin != NULL && plugin_watcher.port != 0) {
-        SOCKET fd;
-        fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-        if (fd != INVALID_SOCKET) {
-            plugin_watcher.valid = 0;
-            do {
-                struct sockaddr_in addr;
-                memset(&addr, 0, sizeof(addr));
-                addr.sin_family      = AF_INET;
-                addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-                addr.sin_port        = htons(plugin_watcher.port);
-                if (bind(fd, (struct sockaddr *)&addr, sizeof(addr))) {
-                    LOGE("failed to bind plugin control port");
-                    break;
-                }
-                if (listen(fd, 1)) {
-                    LOGE("failed to listen on plugin control port");
-                    break;
-                }
-                plugin_watcher.fd = fd;
-                ev_io_init(&plugin_watcher.io, plugin_watcher_cb, fd, EV_READ);
-                ev_io_start(EV_DEFAULT, &plugin_watcher.io);
-                plugin_watcher.valid = 1;
-            } while (0);
-            if (!plugin_watcher.valid) {
-                closesocket(fd);
-                plugin_watcher.port = 0;
-            }
-        }
-    }
-#endif
-
-    // Start plugin server
-    if (plugin != NULL) {
-        int len          = 0;
-        size_t buf_size  = 256 * server_num;
-        char *server_str = ss_malloc(buf_size);
-
-        snprintf(server_str, buf_size, "%s", server_addr[0].host);
-        len = strlen(server_str);
-        for (int i = 1; i < server_num; i++) {
-            snprintf(server_str + len, buf_size - len, "|%s", server_addr[i].host);
-            len = strlen(server_str);
-        }
-
-        int err = start_plugin(plugin, plugin_opts, server_str,
-                               plugin_port, plugin_host, server_port,
-#ifdef __MINGW32__
-                               plugin_watcher.port,
-#endif
-                               MODE_SERVER);
-        if (err) {
-            ERROR("start_plugin");
-            FATAL("failed to start the plugin");
-        }
-    }
-
-    // initialize listen context
-    listen_ctx_t listen_ctx_list[server_num];
-
-    // bind to each interface
-    if (mode != UDP_ONLY) {
-        int num_listen_ctx = 0;
-        for (int i = 0; i < server_num; i++) {
-            const char *host = server_addr[i].host;
-            const char *port = server_addr[i].port ? server_addr[i].port : server_port;
-
-            if (plugin != NULL) {
-                host = plugin_host;
-            }
-
-            if (host && ss_is_ipv6addr(host))
-                LOGI("tcp server listening at [%s]:%s", host, port);
-            else
-                LOGI("tcp server listening at %s:%s", host ? host : "0.0.0.0", port);
-
-            // Bind to port
-            int listenfd;
-            listenfd = create_and_bind(host, port, mptcp);
-            if (listenfd == -1) {
-                continue;
-            }
-            if (listen(listenfd, SSMAXCONN) == -1) {
-                ERROR("listen()");
-                continue;
-            }
-            setfastopen(listenfd);
-            setnonblocking(listenfd);
-            listen_ctx_t *listen_ctx = &listen_ctx_list[i];
-
-            // Setup proxy context
-            listen_ctx->timeout = atoi(timeout);
-            listen_ctx->fd      = listenfd;
-            listen_ctx->iface   = iface;
-            listen_ctx->loop    = loop;
-
-            ev_io_init(&listen_ctx->io, accept_cb, listenfd, EV_READ);
-            ev_io_start(loop, &listen_ctx->io);
-
-            num_listen_ctx++;
-
-            if (plugin != NULL)
-                break;
-        }
-
-        if (num_listen_ctx == 0) {
-            FATAL("failed to listen on any address");
-        }
-    }
-
-    if (mode != TCP_ONLY) {
-        int num_listen_ctx = 0;
-        for (int i = 0; i < server_num; i++) {
-            const char *host = server_addr[i].host;
-            const char *port = server_addr[i].port ? server_addr[i].port : server_port;
-            if (plugin != NULL) {
-                port = plugin_port;
-            }
-            if (host && ss_is_ipv6addr(host))
-                LOGI("udp server listening at [%s]:%s", host, port);
-            else
-                LOGI("udp server listening at %s:%s", host ? host : "0.0.0.0", port);
-            // Setup UDP
-            int err = init_udprelay(host, port, mtu, crypto, atoi(timeout), iface);
-            if (err == -1)
-                continue;
-            num_listen_ctx++;
-        }
-
-        if (num_listen_ctx == 0) {
-            FATAL("failed to listen on any address");
-        }
-    }
-
-#ifndef __MINGW32__
-    if (manager_addr != NULL) {
-        ev_timer_init(&stat_update_watcher, stat_update_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
-        ev_timer_start(EV_DEFAULT, &stat_update_watcher);
-    }
-#endif
-
-#ifndef __MINGW32__
-    // setuid
-    if (user != NULL && !run_as(user)) {
-        FATAL("failed to switch user");
-    }
-
-    if (geteuid() == 0) {
-        LOGI("running from root user");
-    }
-#endif
-
-    // Init connections
-    cork_dllist_init(&connections);
-
-    // start ev loop
-    ev_run(loop, 0);
-
-    if (verbose) {
-        LOGI("closed gracefully");
-    }
-
-#ifndef __MINGW32__
-    if (manager_addr != NULL) {
-        ev_timer_stop(EV_DEFAULT, &stat_update_watcher);
-    }
-#endif
-
-    if (plugin != NULL) {
-        stop_plugin();
-    }
-
-    // Clean up
-
-    resolv_shutdown(loop);
-
-    for (int i = 0; i < server_num; i++) {
-        listen_ctx_t *listen_ctx = &listen_ctx_list[i];
-        if (mode != UDP_ONLY) {
-            ev_io_stop(loop, &listen_ctx->io);
-            close(listen_ctx->fd);
-        }
-        if (plugin != NULL)
-            break;
-    }
-
-    if (mode != UDP_ONLY) {
-        free_connections(loop);
-    }
-
-    if (mode != TCP_ONLY) {
-        free_udprelay();
-    }
-
-#ifdef __MINGW32__
-    if (plugin_watcher.valid) {
-        closesocket(plugin_watcher.fd);
-    }
-
-    winsock_cleanup();
-#endif
-
-    return ret_val;
-}
diff --git a/src/server.h b/src/server.h
deleted file mode 100644
index cdff2c1..0000000
--- a/src/server.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * server.h - Define shadowsocks server's buffers and callbacks
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _SERVER_H
-#define _SERVER_H
-
-#include <time.h>
-#include <libcork/ds.h>
-
-#ifdef HAVE_LIBEV_EV_H
-#include <libev/ev.h>
-#else
-#include <ev.h>
-#endif
-
-#ifdef __MINGW32__
-#include "winsock.h"
-#endif
-
-#include "crypto.h"
-#include "jconf.h"
-#include "netutils.h"
-
-#include "common.h"
-
-typedef struct listen_ctx {
-    ev_io io;
-    int fd;
-    int timeout;
-    char *iface;
-    struct ev_loop *loop;
-} listen_ctx_t;
-
-typedef struct server_ctx {
-    ev_io io;
-    ev_timer watcher;
-    int connected;
-    struct server *server;
-} server_ctx_t;
-
-#ifdef USE_NFCONNTRACK_TOS
-
-#include <libnetfilter_conntrack/libnetfilter_conntrack.h>
-#include <libnetfilter_conntrack/libnetfilter_conntrack_tcp.h>
-
-struct dscptracker {
-    struct nf_conntrack *ct;
-    long unsigned int mark;
-    unsigned int dscp;
-    unsigned int packet_count;
-};
-
-#endif
-
-struct query;
-
-typedef struct server {
-    int fd;
-    int stage;
-    int frag;
-
-    buffer_t *buf;
-
-    cipher_ctx_t *e_ctx;
-    cipher_ctx_t *d_ctx;
-    struct server_ctx *recv_ctx;
-    struct server_ctx *send_ctx;
-    struct listen_ctx *listen_ctx;
-    struct remote *remote;
-
-    struct query *query;
-
-    struct cork_dllist_item entries;
-#ifdef USE_NFCONNTRACK_TOS
-    struct dscptracker *tracker;
-#endif
-} server_t;
-
-typedef struct query {
-    server_t *server;
-    char hostname[MAX_HOSTNAME_LEN];
-} query_t;
-
-typedef struct remote_ctx {
-    ev_io io;
-    int connected;
-    struct remote *remote;
-} remote_ctx_t;
-
-typedef struct remote {
-    int fd;
-#ifdef TCP_FASTOPEN_WINSOCK
-    OVERLAPPED olap;
-    int connect_ex_done;
-#endif
-    buffer_t *buf;
-    struct remote_ctx *recv_ctx;
-    struct remote_ctx *send_ctx;
-    struct server *server;
-} remote_t;
-
-#endif // _SERVER_H
diff --git a/src/socks5.h b/src/socks5.h
deleted file mode 100644
index 42dbcfe..0000000
--- a/src/socks5.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * socks5.h - Define SOCKS5's header
- *
- * Copyright (C) 2013, clowwindy <clowwindy42@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _SOCKS5_H
-#define _SOCKS5_H
-
-#define SVERSION 0x05
-#define METHOD_NOAUTH 0x00
-#define METHOD_UNACCEPTABLE 0xff
-
-// see also: https://www.ietf.org/rfc/rfc1928.txt
-#define SOCKS5_CMD_CONNECT 0x01
-#define SOCKS5_CMD_BIND 0x02
-#define SOCKS5_CMD_UDP_ASSOCIATE 0x03
-
-#define SOCKS5_ATYP_IPV4 0x01
-#define SOCKS5_ATYP_DOMAIN 0x03
-#define SOCKS5_ATYP_IPV6 0x04
-
-#define SOCKS5_REP_SUCCEEDED 0x00
-#define SOCKS5_REP_GENERAL 0x01
-#define SOCKS5_REP_CONN_DISALLOWED 0x02
-#define SOCKS5_REP_NETWORK_UNREACHABLE 0x03
-#define SOCKS5_REP_HOST_UNREACHABLE 0x04
-#define SOCKS5_REP_CONN_REFUSED 0x05
-#define SOCKS5_REP_TTL_EXPIRED 0x06
-#define SOCKS5_REP_CMD_NOT_SUPPORTED 0x07
-#define SOCKS5_REP_ADDRTYPE_NOT_SUPPORTED 0x08
-#define SOCKS5_REP_FF_UNASSIGNED 0x09
-
-struct method_select_request {
-    unsigned char ver;
-    unsigned char nmethods;
-    unsigned char methods[0];
-} __attribute__((packed, aligned(1)));
-
-struct method_select_response {
-    unsigned char ver;
-    unsigned char method;
-} __attribute__((packed, aligned(1)));
-
-struct socks5_request {
-    unsigned char ver;
-    unsigned char cmd;
-    unsigned char rsv;
-    unsigned char atyp;
-} __attribute__((packed, aligned(1)));
-
-struct socks5_response {
-    unsigned char ver;
-    unsigned char rep;
-    unsigned char rsv;
-    unsigned char atyp;
-} __attribute__((packed, aligned(1)));
-
-#endif // _SOCKS5_H
diff --git a/src/stream.c b/src/stream.c
index b2e2cea..4a09933 100644
--- a/src/stream.c
+++ b/src/stream.c
@@ -318,9 +318,6 @@ stream_encrypt_all(buffer_t *plaintext, cipher_t *cipher, size_t capacity)
     cipher_ctx_set_nonce(&cipher_ctx, nonce, nonce_len, 1);
     memcpy(ciphertext->data, nonce, nonce_len);
 
-#ifdef MODULE_REMOTE
-    ppbloom_add((void *)nonce, nonce_len);
-#endif
 
     if (cipher->method >= SALSA20) {
         crypto_stream_xor_ic((uint8_t *)(ciphertext->data + nonce_len),
@@ -376,10 +373,6 @@ stream_encrypt(buffer_t *plaintext, cipher_ctx_t *cipher_ctx, size_t capacity)
         memcpy(ciphertext->data, cipher_ctx->nonce, nonce_len);
         cipher_ctx->counter = 0;
         cipher_ctx->init    = 1;
-
-#ifdef MODULE_REMOTE
-        ppbloom_add((void *)cipher_ctx->nonce, nonce_len);
-#endif
     }
 
     if (cipher->method >= SALSA20) {
diff --git a/src/tunnel.c b/src/tunnel.c
deleted file mode 100644
index 99ed412..0000000
--- a/src/tunnel.c
+++ /dev/null
@@ -1,1449 +0,0 @@
-/*
- * tunnel.c - Setup a local port forwarding through remote shadowsocks server
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <locale.h>
-#include <signal.h>
-#include <string.h>
-#include <strings.h>
-#include <unistd.h>
-#include <getopt.h>
-#ifndef __MINGW32__
-#include <errno.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#include <pthread.h>
-#endif
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
-#include <net/if.h>
-#include <sys/ioctl.h>
-#define SET_INTERFACE
-#endif
-
-#include <libcork/core.h>
-
-#include "netutils.h"
-#include "utils.h"
-#include "plugin.h"
-#include "tunnel.h"
-#include "winsock.h"
-
-#ifndef EAGAIN
-#define EAGAIN EWOULDBLOCK
-#endif
-
-#ifndef EWOULDBLOCK
-#define EWOULDBLOCK EAGAIN
-#endif
-
-static void accept_cb(EV_P_ ev_io *w, int revents);
-static void server_recv_cb(EV_P_ ev_io *w, int revents);
-static void server_send_cb(EV_P_ ev_io *w, int revents);
-static void remote_recv_cb(EV_P_ ev_io *w, int revents);
-static void remote_send_cb(EV_P_ ev_io *w, int revents);
-
-static remote_t *new_remote(int fd, int timeout);
-static server_t *new_server(int fd);
-
-static void free_remote(remote_t *remote);
-static void close_and_free_remote(EV_P_ remote_t *remote);
-static void free_server(server_t *server);
-static void close_and_free_server(EV_P_ server_t *server);
-
-#ifdef __ANDROID__
-int vpn = 0;
-#endif
-
-int verbose    = 0;
-int reuse_port = 0;
-int tcp_incoming_sndbuf = 0;
-int tcp_incoming_rcvbuf = 0;
-int tcp_outgoing_sndbuf = 0;
-int tcp_outgoing_rcvbuf = 0;
-
-static crypto_t *crypto;
-
-static int ipv6first = 0;
-static int mode      = TCP_ONLY;
-#ifdef HAVE_SETRLIMIT
-static int nofile = 0;
-#endif
-static int no_delay = 0;
-int fast_open       = 0;
-static int ret_val  = 0;
-
-static struct ev_signal sigint_watcher;
-static struct ev_signal sigterm_watcher;
-#ifndef __MINGW32__
-static struct ev_signal sigchld_watcher;
-#else
-static struct plugin_watcher_t {
-    ev_io io;
-    SOCKET fd;
-    uint16_t port;
-    int valid;
-} plugin_watcher;
-#endif
-
-#ifndef __MINGW32__
-static int
-setnonblocking(int fd)
-{
-    int flags;
-    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
-        flags = 0;
-    }
-    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-}
-
-#endif
-
-int
-create_and_bind(const char *addr, const char *port)
-{
-    struct addrinfo hints;
-    struct addrinfo *result, *rp;
-    int s, listen_sock = -1;
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_family   = AF_UNSPEC;   /* Return IPv4 and IPv6 choices */
-    hints.ai_socktype = SOCK_STREAM; /* We want a TCP socket */
-
-    result = NULL;
-
-    s = getaddrinfo(addr, port, &hints, &result);
-    if (s != 0) {
-        LOGI("getaddrinfo: %s", gai_strerror(s));
-        return -1;
-    }
-
-    if (result == NULL) {
-        LOGE("Could not bind");
-        return -1;
-    }
-
-    for (rp = result; rp != NULL; rp = rp->ai_next) {
-        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
-        if (listen_sock == -1) {
-            continue;
-        }
-
-        int opt = 1;
-        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-        if (reuse_port) {
-            int err = set_reuseport(listen_sock);
-            if (err == 0) {
-                LOGI("tcp port reuse enabled");
-            }
-        }
-
-        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);
-        if (s == 0) {
-            /* We managed to bind successfully! */
-            break;
-        } else {
-            ERROR("bind");
-        }
-
-        close(listen_sock);
-        listen_sock = -1;
-    }
-
-    freeaddrinfo(result);
-
-    return listen_sock;
-}
-
-static void
-server_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
-    remote_t *remote              = server->remote;
-
-    if (remote == NULL) {
-        close_and_free_server(EV_A_ server);
-        return;
-    }
-
-    ssize_t r = recv(server->fd, remote->buf->data, SOCKET_BUF_SIZE, 0);
-
-    if (r == 0) {
-        // connection closed
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else if (r == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data
-            // continue to wait for recv
-            return;
-        } else {
-            ERROR("server recv");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    remote->buf->len = r;
-
-    int err = crypto->encrypt(remote->buf, server->e_ctx, SOCKET_BUF_SIZE);
-
-    if (err) {
-        LOGE("invalid password or cipher");
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    }
-
-    int s = send(remote->fd, remote->buf->data, remote->buf->len, 0);
-
-    if (s == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data, wait for send
-            remote->buf->idx = 0;
-            ev_io_stop(EV_A_ & server_recv_ctx->io);
-            ev_io_start(EV_A_ & remote->send_ctx->io);
-            return;
-        } else {
-            ERROR("send");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    } else if (s < remote->buf->len) {
-        remote->buf->len -= s;
-        remote->buf->idx  = s;
-        ev_io_stop(EV_A_ & server_recv_ctx->io);
-        ev_io_start(EV_A_ & remote->send_ctx->io);
-        return;
-    }
-}
-
-static void
-server_send_cb(EV_P_ ev_io *w, int revents)
-{
-    server_ctx_t *server_send_ctx = (server_ctx_t *)w;
-    server_t *server              = server_send_ctx->server;
-    remote_t *remote              = server->remote;
-    if (server->buf->len == 0) {
-        // close and free
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else {
-        // has data to send
-        ssize_t s = send(server->fd, server->buf->data + server->buf->idx,
-                         server->buf->len, 0);
-        if (s == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("send");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        } else if (s < server->buf->len) {
-            // partly sent, move memory, wait for the next time to send
-            server->buf->len -= s;
-            server->buf->idx += s;
-            return;
-        } else {
-            // all sent out, wait for reading
-            server->buf->len = 0;
-            server->buf->idx = 0;
-            ev_io_stop(EV_A_ & server_send_ctx->io);
-            if (remote != NULL) {
-                ev_io_start(EV_A_ & remote->recv_ctx->io);
-            } else {
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-        }
-    }
-}
-
-static void
-remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
-{
-    remote_ctx_t *remote_ctx
-        = cork_container_of(watcher, remote_ctx_t, watcher);
-
-    remote_t *remote = remote_ctx->remote;
-    server_t *server = remote->server;
-
-    if (verbose) {
-        LOGI("TCP connection timeout");
-    }
-
-    ev_timer_stop(EV_A_ watcher);
-
-    close_and_free_remote(EV_A_ remote);
-    close_and_free_server(EV_A_ server);
-}
-
-static void
-remote_recv_cb(EV_P_ ev_io *w, int revents)
-{
-    remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_recv_ctx->remote;
-    server_t *server              = remote->server;
-
-    ssize_t r = recv(remote->fd, server->buf->data, SOCKET_BUF_SIZE, 0);
-
-    if (r == 0) {
-        // connection closed
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else if (r == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data
-            // continue to wait for recv
-            return;
-        } else {
-            ERROR("remote recv");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    server->buf->len = r;
-
-    int err = crypto->decrypt(server->buf, server->d_ctx, SOCKET_BUF_SIZE);
-    if (err == CRYPTO_ERROR) {
-        LOGE("invalid password or cipher");
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else if (err == CRYPTO_NEED_MORE) {
-        return; // Wait for more
-    }
-
-    int s = send(server->fd, server->buf->data, server->buf->len, 0);
-
-    if (s == -1) {
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            // no data, wait for send
-            server->buf->idx = 0;
-            ev_io_stop(EV_A_ & remote_recv_ctx->io);
-            ev_io_start(EV_A_ & server->send_ctx->io);
-        } else {
-            ERROR("send");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    } else if (s < server->buf->len) {
-        server->buf->len -= s;
-        server->buf->idx  = s;
-        ev_io_stop(EV_A_ & remote_recv_ctx->io);
-        ev_io_start(EV_A_ & server->send_ctx->io);
-    }
-
-    // Disable TCP_NODELAY after the first response are sent
-    if (!remote->recv_ctx->connected && !no_delay) {
-        int opt = 0;
-        setsockopt(server->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-        setsockopt(remote->fd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-    }
-    remote->recv_ctx->connected = 1;
-}
-
-static void
-remote_send_cb(EV_P_ ev_io *w, int revents)
-{
-    remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_send_ctx->remote;
-    server_t *server              = remote->server;
-
-    ev_timer_stop(EV_A_ & remote_send_ctx->watcher);
-
-    if (!remote_send_ctx->connected) {
-        int r = 0;
-
-        if (remote->addr == NULL) {
-            struct sockaddr_storage addr;
-            socklen_t len = sizeof(struct sockaddr_storage);
-            r = getpeername(remote->fd, (struct sockaddr *)&addr, &len);
-        }
-
-        if (r == 0) {
-            remote_send_ctx->connected = 1;
-
-            assert(remote->buf->len == 0);
-            buffer_t *abuf = remote->buf;
-
-            ss_addr_t *sa = &server->destaddr;
-            struct cork_ip ip;
-            if (cork_ip_init(&ip, sa->host) != -1) {
-                if (ip.version == 4) {
-                    // send as IPv4
-                    struct in_addr host;
-                    memset(&host, 0, sizeof(struct in_addr));
-                    int host_len = sizeof(struct in_addr);
-
-                    if (inet_pton(AF_INET, sa->host, &host) == -1) {
-                        FATAL("IP parser error");
-                    }
-                    abuf->data[abuf->len++] = 1;
-                    memcpy(abuf->data + abuf->len, &host, host_len);
-                    abuf->len += host_len;
-                } else if (ip.version == 6) {
-                    // send as IPv6
-                    struct in6_addr host;
-                    memset(&host, 0, sizeof(struct in6_addr));
-                    int host_len = sizeof(struct in6_addr);
-
-                    if (inet_pton(AF_INET6, sa->host, &host) == -1) {
-                        FATAL("IP parser error");
-                    }
-                    abuf->data[abuf->len++] = 4;
-                    memcpy(abuf->data + abuf->len, &host, host_len);
-                    abuf->len += host_len;
-                } else {
-                    FATAL("IP parser error");
-                }
-            } else {
-                // send as domain
-                int host_len = strlen(sa->host);
-
-                abuf->data[abuf->len++] = 3;
-                abuf->data[abuf->len++] = host_len;
-                memcpy(abuf->data + abuf->len, sa->host, host_len);
-                abuf->len += host_len;
-            }
-
-            uint16_t port = htons(atoi(sa->port));
-            memcpy(abuf->data + abuf->len, &port, 2);
-            abuf->len += 2;
-
-            int err = crypto->encrypt(abuf, server->e_ctx, SOCKET_BUF_SIZE);
-
-            if (err) {
-                LOGE("invalid password or cipher");
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-                return;
-            }
-
-            ev_io_start(EV_A_ & remote->recv_ctx->io);
-        } else {
-            ERROR("getpeername");
-            // not connected
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    if (remote->buf->len == 0) {
-        // close and free
-        close_and_free_remote(EV_A_ remote);
-        close_and_free_server(EV_A_ server);
-        return;
-    } else {
-        // has data to send
-        ssize_t s = -1;
-        if (remote->addr != NULL) {
-#if defined(TCP_FASTOPEN_WINSOCK)
-            DWORD s   = -1;
-            DWORD err = 0;
-            do {
-                int optval = 1;
-                // Set fast open option
-                if (setsockopt(remote->fd, IPPROTO_TCP, TCP_FASTOPEN,
-                               &optval, sizeof(optval)) != 0) {
-                    ERROR("setsockopt");
-                    break;
-                }
-                // Load ConnectEx function
-                LPFN_CONNECTEX ConnectEx = winsock_getconnectex();
-                if (ConnectEx == NULL) {
-                    LOGE("Cannot load ConnectEx() function");
-                    err = WSAENOPROTOOPT;
-                    break;
-                }
-                // ConnectEx requires a bound socket
-                if (winsock_dummybind(remote->fd,
-                                      (struct sockaddr *)&(remote->addr)) != 0) {
-                    ERROR("bind");
-                    break;
-                }
-                // Call ConnectEx to send data
-                memset(&remote->olap, 0, sizeof(remote->olap));
-                remote->connect_ex_done = 0;
-                if (ConnectEx(remote->fd, (const struct sockaddr *)&(remote->addr),
-                              get_sockaddr_len(remote->addr), remote->buf->data, remote->buf->len,
-                              &s, &remote->olap)) {
-                    remote->connect_ex_done = 1;
-                    break;
-                }
-                // XXX: ConnectEx pending, check later in remote_send
-                if (WSAGetLastError() == ERROR_IO_PENDING) {
-                    err = CONNECT_IN_PROGRESS;
-                    break;
-                }
-                ERROR("ConnectEx");
-            } while (0);
-            // Set error number
-            if (err) {
-                SetLastError(err);
-            }
-#elif defined(CONNECT_DATA_IDEMPOTENT)
-            ((struct sockaddr_in *)&(remote->addr))->sin_len = sizeof(struct sockaddr_in);
-            sa_endpoints_t endpoints;
-            memset((char *)&endpoints, 0, sizeof(endpoints));
-            endpoints.sae_dstaddr    = (struct sockaddr *)&(remote->addr);
-            endpoints.sae_dstaddrlen = get_sockaddr_len(remote->addr);
-            s                        = connectx(remote->fd, &endpoints, SAE_ASSOCID_ANY,
-                                                CONNECT_RESUME_ON_READ_WRITE | CONNECT_DATA_IDEMPOTENT,
-                                                NULL, 0, NULL, NULL);
-#elif defined(TCP_FASTOPEN_CONNECT)
-            int optval = 1;
-            if (setsockopt(remote->fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT,
-                           (void *)&optval, sizeof(optval)) < 0)
-                FATAL("failed to set TCP_FASTOPEN_CONNECT");
-            s = connect(remote->fd, remote->addr, get_sockaddr_len(remote->addr));
-            if (s == 0)
-                s = send(remote->fd, remote->buf->data, remote->buf->len, 0);
-#elif defined(MSG_FASTOPEN)
-            s = sendto(remote->fd, remote->buf->data + remote->buf->idx,
-                       remote->buf->len, MSG_FASTOPEN, remote->addr,
-                       get_sockaddr_len(remote->addr));
-#else
-            FATAL("tcp fast open is not supported on this platform");
-#endif
-
-            remote->addr = NULL;
-
-            if (s == -1) {
-                if (errno == CONNECT_IN_PROGRESS) {
-                    ev_io_start(EV_A_ & remote_send_ctx->io);
-                    ev_timer_start(EV_A_ & remote_send_ctx->watcher);
-                } else {
-                    fast_open = 0;
-                    if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
-                        errno == ENOPROTOOPT) {
-                        LOGE("fast open is not supported on this platform");
-                    } else {
-                        ERROR("fast_open_connect");
-                    }
-                    close_and_free_remote(EV_A_ remote);
-                    close_and_free_server(EV_A_ server);
-                }
-                return;
-            }
-        } else {
-            s = send(remote->fd, remote->buf->data + remote->buf->idx,
-                     remote->buf->len, 0);
-        }
-
-        if (s == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("send");
-                // close and free
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
-            }
-            return;
-        } else if (s < remote->buf->len) {
-            // partly sent, move memory, wait for the next time to send
-            remote->buf->len -= s;
-            remote->buf->idx += s;
-            return;
-        } else {
-            // all sent out, wait for reading
-            remote->buf->len = 0;
-            remote->buf->idx = 0;
-            ev_io_stop(EV_A_ & remote_send_ctx->io);
-            ev_io_start(EV_A_ & server->recv_ctx->io);
-        }
-    }
-}
-
-static remote_t *
-new_remote(int fd, int timeout)
-{
-    remote_t *remote = ss_malloc(sizeof(remote_t));
-    memset(remote, 0, sizeof(remote_t));
-
-    remote->recv_ctx = ss_malloc(sizeof(remote_ctx_t));
-    remote->send_ctx = ss_malloc(sizeof(remote_ctx_t));
-    remote->buf      = ss_malloc(sizeof(buffer_t));
-    balloc(remote->buf, SOCKET_BUF_SIZE);
-    memset(remote->recv_ctx, 0, sizeof(remote_ctx_t));
-    memset(remote->send_ctx, 0, sizeof(remote_ctx_t));
-    remote->fd                  = fd;
-    remote->recv_ctx->remote    = remote;
-    remote->recv_ctx->connected = 0;
-    remote->send_ctx->remote    = remote;
-    remote->send_ctx->connected = 0;
-
-    ev_io_init(&remote->recv_ctx->io, remote_recv_cb, fd, EV_READ);
-    ev_io_init(&remote->send_ctx->io, remote_send_cb, fd, EV_WRITE);
-    ev_timer_init(&remote->send_ctx->watcher, remote_timeout_cb,
-                  min(MAX_CONNECT_TIMEOUT, timeout), 0);
-
-    return remote;
-}
-
-static void
-free_remote(remote_t *remote)
-{
-    if (remote->server != NULL) {
-        remote->server->remote = NULL;
-    }
-    if (remote->buf != NULL) {
-        bfree(remote->buf);
-        ss_free(remote->buf);
-    }
-    ss_free(remote->recv_ctx);
-    ss_free(remote->send_ctx);
-    ss_free(remote);
-}
-
-static void
-close_and_free_remote(EV_P_ remote_t *remote)
-{
-    if (remote != NULL) {
-        ev_timer_stop(EV_A_ & remote->send_ctx->watcher);
-        ev_io_stop(EV_A_ & remote->send_ctx->io);
-        ev_io_stop(EV_A_ & remote->recv_ctx->io);
-        close(remote->fd);
-        free_remote(remote);
-    }
-}
-
-static server_t *
-new_server(int fd)
-{
-    server_t *server = ss_malloc(sizeof(server_t));
-    memset(server, 0, sizeof(server_t));
-
-    server->recv_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->send_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->buf      = ss_malloc(sizeof(buffer_t));
-    balloc(server->buf, SOCKET_BUF_SIZE);
-    memset(server->recv_ctx, 0, sizeof(server_ctx_t));
-    memset(server->send_ctx, 0, sizeof(server_ctx_t));
-    server->fd                  = fd;
-    server->recv_ctx->server    = server;
-    server->recv_ctx->connected = 0;
-    server->send_ctx->server    = server;
-    server->send_ctx->connected = 0;
-
-    server->e_ctx = ss_malloc(sizeof(cipher_ctx_t));
-    server->d_ctx = ss_malloc(sizeof(cipher_ctx_t));
-    crypto->ctx_init(crypto->cipher, server->e_ctx, 1);
-    crypto->ctx_init(crypto->cipher, server->d_ctx, 0);
-
-    ev_io_init(&server->recv_ctx->io, server_recv_cb, fd, EV_READ);
-    ev_io_init(&server->send_ctx->io, server_send_cb, fd, EV_WRITE);
-
-    return server;
-}
-
-static void
-free_server(server_t *server)
-{
-    if (server->remote != NULL) {
-        server->remote->server = NULL;
-    }
-    if (server->e_ctx != NULL) {
-        crypto->ctx_release(server->e_ctx);
-        ss_free(server->e_ctx);
-    }
-    if (server->d_ctx != NULL) {
-        crypto->ctx_release(server->d_ctx);
-        ss_free(server->d_ctx);
-    }
-    if (server->buf != NULL) {
-        bfree(server->buf);
-        ss_free(server->buf);
-    }
-    ss_free(server->recv_ctx);
-    ss_free(server->send_ctx);
-    ss_free(server);
-}
-
-static void
-close_and_free_server(EV_P_ server_t *server)
-{
-    if (server != NULL) {
-        ev_io_stop(EV_A_ & server->send_ctx->io);
-        ev_io_stop(EV_A_ & server->recv_ctx->io);
-        close(server->fd);
-        free_server(server);
-    }
-}
-
-static void
-accept_cb(EV_P_ ev_io *w, int revents)
-{
-    struct listen_ctx *listener = (struct listen_ctx *)w;
-    int serverfd                = accept(listener->fd, NULL, NULL);
-    if (serverfd == -1) {
-        ERROR("accept");
-        return;
-    }
-    setnonblocking(serverfd);
-    int opt = 1;
-    setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-
-    if (tcp_incoming_sndbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &tcp_incoming_sndbuf, sizeof(int));
-    }
-
-    if (tcp_incoming_rcvbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &tcp_incoming_rcvbuf, sizeof(int));
-    }
-
-    int index                    = rand() % listener->remote_num;
-    struct sockaddr *remote_addr = listener->remote_addr[index];
-
-    int protocol = IPPROTO_TCP;
-    if (listener->mptcp < 0) {
-        protocol = IPPROTO_MPTCP; // Enable upstream MPTCP
-    }
-    int remotefd = socket(remote_addr->sa_family, SOCK_STREAM, protocol);
-    if (remotefd == -1) {
-        ERROR("socket");
-        return;
-    }
-
-#ifdef __ANDROID__
-    if (vpn) {
-        int not_protect = 0;
-        if (remote_addr->sa_family == AF_INET) {
-            struct sockaddr_in *s = (struct sockaddr_in *)remote_addr;
-            if (s->sin_addr.s_addr == inet_addr("127.0.0.1"))
-                not_protect = 1;
-        }
-        if (!not_protect) {
-            if (protect_socket(remotefd) == -1) {
-                ERROR("protect_socket");
-                close(remotefd);
-                return;
-            }
-        }
-    }
-#endif
-
-    int keepAlive = 1;
-    setsockopt(remotefd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepAlive, sizeof(keepAlive));
-    setsockopt(remotefd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
-
-    // Enable out-of-tree MPTCP
-    if (listener->mptcp > 1) {
-        int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
-        if (err == -1) {
-            ERROR("failed to enable out-of-tree multipath TCP");
-        }
-    } else if (listener->mptcp == 1) {
-        int i = 0;
-        while ((listener->mptcp = mptcp_enabled_values[i]) > 0) {
-            int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
-            if (err != -1) {
-                break;
-            }
-            i++;
-        }
-        if (listener->mptcp == 0) {
-            ERROR("failed to enable out-of-tree multipath TCP");
-        }
-    }
-
-    if (tcp_outgoing_sndbuf > 0) {
-        setsockopt(remotefd, SOL_SOCKET, SO_SNDBUF, &tcp_outgoing_sndbuf, sizeof(int));
-    }
-
-    if (tcp_outgoing_rcvbuf > 0) {
-        setsockopt(remotefd, SOL_SOCKET, SO_RCVBUF, &tcp_outgoing_rcvbuf, sizeof(int));
-    }
-
-    // Setup
-    setnonblocking(remotefd);
-#ifdef SET_INTERFACE
-    if (listener->iface) {
-        if (setinterface(remotefd, listener->iface) == -1)
-            ERROR("setinterface");
-    }
-#endif
-
-    server_t *server = new_server(serverfd);
-    remote_t *remote = new_remote(remotefd, listener->timeout);
-    server->destaddr = listener->tunnel_addr;
-    server->remote   = remote;
-    remote->server   = server;
-
-    if (fast_open) {
-        remote->addr = remote_addr;
-    } else {
-        int r = connect(remotefd, remote_addr, get_sockaddr_len(remote_addr));
-
-        if (r == -1 && errno != CONNECT_IN_PROGRESS) {
-            ERROR("connect");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
-            return;
-        }
-    }
-
-    // listen to remote connected event
-    ev_io_start(EV_A_ & remote->send_ctx->io);
-    ev_timer_start(EV_A_ & remote->send_ctx->watcher);
-}
-
-static void
-signal_cb(EV_P_ ev_signal *w, int revents)
-{
-    if (revents & EV_SIGNAL) {
-        switch (w->signum) {
-#ifndef __MINGW32__
-        case SIGCHLD:
-            if (!is_plugin_running()) {
-                LOGE("plugin service exit unexpectedly");
-                ret_val = -1;
-            } else
-                return;
-#endif
-        case SIGINT:
-        case SIGTERM:
-            ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-            ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-            ev_signal_stop(EV_DEFAULT, &sigchld_watcher);
-#else
-            ev_io_stop(EV_DEFAULT, &plugin_watcher.io);
-#endif
-            ev_unloop(EV_A_ EVUNLOOP_ALL);
-        }
-    }
-}
-
-#ifdef __MINGW32__
-static void
-plugin_watcher_cb(EV_P_ ev_io *w, int revents)
-{
-    char buf[1];
-    SOCKET fd = accept(plugin_watcher.fd, NULL, NULL);
-    if (fd == INVALID_SOCKET) {
-        return;
-    }
-    recv(fd, buf, 1, 0);
-    closesocket(fd);
-    LOGE("plugin service exit unexpectedly");
-    ret_val = -1;
-    ev_signal_stop(EV_DEFAULT, &sigint_watcher);
-    ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
-    ev_io_stop(EV_DEFAULT, &plugin_watcher.io);
-    ev_unloop(EV_A_ EVUNLOOP_ALL);
-}
-
-#endif
-
-int
-main(int argc, char **argv)
-{
-    srand(time(NULL));
-
-    int i, c;
-    int pid_flags    = 0;
-    int mptcp        = 0;
-    int mtu          = 0;
-    char *user       = NULL;
-    char *local_port = NULL;
-    char *local_addr = NULL;
-    char *password   = NULL;
-    char *key        = NULL;
-    char *timeout    = NULL;
-    char *method     = NULL;
-    char *pid_path   = NULL;
-    char *conf_path  = NULL;
-    char *iface      = NULL;
-
-    char *plugin      = NULL;
-    char *plugin_opts = NULL;
-    char *plugin_host = NULL;
-    char *plugin_port = NULL;
-    char tmp_port[8];
-
-    ss_addr_t tunnel_addr = { .host = NULL, .port = NULL };
-    char *tunnel_addr_str = NULL;
-
-    int remote_num    = 0;
-    char *remote_port = NULL;
-    ss_addr_t remote_addr[MAX_REMOTE_NUM];
-
-    memset(remote_addr, 0, sizeof(ss_addr_t) * MAX_REMOTE_NUM);
-
-    static struct option long_options[] = {
-        { "fast-open",   no_argument,       NULL, GETOPT_VAL_FAST_OPEN   },
-        { "mtu",         required_argument, NULL, GETOPT_VAL_MTU         },
-        { "no-delay",    no_argument,       NULL, GETOPT_VAL_NODELAY     },
-        { "mptcp",       no_argument,       NULL, GETOPT_VAL_MPTCP       },
-        { "plugin",      required_argument, NULL, GETOPT_VAL_PLUGIN      },
-        { "plugin-opts", required_argument, NULL, GETOPT_VAL_PLUGIN_OPTS },
-        { "reuse-port",  no_argument,       NULL, GETOPT_VAL_REUSE_PORT  },
-        { "tcp-incoming-sndbuf", required_argument, NULL, GETOPT_VAL_TCP_INCOMING_SNDBUF },
-        { "tcp-incoming-rcvbuf", required_argument, NULL, GETOPT_VAL_TCP_INCOMING_RCVBUF },
-        { "tcp-outgoing-sndbuf", required_argument, NULL, GETOPT_VAL_TCP_OUTGOING_SNDBUF },
-        { "tcp-outgoing-rcvbuf", required_argument, NULL, GETOPT_VAL_TCP_OUTGOING_RCVBUF },
-        { "password",    required_argument, NULL, GETOPT_VAL_PASSWORD    },
-        { "key",         required_argument, NULL, GETOPT_VAL_KEY         },
-        { "help",        no_argument,       NULL, GETOPT_VAL_HELP        },
-        { NULL,          0,                 NULL, 0                      }
-    };
-
-    opterr = 0;
-
-    USE_TTY();
-
-#ifdef __ANDROID__
-    while ((c = getopt_long(argc, argv, "f:s:p:l:k:t:m:i:c:b:L:a:n:huUvV6A",
-                            long_options, NULL)) != -1) {
-#else
-    while ((c = getopt_long(argc, argv, "f:s:p:l:k:t:m:i:c:b:L:a:n:huUv6A",
-                            long_options, NULL)) != -1) {
-#endif
-        switch (c) {
-        case GETOPT_VAL_FAST_OPEN:
-            fast_open = 1;
-            break;
-        case GETOPT_VAL_MTU:
-            mtu = atoi(optarg);
-            LOGI("set MTU to %d", mtu);
-            break;
-        case GETOPT_VAL_MPTCP:
-            mptcp = get_mptcp(1);
-            if (mptcp)
-                LOGI("enable multipath TCP (%s)", mptcp > 0 ? "out-of-tree" : "upstream");
-            break;
-        case GETOPT_VAL_NODELAY:
-            no_delay = 1;
-            LOGI("enable TCP no-delay");
-            break;
-        case GETOPT_VAL_PLUGIN:
-            plugin = optarg;
-            break;
-        case GETOPT_VAL_PLUGIN_OPTS:
-            plugin_opts = optarg;
-            break;
-        case GETOPT_VAL_KEY:
-            key = optarg;
-            break;
-        case GETOPT_VAL_REUSE_PORT:
-            reuse_port = 1;
-            break;
-        case GETOPT_VAL_TCP_INCOMING_SNDBUF:
-            tcp_incoming_sndbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_INCOMING_RCVBUF:
-            tcp_incoming_rcvbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_OUTGOING_SNDBUF:
-            tcp_outgoing_sndbuf = atoi(optarg);
-            break;
-        case GETOPT_VAL_TCP_OUTGOING_RCVBUF:
-            tcp_outgoing_rcvbuf = atoi(optarg);
-            break;
-        case 's':
-            if (remote_num < MAX_REMOTE_NUM) {
-                parse_addr(optarg, &remote_addr[remote_num++]);
-            }
-            break;
-        case 'p':
-            remote_port = optarg;
-            break;
-        case 'l':
-            local_port = optarg;
-            break;
-        case GETOPT_VAL_PASSWORD:
-        case 'k':
-            password = optarg;
-            break;
-        case 'f':
-            pid_flags = 1;
-            pid_path  = optarg;
-            break;
-        case 't':
-            timeout = optarg;
-            break;
-        case 'm':
-            method = optarg;
-            break;
-        case 'c':
-            conf_path = optarg;
-            break;
-        case 'i':
-            iface = optarg;
-            break;
-        case 'b':
-            local_addr = optarg;
-            break;
-        case 'u':
-            mode = TCP_AND_UDP;
-            break;
-        case 'U':
-            mode = UDP_ONLY;
-            break;
-        case 'L':
-            tunnel_addr_str = optarg;
-            break;
-        case 'a':
-            user = optarg;
-            break;
-#ifdef HAVE_SETRLIMIT
-        case 'n':
-            nofile = atoi(optarg);
-            break;
-#endif
-        case 'v':
-            verbose = 1;
-            break;
-        case GETOPT_VAL_HELP:
-        case 'h':
-            usage();
-            exit(EXIT_SUCCESS);
-        case '6':
-            ipv6first = 1;
-            break;
-#ifdef __ANDROID__
-        case 'V':
-            vpn = 1;
-            break;
-#endif
-        case 'A':
-            FATAL("One time auth has been deprecated. Try AEAD ciphers instead.");
-            break;
-        case '?':
-            // The option character is not recognized.
-            LOGE("Unrecognized option: %s", optarg);
-            opterr = 1;
-            break;
-        }
-    }
-
-    if (opterr) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-    if (argc == 1) {
-        if (conf_path == NULL) {
-            conf_path = get_default_conf();
-        }
-    }
-
-    if (conf_path != NULL) {
-        jconf_t *conf = read_jconf(conf_path);
-        if (remote_num == 0) {
-            remote_num = conf->remote_num;
-            for (i = 0; i < remote_num; i++)
-                remote_addr[i] = conf->remote_addr[i];
-        }
-        if (remote_port == NULL) {
-            remote_port = conf->remote_port;
-        }
-        if (local_addr == NULL) {
-            local_addr = conf->local_addr;
-        }
-        if (local_port == NULL) {
-            local_port = conf->local_port;
-        }
-        if (password == NULL) {
-            password = conf->password;
-        }
-        if (key == NULL) {
-            key = conf->key;
-        }
-        if (method == NULL) {
-            method = conf->method;
-        }
-        if (timeout == NULL) {
-            timeout = conf->timeout;
-        }
-        if (user == NULL) {
-            user = conf->user;
-        }
-        if (plugin == NULL) {
-            plugin = conf->plugin;
-        }
-        if (plugin_opts == NULL) {
-            plugin_opts = conf->plugin_opts;
-        }
-        if (tunnel_addr_str == NULL) {
-            tunnel_addr_str = conf->tunnel_address;
-        }
-        if (mode == TCP_ONLY) {
-            mode = conf->mode;
-        }
-        if (mtu == 0) {
-            mtu = conf->mtu;
-        }
-        if (mptcp == 0) {
-            mptcp = conf->mptcp;
-        }
-        if (no_delay == 0) {
-            no_delay = conf->no_delay;
-        }
-        if (reuse_port == 0) {
-            reuse_port = conf->reuse_port;
-        }
-        if (tcp_incoming_sndbuf == 0) {
-            tcp_incoming_sndbuf = conf->tcp_incoming_sndbuf;
-        }
-        if (tcp_incoming_rcvbuf == 0) {
-            tcp_incoming_rcvbuf = conf->tcp_incoming_rcvbuf;
-        }
-        if (tcp_outgoing_sndbuf == 0) {
-            tcp_outgoing_sndbuf = conf->tcp_outgoing_sndbuf;
-        }
-        if (tcp_outgoing_rcvbuf == 0) {
-            tcp_outgoing_rcvbuf = conf->tcp_outgoing_rcvbuf;
-        }
-        if (fast_open == 0) {
-            fast_open = conf->fast_open;
-        }
-#ifdef HAVE_SETRLIMIT
-        if (nofile == 0) {
-            nofile = conf->nofile;
-        }
-#endif
-    }
-
-    if (remote_num == 0 || remote_port == NULL || tunnel_addr_str == NULL
-        || local_port == NULL || (password == NULL && key == NULL)) {
-        usage();
-        exit(EXIT_FAILURE);
-    }
-
-#ifdef __MINGW32__
-    winsock_init();
-#endif
-
-    if (tcp_incoming_sndbuf != 0 && tcp_incoming_sndbuf < SOCKET_BUF_SIZE) {
-        tcp_incoming_sndbuf = 0;
-    }
-
-    if (tcp_incoming_sndbuf != 0) {
-        LOGI("set TCP incoming connection send buffer size to %d", tcp_incoming_sndbuf);
-    }
-
-    if (tcp_incoming_rcvbuf != 0 && tcp_incoming_rcvbuf < SOCKET_BUF_SIZE) {
-        tcp_incoming_rcvbuf = 0;
-    }
-
-    if (tcp_incoming_rcvbuf != 0) {
-        LOGI("set TCP incoming connection receive buffer size to %d", tcp_incoming_rcvbuf);
-    }
-
-    if (tcp_outgoing_sndbuf != 0 && tcp_outgoing_sndbuf < SOCKET_BUF_SIZE) {
-        tcp_outgoing_sndbuf = 0;
-    }
-
-    if (tcp_outgoing_sndbuf != 0) {
-        LOGI("set TCP outgoing connection send buffer size to %d", tcp_outgoing_sndbuf);
-    }
-
-    if (tcp_outgoing_rcvbuf != 0 && tcp_outgoing_rcvbuf < SOCKET_BUF_SIZE) {
-        tcp_outgoing_rcvbuf = 0;
-    }
-
-    if (tcp_outgoing_rcvbuf != 0) {
-        LOGI("set TCP outgoing connection receive buffer size to %d", tcp_outgoing_rcvbuf);
-    }
-
-    if (plugin != NULL) {
-        uint16_t port = get_local_port();
-        if (port == 0) {
-            FATAL("failed to find a free port");
-        }
-        snprintf(tmp_port, 8, "%d", port);
-        if (is_ipv6only(remote_addr, remote_num, ipv6first)) {
-            plugin_host = "::1";
-        } else {
-            plugin_host = "127.0.0.1";
-        }
-        plugin_port = tmp_port;
-
-#ifdef __MINGW32__
-        memset(&plugin_watcher, 0, sizeof(plugin_watcher));
-        plugin_watcher.port = get_local_port();
-        if (plugin_watcher.port == 0) {
-            LOGE("failed to assign a control port for plugin");
-        }
-#endif
-
-        LOGI("plugin \"%s\" enabled", plugin);
-    }
-
-    if (method == NULL) {
-        method = "chacha20-ietf-poly1305";
-    }
-
-    if (timeout == NULL) {
-        timeout = "60";
-    }
-
-#ifdef HAVE_SETRLIMIT
-    /*
-     * no need to check the return value here since we will show
-     * the user an error message if setrlimit(2) fails
-     */
-    if (nofile > 1024) {
-        if (verbose) {
-            LOGI("setting NOFILE to %d", nofile);
-        }
-        set_nofile(nofile);
-    }
-#endif
-
-    if (local_addr == NULL) {
-        if (is_ipv6only(remote_addr, remote_num, ipv6first)) {
-            local_addr = "::1";
-        } else {
-            local_addr = "127.0.0.1";
-        }
-    }
-
-    if (fast_open == 1) {
-#ifdef TCP_FASTOPEN
-        LOGI("using tcp fast open");
-#else
-        LOGE("tcp fast open is not supported by this environment");
-        fast_open = 0;
-#endif
-    }
-
-    USE_SYSLOG(argv[0], pid_flags);
-    if (pid_flags) {
-        daemonize(pid_path);
-    }
-
-    if (ipv6first) {
-        LOGI("resolving hostname to IPv6 address first");
-    }
-
-    // parse tunnel addr
-    parse_addr(tunnel_addr_str, &tunnel_addr);
-
-    if (tunnel_addr.port == NULL) {
-        FATAL("tunnel port is not defined");
-    }
-
-#ifdef __MINGW32__
-    // Listen on plugin control port
-    if (plugin != NULL && plugin_watcher.port != 0) {
-        SOCKET fd;
-        fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-        if (fd != INVALID_SOCKET) {
-            plugin_watcher.valid = 0;
-            do {
-                struct sockaddr_in addr;
-                memset(&addr, 0, sizeof(addr));
-                addr.sin_family      = AF_INET;
-                addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-                addr.sin_port        = htons(plugin_watcher.port);
-                if (bind(fd, (struct sockaddr *)&addr, sizeof(addr))) {
-                    LOGE("failed to bind plugin control port");
-                    break;
-                }
-                if (listen(fd, 1)) {
-                    LOGE("failed to listen on plugin control port");
-                    break;
-                }
-                plugin_watcher.fd = fd;
-                ev_io_init(&plugin_watcher.io, plugin_watcher_cb, fd, EV_READ);
-                ev_io_start(EV_DEFAULT, &plugin_watcher.io);
-                plugin_watcher.valid = 1;
-            } while (0);
-            if (!plugin_watcher.valid) {
-                closesocket(fd);
-                plugin_watcher.port = 0;
-            }
-        }
-    }
-#endif
-
-    if (plugin != NULL) {
-        int len          = 0;
-        size_t buf_size  = 256 * remote_num;
-        char *remote_str = ss_malloc(buf_size);
-
-        snprintf(remote_str, buf_size, "%s", remote_addr[0].host);
-        for (int i = 1; i < remote_num; i++) {
-            snprintf(remote_str + len, buf_size - len, "|%s", remote_addr[i].host);
-            len = strlen(remote_str);
-        }
-        int err = start_plugin(plugin, plugin_opts, remote_str,
-                               remote_port, plugin_host, plugin_port,
-#ifdef __MINGW32__
-                               plugin_watcher.port,
-#endif
-                               MODE_CLIENT);
-        if (err) {
-            ERROR("start_plugin");
-            FATAL("failed to start the plugin");
-        }
-    }
-
-#ifndef __MINGW32__
-    // ignore SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGABRT, SIG_IGN);
-#endif
-
-    ev_signal_init(&sigint_watcher, signal_cb, SIGINT);
-    ev_signal_init(&sigterm_watcher, signal_cb, SIGTERM);
-    ev_signal_start(EV_DEFAULT, &sigint_watcher);
-    ev_signal_start(EV_DEFAULT, &sigterm_watcher);
-#ifndef __MINGW32__
-    ev_signal_init(&sigchld_watcher, signal_cb, SIGCHLD);
-    ev_signal_start(EV_DEFAULT, &sigchld_watcher);
-#endif
-
-    // Setup keys
-    LOGI("initializing ciphers... %s", method);
-    crypto = crypto_init(password, key, method);
-    if (crypto == NULL)
-        FATAL("failed to initialize ciphers");
-
-    // Setup proxy context
-    struct listen_ctx listen_ctx;
-    memset(&listen_ctx, 0, sizeof(struct listen_ctx));
-    listen_ctx.tunnel_addr = tunnel_addr;
-    listen_ctx.remote_num  = remote_num;
-    listen_ctx.remote_addr = ss_malloc(sizeof(struct sockaddr *) * remote_num);
-    memset(listen_ctx.remote_addr, 0, sizeof(struct sockaddr *) * remote_num);
-    for (i = 0; i < remote_num; i++) {
-        char *host = remote_addr[i].host;
-        char *port = remote_addr[i].port == NULL ? remote_port : remote_addr[i].port;
-        if (plugin != NULL) {
-            host = plugin_host;
-            port = plugin_port;
-        }
-        struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
-        memset(storage, 0, sizeof(struct sockaddr_storage));
-        if (get_sockaddr(host, port, storage, 1, ipv6first) == -1) {
-            FATAL("failed to resolve the provided hostname");
-        }
-        listen_ctx.remote_addr[i] = (struct sockaddr *)storage;
-
-        if (plugin != NULL)
-            break;
-    }
-    listen_ctx.timeout = atoi(timeout);
-    listen_ctx.iface   = iface;
-    listen_ctx.mptcp   = mptcp;
-
-    LOGI("listening at %s:%s", local_addr, local_port);
-
-    struct ev_loop *loop = EV_DEFAULT;
-
-    if (mode != UDP_ONLY) {
-        // Setup socket
-        int listenfd;
-        listenfd = create_and_bind(local_addr, local_port);
-        if (listenfd == -1) {
-            FATAL("bind() error");
-        }
-        if (listen(listenfd, SOMAXCONN) == -1) {
-            FATAL("listen() error");
-        }
-        setnonblocking(listenfd);
-
-        listen_ctx.fd = listenfd;
-
-        ev_io_init(&listen_ctx.io, accept_cb, listenfd, EV_READ);
-        ev_io_start(loop, &listen_ctx.io);
-    }
-
-    // Setup UDP
-    if (mode != TCP_ONLY) {
-        LOGI("UDP relay enabled");
-        char *host                       = remote_addr[0].host;
-        char *port                       = remote_addr[0].port == NULL ? remote_port : remote_addr[0].port;
-        struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
-        memset(storage, 0, sizeof(struct sockaddr_storage));
-        if (get_sockaddr(host, port, storage, 1, ipv6first) == -1) {
-            FATAL("failed to resolve the provided hostname");
-        }
-        struct sockaddr *addr = (struct sockaddr *)storage;
-        init_udprelay(local_addr, local_port, addr, get_sockaddr_len(addr),
-                      tunnel_addr, mtu, crypto, listen_ctx.timeout, iface);
-    }
-
-    if (mode == UDP_ONLY) {
-        LOGI("TCP relay disabled");
-    }
-
-#ifndef __MINGW32__
-    // setuid
-    if (user != NULL && !run_as(user)) {
-        FATAL("failed to switch user");
-    }
-
-    if (geteuid() == 0) {
-        LOGI("running from root user");
-    }
-#endif
-
-    ev_run(loop, 0);
-
-    if (plugin != NULL) {
-        stop_plugin();
-    }
-
-    for (i = 0; i < remote_num; i++)
-        ss_free(listen_ctx.remote_addr[i]);
-    ss_free(listen_ctx.remote_addr);
-
-#ifdef __MINGW32__
-    if (plugin_watcher.valid) {
-        closesocket(plugin_watcher.fd);
-    }
-
-    winsock_cleanup();
-#endif
-
-    return ret_val;
-}
diff --git a/src/tunnel.h b/src/tunnel.h
deleted file mode 100644
index 4e9fbf8..0000000
--- a/src/tunnel.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * tunnel.h - Define tunnel's buffers and callbacks
- *
- * Copyright (C) 2013 - 2019, Max Lv <max.c.lv@gmail.com>
- *
- * This file is part of the shadowsocks-libev.
- *
- * shadowsocks-libev is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * shadowsocks-libev is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with shadowsocks-libev; see the file COPYING. If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef _TUNNEL_H
-#define _TUNNEL_H
-
-#ifdef HAVE_LIBEV_EV_H
-#include <libev/ev.h>
-#else
-#include <ev.h>
-#endif
-
-#ifdef __MINGW32__
-#include "winsock.h"
-#endif
-
-#include "crypto.h"
-#include "jconf.h"
-
-#include "common.h"
-
-typedef struct listen_ctx {
-    ev_io io;
-    ss_addr_t tunnel_addr;
-    char *iface;
-    int remote_num;
-    int timeout;
-    int fd;
-    int mptcp;
-    struct sockaddr **remote_addr;
-} listen_ctx_t;
-
-typedef struct server_ctx {
-    ev_io io;
-    int connected;
-    struct server *server;
-} server_ctx_t;
-
-typedef struct server {
-    int fd;
-
-    buffer_t *buf;
-    cipher_ctx_t *e_ctx;
-    cipher_ctx_t *d_ctx;
-    struct server_ctx *recv_ctx;
-    struct server_ctx *send_ctx;
-    struct remote *remote;
-    ss_addr_t destaddr;
-} server_t;
-
-typedef struct remote_ctx {
-    ev_io io;
-    ev_timer watcher;
-    int connected;
-    struct remote *remote;
-} remote_ctx_t;
-
-typedef struct remote {
-    int fd;
-#ifdef TCP_FASTOPEN_WINSOCK
-    OVERLAPPED olap;
-    int connect_ex_done;
-#endif
-    buffer_t *buf;
-    struct remote_ctx *recv_ctx;
-    struct remote_ctx *send_ctx;
-    struct server *server;
-    struct sockaddr *addr;
-    uint32_t counter;
-} remote_t;
-
-#endif // _TUNNEL_H
diff --git a/src/udprelay.c b/src/udprelay.c
index 49ce98a..578e024 100644
--- a/src/udprelay.c
+++ b/src/udprelay.c
@@ -40,7 +40,7 @@
 #include "config.h"
 #endif
 
-#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
+#if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H)
 #include <net/if.h>
 #include <sys/ioctl.h>
 #define SET_INTERFACE
@@ -53,18 +53,7 @@
 #include "cache.h"
 #include "udprelay.h"
 #include "winsock.h"
-
-#ifdef MODULE_REMOTE
-#define MAX_UDP_CONN_NUM 512
-#else
 #define MAX_UDP_CONN_NUM 256
-#endif
-
-#ifdef MODULE_REMOTE
-#ifdef MODULE_
-#error "MODULE_REMOTE and MODULE_LOCAL should not be both defined"
-#endif
-#endif
 
 #ifndef EAGAIN
 #define EAGAIN EWOULDBLOCK
@@ -79,30 +68,11 @@ static void remote_recv_cb(EV_P_ ev_io *w, int revents);
 static void remote_timeout_cb(EV_P_ ev_timer *watcher, int revents);
 
 static char *hash_key(const int af, const struct sockaddr_storage *addr);
-#ifdef MODULE_REMOTE
-static void resolv_free_cb(void *data);
-static void resolv_cb(struct sockaddr *addr, void *data);
-#endif
 static void close_and_free_remote(EV_P_ remote_ctx_t *ctx);
 static remote_ctx_t *new_remote(int fd, server_ctx_t *server_ctx);
 
-#ifdef __ANDROID__
-extern uint64_t tx;
-extern uint64_t rx;
-extern int vpn;
-extern void stat_update_cb();
-#endif
-
 extern int verbose;
 extern int reuse_port;
-#ifdef MODULE_REMOTE
-extern uint64_t tx;
-extern uint64_t rx;
-
-extern int is_bind_local_addr;
-extern struct sockaddr_storage local_addr_v4;
-extern struct sockaddr_storage local_addr_v6;
-#endif
 
 static int packet_size                               = DEFAULT_PACKET_SIZE;
 static int buf_size                                  = DEFAULT_PACKET_SIZE * 2;
@@ -111,7 +81,6 @@ static server_ctx_t *server_ctx_list[MAX_REMOTE_NUM] = { NULL };
 
 const char *s_port = NULL;
 
-#ifndef __MINGW32__
 static int
 setnonblocking(int fd)
 {
@@ -122,18 +91,6 @@ setnonblocking(int fd)
     return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
 }
 
-#endif
-
-#if defined(MODULE_REMOTE) && defined(SO_BROADCAST)
-static int
-set_broadcast(int socket_fd)
-{
-    int opt = 1;
-    return setsockopt(socket_fd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt));
-}
-
-#endif
-
 #ifdef SO_NOSIGPIPE
 static int
 set_nosigpipe(int socket_fd)
@@ -144,8 +101,6 @@ set_nosigpipe(int socket_fd)
 
 #endif
 
-#ifdef MODULE_REDIR
-
 #ifndef IP_TRANSPARENT
 #define IP_TRANSPARENT       19
 #endif
@@ -190,8 +145,6 @@ get_dstaddr(struct msghdr *msg, struct sockaddr_storage *dstaddr)
     return 1;
 }
 
-#endif
-
 #define HASH_KEY_LEN sizeof(struct sockaddr_storage) + sizeof(int)
 static char *
 hash_key(const int af, const struct sockaddr_storage *addr)
@@ -206,8 +159,6 @@ hash_key(const int af, const struct sockaddr_storage *addr)
     return key;
 }
 
-#if defined(MODULE_REDIR) || defined(MODULE_REMOTE)
-
 static int
 construct_udprelay_header(const struct sockaddr_storage *in_addr,
                           char *addr_header)
@@ -239,8 +190,6 @@ construct_udprelay_header(const struct sockaddr_storage *in_addr,
     return addr_header_len;
 }
 
-#endif
-
 static int
 parse_udprelay_header(const char *buf, const size_t buf_len,
                       char *host, char *port, struct sockaddr_storage *storage)
@@ -382,24 +331,10 @@ create_remote_socket(int ipv6)
             ERROR("[udp] cannot create socket");
             return -1;
         }
-#ifdef MODULE_REMOTE
-        if (is_bind_local_addr) {
-            if (local_addr_v6.ss_family == AF_INET6) {
-                if (bind_to_addr(&local_addr_v6, remote_sock) == -1) {
-                    ERROR("bind_to_addr");
-                    FATAL("[udp] cannot bind socket");
-                    return -1;
-                }
-            }
-        } else {
-#endif
         if (bind(remote_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
             FATAL("[udp] cannot bind socket");
             return -1;
         }
-#ifdef MODULE_REMOTE
-    }
-#endif
     } else {
         // Or else bind to IPv4
         struct sockaddr_in addr;
@@ -412,31 +347,15 @@ create_remote_socket(int ipv6)
             ERROR("[udp] cannot create socket");
             return -1;
         }
-#ifdef MODULE_REMOTE
-        if (is_bind_local_addr) {
-            if (local_addr_v4.ss_family == AF_INET) {
-                if (bind_to_addr(&local_addr_v4, remote_sock) == -1) {
-                    ERROR("bind_to_addr");
-                    FATAL("[udp] cannot bind socket");
-                    return -1;
-                }
-            }
-        } else {
-#endif
         if (bind(remote_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
             FATAL("[udp] cannot bind remote");
             return -1;
         }
-#ifdef MODULE_REMOTE
-    }
-#endif
     }
 
-#if defined(__linux__)
     // Disable fragmentation
     int val = IP_PMTUDISC_DO;
     setsockopt(remote_sock, IPPROTO_IP, IP_MTU_DISCOVER, &val, sizeof(val));
-#endif
 
     return remote_sock;
 }
@@ -523,7 +442,6 @@ create_server_socket(const char *host, const char *port)
 #endif
 #endif
 
-#ifdef MODULE_REDIR
         int sol    = rp->ai_family == AF_INET ? SOL_IP : SOL_IPV6;
         int flag_t = rp->ai_family == AF_INET ? IP_TRANSPARENT : IPV6_TRANSPARENT;
         int flag_r = rp->ai_family == AF_INET ? IP_RECVORIGDSTADDR : IPV6_RECVORIGDSTADDR;
@@ -536,7 +454,6 @@ create_server_socket(const char *host, const char *port)
         if (setsockopt(server_sock, sol, flag_r, &opt, sizeof(opt))) {
             FATAL("[udp] setsockopt IP_RECVORIGDSTADDR");
         }
-#endif
 
         s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);
         if (s == 0) {
@@ -552,11 +469,9 @@ create_server_socket(const char *host, const char *port)
 
     freeaddrinfo(result);
 
-#if defined(__linux__)
     // Disable fragmentation
     int val = IP_PMTUDISC_DO;
     setsockopt(server_sock, IPPROTO_IP, IP_MTU_DISCOVER, &val, sizeof(val));
-#endif
 
     return server_sock;
 }
@@ -591,33 +506,6 @@ new_server_ctx(int fd)
     return ctx;
 }
 
-#ifdef MODULE_REMOTE
-struct query_ctx *
-new_query_ctx(char *buf, size_t len)
-{
-    struct query_ctx *ctx = ss_malloc(sizeof(struct query_ctx));
-    memset(ctx, 0, sizeof(struct query_ctx));
-    ctx->buf = ss_malloc(sizeof(buffer_t));
-    balloc(ctx->buf, len);
-    memcpy(ctx->buf->data, buf, len);
-    ctx->buf->len = len;
-    return ctx;
-}
-
-void
-close_and_free_query(EV_P_ struct query_ctx *ctx)
-{
-    if (ctx != NULL) {
-        if (ctx->buf != NULL) {
-            bfree(ctx->buf);
-            ss_free(ctx->buf);
-        }
-        ss_free(ctx);
-    }
-}
-
-#endif
-
 void
 close_and_free_remote(EV_P_ remote_ctx_t *ctx)
 {
@@ -643,106 +531,6 @@ remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
     cache_remove(remote_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN);
 }
 
-#ifdef MODULE_REMOTE
-static void
-resolv_free_cb(void *data)
-{
-    struct query_ctx *ctx = (struct query_ctx *)data;
-    if (ctx->buf != NULL) {
-        bfree(ctx->buf);
-        ss_free(ctx->buf);
-    }
-    ss_free(ctx);
-}
-
-static void
-resolv_cb(struct sockaddr *addr, void *data)
-{
-    struct query_ctx *query_ctx = (struct query_ctx *)data;
-    struct ev_loop *loop        = query_ctx->server_ctx->loop;
-
-    if (addr == NULL) {
-        LOGE("[udp] unable to resolve");
-    } else {
-        remote_ctx_t *remote_ctx = query_ctx->remote_ctx;
-        int cache_hit            = 0;
-
-        // Lookup in the conn cache
-        if (remote_ctx == NULL) {
-            char *key = hash_key(AF_UNSPEC, &query_ctx->src_addr);
-            cache_lookup(query_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN, (void *)&remote_ctx);
-        }
-
-        if (remote_ctx == NULL) {
-            int remotefd = create_remote_socket(addr->sa_family == AF_INET6);
-            if (remotefd != -1) {
-                setnonblocking(remotefd);
-#ifdef SO_BROADCAST
-                set_broadcast(remotefd);
-#endif
-#ifdef SO_NOSIGPIPE
-                set_nosigpipe(remotefd);
-#endif
-#ifdef IP_TOS
-                // Set QoS flag
-                int tos   = 46 << 2;
-                int rc = setsockopt(remotefd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
-                if (rc < 0 && errno != ENOPROTOOPT) {
-                    LOGE("setting ipv4 dscp failed: %d", errno);
-                }
-#ifdef IPV6_TCLASS
-                rc = setsockopt(remotefd, IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos));
-                if (rc < 0 && errno != ENOPROTOOPT) {
-                    LOGE("setting ipv6 dscp failed: %d", errno);
-                }
-#endif
-#endif
-#ifdef SET_INTERFACE
-                if (query_ctx->server_ctx->iface) {
-                    if (setinterface(remotefd, query_ctx->server_ctx->iface) == -1)
-                        ERROR("setinterface");
-                }
-#endif
-                remote_ctx             = new_remote(remotefd, query_ctx->server_ctx);
-                remote_ctx->src_addr   = query_ctx->src_addr;
-                remote_ctx->server_ctx = query_ctx->server_ctx;
-            } else {
-                ERROR("[udp] bind() error");
-            }
-        } else {
-            cache_hit = 1;
-        }
-
-        if (remote_ctx != NULL) {
-            if (addr->sa_family == AF_INET)
-                memcpy(&remote_ctx->dst_addr, addr, sizeof(struct sockaddr_in));
-            else
-                memcpy(&remote_ctx->dst_addr, addr, sizeof(struct sockaddr_in6));
-
-            size_t addr_len = get_sockaddr_len(addr);
-            int s           = sendto(remote_ctx->fd, query_ctx->buf->data, query_ctx->buf->len,
-                                     0, addr, addr_len);
-
-            if (s == -1) {
-                ERROR("[udp] sendto_remote");
-                if (!cache_hit) {
-                    close_and_free_remote(EV_A_ remote_ctx);
-                }
-            } else {
-                if (!cache_hit) {
-                    // Add to conn cache
-                    char *key = hash_key(AF_UNSPEC, &remote_ctx->src_addr);
-                    cache_insert(query_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
-                    ev_io_start(EV_A_ & remote_ctx->io);
-                    ev_timer_start(EV_A_ & remote_ctx->watcher);
-                }
-            }
-        }
-    }
-}
-
-#endif
-
 void convert_ipv4_mapped_ipv6(struct sockaddr_storage* addr) {
     if (addr->ss_family == AF_INET) {
         struct sockaddr_in* ipv4_addr = (struct sockaddr_in*)addr;
@@ -807,7 +595,6 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
 
     buf->len = r;
 
-#ifdef MODULE_LOCAL
     int err = server_ctx->crypto->decrypt_all(buf, server_ctx->crypto->cipher, buf_size);
     if (err) {
         LOGE("failed to handshake with %s: %s",
@@ -816,7 +603,6 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
         goto CLEAN_UP;
     }
 
-#ifdef MODULE_REDIR
     struct sockaddr_storage dst_addr;
     memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
     int len = parse_udprelay_header(buf->data, buf->len, NULL, NULL, &dst_addr);
@@ -825,9 +611,6 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
         LOGI("[udp] ss-redir does not support domain name");
         goto CLEAN_UP;
     }
-#else
-    int len = parse_udprelay_header(buf->data, buf->len, NULL, NULL, NULL);
-#endif
 
     if (len == 0) {
         // error when parsing header
@@ -835,45 +618,9 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
         goto CLEAN_UP;
     }
 
-#if defined(MODULE_TUNNEL) || defined(MODULE_REDIR)
     // Construct packet
     buf->len -= len;
     memmove(buf->data, buf->data + len, buf->len);
-#else
-#ifdef __ANDROID__
-    rx += buf->len;
-    stat_update_cb();
-#endif
-    // Construct packet
-    brealloc(buf, buf->len + 3, buf_size);
-    memmove(buf->data + 3, buf->data, buf->len);
-    memset(buf->data, 0, 3);
-    buf->len += 3;
-#endif
-
-#endif
-
-#ifdef MODULE_REMOTE
-
-    rx += buf->len;
-
-    // Reconstruct UDP response header
-    char addr_header[MAX_ADDR_HEADER_SIZE];
-    int addr_header_len = construct_udprelay_header(&src_addr, addr_header);
-
-    // Construct packet
-    brealloc(buf, buf->len + addr_header_len, buf_size);
-    memmove(buf->data + addr_header_len, buf->data, buf->len);
-    memcpy(buf->data, addr_header, addr_header_len);
-    buf->len += addr_header_len;
-
-    int err = server_ctx->crypto->encrypt_all(buf, server_ctx->crypto->cipher, buf_size);
-    if (err) {
-        // drop the packet silently
-        goto CLEAN_UP;
-    }
-
-#endif
 
     if (buf->len > packet_size) {
         if (verbose) {
@@ -881,8 +628,6 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
         }
     }
 
-
-#ifdef MODULE_REDIR
     convert_ipv4_mapped_ipv6(&dst_addr);
 
     size_t remote_dst_addr_len = get_sockaddr_len((struct sockaddr *)&dst_addr);
@@ -943,18 +688,6 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
     }
     close(src_fd);
 
-#else
-    size_t remote_src_addr_len = get_sockaddr_len((struct sockaddr *)&remote_ctx->src_addr);
-
-    int s = sendto(server_ctx->fd, buf->data, buf->len, 0,
-                   (struct sockaddr *)&remote_ctx->src_addr, remote_src_addr_len);
-    if (s == -1 && !(errno == EAGAIN || errno == EWOULDBLOCK)) {
-        ERROR("[udp] remote_recv_sendto");
-        goto CLEAN_UP;
-    }
-
-#endif
-
     // handle the UDP packet successfully,
     // triger the timer
     ev_timer_again(EV_A_ & remote_ctx->watcher);
@@ -965,6 +698,7 @@ CLEAN_UP:
     ss_free(buf);
 }
 
+
 static void
 server_recv_cb(EV_P_ ev_io *w, int revents)
 {
@@ -978,7 +712,6 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
     socklen_t src_addr_len = sizeof(struct sockaddr_storage);
     unsigned int offset    = 0;
 
-#ifdef MODULE_REDIR
     char control_buffer[64] = { 0 };
     struct msghdr msg;
     memset(&msg, 0, sizeof(struct msghdr));
@@ -1013,51 +746,11 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
     }
 
     src_addr_len = msg.msg_namelen;
-#else
-    ssize_t r;
-    r = recvfrom(server_ctx->fd, buf->data, buf_size,
-                 0, (struct sockaddr *)&src_addr, &src_addr_len);
-
-    if (r == -1) {
-        // error on recv
-        // simply drop that packet
-        ERROR("[udp] server_recv_recvfrom");
-        goto CLEAN_UP;
-    } else if (r > packet_size) {
-        if (verbose) {
-            LOGI("[udp] server_recv_recvfrom fragmentation, MTU at least be: " SSIZE_FMT, r + PACKET_HEADER_SIZE);
-        }
-    }
-
-    buf->len = r;
-#endif
 
     if (verbose) {
         LOGI("[udp] server receive a packet");
     }
 
-#ifdef MODULE_REMOTE
-    tx += buf->len;
-
-    int err = server_ctx->crypto->decrypt_all(buf, server_ctx->crypto->cipher, buf_size);
-    if (err) {
-        LOGE("failed to handshake with %s: %s",
-                get_addr_str((struct sockaddr *)&src_addr, false), "suspicious UDP packet");
-        // drop the packet silently
-        goto CLEAN_UP;
-    }
-#endif
-
-#ifdef MODULE_LOCAL
-#if !defined(MODULE_TUNNEL) && !defined(MODULE_REDIR)
-#ifdef __ANDROID__
-    tx += buf->len;
-#endif
-    uint8_t frag = *(uint8_t *)(buf->data + 2);
-    offset += 3;
-#endif
-#endif
-
     /*
      *
      * SOCKS5 UDP Request
@@ -1097,7 +790,6 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
      *
      */
 
-#ifdef MODULE_REDIR
     char addr_header[MAX_ADDR_HEADER_SIZE] = { 0 };
     int addr_header_len                    = construct_udprelay_header(&dst_addr, addr_header);
 
@@ -1112,83 +804,7 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
     memcpy(buf->data, addr_header, addr_header_len);
     buf->len += addr_header_len;
 
-#elif MODULE_TUNNEL
-
-    char addr_header[MAX_ADDR_HEADER_SIZE] = { 0 };
-    char *host                             = server_ctx->tunnel_addr.host;
-    char *port                             = server_ctx->tunnel_addr.port;
-    uint16_t port_num                      = (uint16_t)atoi(port);
-    uint16_t port_net_num                  = htons(port_num);
-    int addr_header_len                    = 0;
-
-    struct cork_ip ip;
-    if (cork_ip_init(&ip, host) != -1) {
-        if (ip.version == 4) {
-            // send as IPv4
-            struct in_addr host_addr;
-            memset(&host_addr, 0, sizeof(struct in_addr));
-            int host_len = sizeof(struct in_addr);
-
-            if (inet_pton(AF_INET, host, &host_addr) == -1) {
-                FATAL("IP parser error");
-            }
-            addr_header[addr_header_len++] = 1;
-            memcpy(addr_header + addr_header_len, &host_addr, host_len);
-            addr_header_len += host_len;
-        } else if (ip.version == 6) {
-            // send as IPv6
-            struct in6_addr host_addr;
-            memset(&host_addr, 0, sizeof(struct in6_addr));
-            int host_len = sizeof(struct in6_addr);
-
-            if (inet_pton(AF_INET6, host, &host_addr) == -1) {
-                FATAL("IP parser error");
-            }
-            addr_header[addr_header_len++] = 4;
-            memcpy(addr_header + addr_header_len, &host_addr, host_len);
-            addr_header_len += host_len;
-        } else {
-            FATAL("IP parser error");
-        }
-    } else {
-        // send as domain
-        int host_len = strlen(host);
-
-        addr_header[addr_header_len++] = 3;
-        addr_header[addr_header_len++] = host_len;
-        memcpy(addr_header + addr_header_len, host, host_len);
-        addr_header_len += host_len;
-    }
-    memcpy(addr_header + addr_header_len, &port_net_num, 2);
-    addr_header_len += 2;
-
-    // reconstruct the buffer
-    brealloc(buf, buf->len + addr_header_len, buf_size);
-    memmove(buf->data + addr_header_len, buf->data, buf->len);
-    memcpy(buf->data, addr_header, addr_header_len);
-    buf->len += addr_header_len;
-
-#else
-
-    char host[MAX_HOSTNAME_LEN] = { 0 };
-    char port[MAX_PORT_STR_LEN] = { 0 };
-    struct sockaddr_storage dst_addr;
-    memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
-
-    int addr_header_len = parse_udprelay_header(buf->data + offset, buf->len - offset,
-                                                host, port, &dst_addr);
-    if (addr_header_len == 0) {
-        // error in parse header
-        goto CLEAN_UP;
-    }
-
-#endif
-
-#ifdef MODULE_LOCAL
     char *key = hash_key(server_ctx->remote_addr->sa_family, &src_addr);
-#else
-    char *key = hash_key(dst_addr.ss_family, &src_addr);
-#endif
 
     struct cache *conn_cache = server_ctx->conn_cache;
 
@@ -1208,41 +824,22 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
 
     if (remote_ctx == NULL) {
         if (verbose) {
-#ifdef MODULE_REDIR
             char src[SS_ADDRSTRLEN];
             char dst[SS_ADDRSTRLEN];
             strcpy(src, get_addr_str((struct sockaddr *)&src_addr, true));
             strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr, true));
             LOGI("[%s] [udp] cache miss: %s <-> %s", s_port, dst, src);
-#else
-            LOGI("[%s] [udp] cache miss: %s:%s <-> %s", s_port, host, port,
-                 get_addr_str((struct sockaddr *)&src_addr, true));
-#endif
         }
     } else {
         if (verbose) {
-#ifdef MODULE_REDIR
             char src[SS_ADDRSTRLEN];
             char dst[SS_ADDRSTRLEN];
             strcpy(src, get_addr_str((struct sockaddr *)&src_addr, true));
             strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr, true));
             LOGI("[%s] [udp] cache hit: %s <-> %s", s_port, dst, src);
-#else
-            LOGI("[%s] [udp] cache hit: %s:%s <-> %s", s_port, host, port,
-                 get_addr_str((struct sockaddr *)&src_addr, true));
-#endif
         }
     }
 
-#ifdef MODULE_LOCAL
-
-#if !defined(MODULE_TUNNEL) && !defined(MODULE_REDIR)
-    if (frag) {
-        LOGE("[udp] drop a message since frag is not 0, but %d", frag);
-        goto CLEAN_UP;
-    }
-#endif
-
     const struct sockaddr *remote_addr = server_ctx->remote_addr;
     const int remote_addr_len          = server_ctx->remote_addr_len;
 
@@ -1279,16 +876,6 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
         }
 #endif
 
-#ifdef __ANDROID__
-        if (vpn) {
-            if (protect_socket(remotefd) == -1) {
-                ERROR("protect_socket");
-                close(remotefd);
-                goto CLEAN_UP;
-            }
-        }
-#endif
-
         // Init remote_ctx
         remote_ctx           = new_remote(remotefd, server_ctx);
         remote_ctx->src_addr = src_addr;
@@ -1326,105 +913,6 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
         ERROR("[udp] server_recv_sendto");
     }
 
-#else
-
-    int cache_hit  = 0;
-    int need_query = 0;
-
-    char *addr_header = buf->data + offset;
-
-    if (buf->len - addr_header_len > packet_size) {
-        if (verbose) {
-            LOGI("[udp] server_recv_sendto fragmentation, MTU at least be: " SSIZE_FMT,
-                 buf->len - addr_header_len + PACKET_HEADER_SIZE);
-        }
-    }
-
-    if (remote_ctx != NULL) {
-        cache_hit = 1;
-        if (dst_addr.ss_family != AF_INET && dst_addr.ss_family != AF_INET6) {
-            need_query = 1;
-        }
-    } else {
-        if (dst_addr.ss_family == AF_INET || dst_addr.ss_family == AF_INET6) {
-            int remotefd = create_remote_socket(dst_addr.ss_family == AF_INET6);
-            if (remotefd != -1) {
-                setnonblocking(remotefd);
-#ifdef SO_BROADCAST
-                set_broadcast(remotefd);
-#endif
-#ifdef SO_NOSIGPIPE
-                set_nosigpipe(remotefd);
-#endif
-#ifdef IP_TOS
-                // Set QoS flag
-                int tos   = 46 << 2;
-                int rc = setsockopt(remotefd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
-                if (rc < 0 && errno != ENOPROTOOPT) {
-                    LOGE("setting ipv4 dscp failed: %d", errno);
-                }
-#ifdef IPV6_TCLASS
-                rc = setsockopt(remotefd, IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos));
-                if (rc < 0 && errno != ENOPROTOOPT) {
-                    LOGE("setting ipv6 dscp failed: %d", errno);
-                }
-#endif
-#endif
-#ifdef SET_INTERFACE
-                if (server_ctx->iface) {
-                    if (setinterface(remotefd, server_ctx->iface) == -1)
-                        ERROR("setinterface");
-                }
-#endif
-                remote_ctx             = new_remote(remotefd, server_ctx);
-                remote_ctx->src_addr   = src_addr;
-                remote_ctx->server_ctx = server_ctx;
-                memcpy(&remote_ctx->dst_addr, &dst_addr, sizeof(struct sockaddr_storage));
-            } else {
-                ERROR("[udp] bind() error");
-                goto CLEAN_UP;
-            }
-        }
-    }
-
-    if (remote_ctx != NULL && !need_query) {
-        size_t addr_len = get_sockaddr_len((struct sockaddr *)&dst_addr);
-        int s           = sendto(remote_ctx->fd, buf->data + addr_header_len,
-                                 buf->len - addr_header_len, 0,
-                                 (struct sockaddr *)&dst_addr, addr_len);
-
-        if (s == -1) {
-            ERROR("[udp] sendto_remote");
-            if (!cache_hit) {
-                close_and_free_remote(EV_A_ remote_ctx);
-            }
-        } else {
-            if (!cache_hit) {
-                // Add to conn cache
-                remote_ctx->af = dst_addr.ss_family;
-                char *key = hash_key(remote_ctx->af, &remote_ctx->src_addr);
-                cache_insert(server_ctx->conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
-
-                ev_io_start(EV_A_ & remote_ctx->io);
-                ev_timer_start(EV_A_ & remote_ctx->watcher);
-            }
-        }
-    } else {
-        struct query_ctx *query_ctx = new_query_ctx(buf->data + addr_header_len,
-                                                    buf->len - addr_header_len);
-        query_ctx->server_ctx      = server_ctx;
-        query_ctx->addr_header_len = addr_header_len;
-        query_ctx->src_addr        = src_addr;
-        memcpy(query_ctx->addr_header, addr_header, addr_header_len);
-
-        if (need_query) {
-            query_ctx->remote_ctx = remote_ctx;
-        }
-
-        resolv_start(host, htons(atoi(port)), resolv_cb, resolv_free_cb, query_ctx);
-    }
-#endif
-
 CLEAN_UP:
     bfree(buf);
     ss_free(buf);
@@ -1443,12 +931,7 @@ free_cb(void *key, void *element)
 
 int
 init_udprelay(const char *server_host, const char *server_port,
-#ifdef MODULE_LOCAL
               const struct sockaddr *remote_addr, const int remote_addr_len,
-#ifdef MODULE_TUNNEL
-              const ss_addr_t tunnel_addr,
-#endif
-#endif
               int mtu, crypto_t *crypto, int timeout, const char *iface)
 {
     s_port = server_port;
@@ -1476,20 +959,12 @@ init_udprelay(const char *server_host, const char *server_port,
     cache_create(&conn_cache, MAX_UDP_CONN_NUM, free_cb);
 
     server_ctx_t *server_ctx = new_server_ctx(serverfd);
-#ifdef MODULE_REMOTE
-    server_ctx->loop = loop;
-#endif
     server_ctx->timeout    = max(timeout, MIN_UDP_TIMEOUT);
     server_ctx->crypto     = crypto;
     server_ctx->iface      = iface;
     server_ctx->conn_cache = conn_cache;
-#ifdef MODULE_LOCAL
     server_ctx->remote_addr     = remote_addr;
     server_ctx->remote_addr_len = remote_addr_len;
-#ifdef MODULE_TUNNEL
-    server_ctx->tunnel_addr = tunnel_addr;
-#endif
-#endif
 
     ev_io_start(loop, &server_ctx->io);
 
diff --git a/src/udprelay.h b/src/udprelay.h
index 7242491..132c9cc 100644
--- a/src/udprelay.h
+++ b/src/udprelay.h
@@ -34,10 +34,6 @@
 #include "crypto.h"
 #include "jconf.h"
 
-#ifdef MODULE_REMOTE
-#include "resolv.h"
-#endif
-
 #include "cache.h"
 
 #include "common.h"
@@ -55,38 +51,16 @@ typedef struct server_ctx {
     int timeout;
     const char *iface;
     struct cache *conn_cache;
-#ifdef MODULE_LOCAL
     const struct sockaddr *remote_addr;
     int remote_addr_len;
-#ifdef MODULE_TUNNEL
-    ss_addr_t tunnel_addr;
-#endif
-#endif
-#ifdef MODULE_REMOTE
-    struct ev_loop *loop;
-#endif
 } server_ctx_t;
 
-#ifdef MODULE_REMOTE
-typedef struct query_ctx {
-    struct sockaddr_storage src_addr;
-    buffer_t *buf;
-    int addr_header_len;
-    char addr_header[MAX_ADDR_HEADER_SIZE];
-    struct server_ctx *server_ctx;
-    struct remote_ctx *remote_ctx;
-} query_ctx_t;
-#endif
-
 typedef struct remote_ctx {
     ev_io io;
     ev_timer watcher;
     int af;
     int fd;
     struct sockaddr_storage src_addr;
-#ifdef MODULE_REMOTE
-    struct sockaddr_storage dst_addr;
-#endif
     struct server_ctx *server_ctx;
 } remote_ctx_t;
 
diff --git a/src/utils.c b/src/utils.c
index d3ff2ab..553e1ac 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -27,14 +27,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
-#ifndef __MINGW32__
 #include <unistd.h>
 #include <errno.h>
 #include <pwd.h>
 #include <grp.h>
-#else
-#include <malloc.h>
-#endif
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -60,7 +56,6 @@ FILE *logfile;
 int use_syslog = 0;
 #endif
 
-#ifndef __MINGW32__
 void
 ERROR(const char *s)
 {
@@ -68,8 +63,6 @@ ERROR(const char *s)
     LOGE("%s: %s", s, msg);
 }
 
-#endif
-
 int use_tty = 1;
 
 char *
@@ -110,7 +103,6 @@ ss_isnumeric(const char *s)
 int
 run_as(const char *user)
 {
-#ifndef __MINGW32__
     if (user[0]) {
         /* Convert user to a long integer if it is a non-negative number.
          * -1 means it is a user name. */
@@ -204,9 +196,6 @@ run_as(const char *user)
         }
 #endif
     }
-#else
-    LOGE("run_as(): not implemented in MinGW port");
-#endif
 
     return 1;
 }
@@ -290,17 +279,7 @@ usage()
     printf(
         "  maintained by Max Lv <max.c.lv@gmail.com> and Linus Yang <laokongzi@gmail.com>\n\n");
     printf("  usage:\n\n");
-#ifdef MODULE_LOCAL
-    printf("    ss-local\n");
-#elif MODULE_REMOTE
-    printf("    ss-server\n");
-#elif MODULE_TUNNEL
-    printf("    ss-tunnel\n");
-#elif MODULE_REDIR
     printf("    ss-redir\n");
-#elif MODULE_MANAGER
-    printf("    ss-manager\n");
-#endif
     printf("\n");
     printf(
         "       -s <server_host>           Host name or IP address of your remote server.\n");
@@ -344,49 +323,25 @@ usage()
 #ifdef HAVE_SETRLIMIT
     printf(
         "       [-n <number>]              Max number of open files.\n");
-#endif
-#ifndef MODULE_REDIR
-    printf(
-        "       [-i <interface>]           Network interface to bind.\n");
 #endif
     printf(
         "       [-b <local_address>]       Local address to bind.\n");
     printf("\n");
     printf(
         "       [-u]                       Enable UDP relay.\n");
-#ifdef MODULE_REDIR
     printf(
         "                                  TPROXY is required in redir mode.\n");
-#endif
     printf(
         "       [-U]                       Enable UDP relay and disable TCP relay.\n");
-#ifdef MODULE_REDIR
     printf(
         "       [-T]                       Use tproxy instead of redirect (for tcp).\n");
-#endif
-#ifdef MODULE_REMOTE
-    printf(
-        "       [-6]                       Resovle hostname to IPv6 address first.\n");
-#endif
     printf("\n");
-#ifdef MODULE_TUNNEL
-    printf(
-        "       [-L <addr>:<port>]         Destination server address and port\n");
-    printf(
-        "                                  for local port forwarding.\n");
-#endif
-#ifdef MODULE_REMOTE
-    printf(
-        "       [-d <addr>]                Name servers for internal DNS resolver.\n");
-#endif
     printf(
         "       [--reuse-port]             Enable port reuse.\n");
-#if defined(MODULE_REMOTE) || defined(MODULE_LOCAL) || defined(MODULE_REDIR)
     printf(
         "       [--fast-open]              Enable TCP fast open.\n");
     printf(
         "                                  with Linux kernel > 3.7.0.\n");
-#endif
     printf(
         "       [--tcp-incoming-sndbuf]    Size of the incoming connection TCP send buffer.\n");
     printf(
@@ -395,38 +350,14 @@ usage()
         "       [--tcp-outgoing-sndbuf]    Size of the outgoing connection TCP send buffer.\n");
     printf(
         "       [--tcp-outgoing-rcvbuf]    Size of the outgoing connection TCP receive buffer.\n");
-#if defined(MODULE_REMOTE) || defined(MODULE_LOCAL)
-    printf(
-        "       [--acl <acl_file>]         Path to ACL (Access Control List).\n");
-#endif
-#if defined(MODULE_REMOTE) || defined(MODULE_MANAGER)
-    printf(
-        "       [--manager-address <addr>] UNIX domain socket address.\n");
-#endif
-#ifdef MODULE_MANAGER
-    printf(
-        "       [--executable <path>]      Path to the executable of ss-server.\n");
-    printf(
-        "       [-D <path>]                Path to the working directory of ss-manager.\n");
-#endif
     printf(
         "       [--mtu <MTU>]              MTU of your network interface.\n");
-#ifdef __linux__
     printf(
         "       [--mptcp]                  Enable Multipath TCP on MPTCP Kernel.\n");
-#ifdef USE_NFTABLES
-    printf(
-        "       [--nftables-sets <sets>]   Add malicious IP into nftables sets.\n");
-    printf(
-        "                                  sets spec: [<table1>:]<set1>[,[<table2>:]<set2>...]\n");
-#endif
-#endif
-#ifndef MODULE_MANAGER
     printf(
         "       [--no-delay]               Enable TCP_NODELAY.\n");
     printf(
         "       [--key <key_in_base64>]    Key of your remote server.\n");
-#endif
     printf(
         "       [--plugin <name>]          Enable SIP003 plugin. (Experimental)\n");
     printf(
@@ -442,7 +373,6 @@ usage()
 void
 daemonize(const char *path)
 {
-#ifndef __MINGW32__
     /* Our process ID and Session ID */
     pid_t pid, sid;
 
@@ -496,9 +426,6 @@ daemonize(const char *path)
 
     /* Close the standard file descriptors */
     close(STDIN_FILENO);
-#else
-    LOGE("daemonize(): not implemented in MinGW port");
-#endif
 }
 
 #ifdef HAVE_SETRLIMIT
@@ -533,7 +460,6 @@ set_nofile(int nofile)
 char *
 get_default_conf(void)
 {
-#ifndef __MINGW32__
     static char sysconf[] = "/etc/shadowsocks-libev/config.json";
     static char *userconf = NULL;
     static int buf_size   = 0;
@@ -566,9 +492,6 @@ get_default_conf(void)
     // If not, fall back to the system-wide config.
     free(userconf);
     return sysconf;
-#else
-    return "config.json";
-#endif
 }
 
 uint16_t
-- 
2.37.1 (Apple Git-137.1)

