From 69f8ac3f994d842236b2f7c5ff26a266dc3eadaa Mon Sep 17 00:00:00 2001
From: zhenglixin <lixin.zhenglx@gmail.com>
Date: Tue, 23 Sep 2025 22:11:14 +0800
Subject: [PATCH 4/6] probe remote address

---
 src/CMakeLists.txt |   1 +
 src/Makefile.am    |   3 +-
 src/common.h       |  10 +-
 src/jconf.c        |  24 +-
 src/jconf.h        |   6 +-
 src/netutils.c     | 163 ++++++++++
 src/netutils.h     |   4 +
 src/probe.c        | 324 ++++++++++++++++++++
 src/probe.h        |  32 ++
 src/redir.c        | 502 ++++++++++++++++++++-----------
 src/redir.h        |  24 +-
 src/stream.c       |   1 -
 src/udprelay.c     | 728 +++++++++++++++++++--------------------------
 src/udprelay.h     |  16 +-
 src/utils.c        |  29 ++
 src/utils.h        |   2 +
 16 files changed, 1251 insertions(+), 618 deletions(-)
 create mode 100644 src/probe.c
 create mode 100644 src/probe.h

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 65f44fb..eb76252 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -25,6 +25,7 @@ set(SS_SHARED_SOURCES
 set(SS_REDIR_SOURCE
         ${SS_SHARED_SOURCES}
         udprelay.c
+        probe.c
         cache.c
         redir.c
         ${SS_CRYPTO_SOURCE}
diff --git a/src/Makefile.am b/src/Makefile.am
index 995f1cd..1d2a6e6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -34,6 +34,7 @@ ss_redir_SOURCES = utils.c \
                    netutils.c \
                    cache.c \
                    udprelay.c \
+                   probe.c \
                    redir.c \
                    $(crypto_src) \
                    $(plugin_src)
@@ -44,4 +45,4 @@ ss_redir_LDADD += -lcares
 
 noinst_HEADERS = crypto.h stream.h aead.h json.h netutils.h redir.h uthash.h \
                  cache.h plugin.h utils.h base64.h ppbloom.h \
-                 common.h jconf.h udprelay.h
+                 common.h jconf.h udprelay.h probe.h
diff --git a/src/common.h b/src/common.h
index d45d773..96d6d42 100644
--- a/src/common.h
+++ b/src/common.h
@@ -29,8 +29,9 @@
 #include "crypto.h"
 
 int init_udprelay(const char *server_host, const char *server_port,
-                  const struct sockaddr *remote_addr, const int remote_addr_len,
-                  int mtu, crypto_t *crypto, int timeout, const char *iface, int fwmark);
+                  int remote_num, struct sockaddr **remote_addr, int mtu,
+                  crypto_t *crypto, int timeout, const char *iface, int fwmark,
+                  volatile bool *remote_status);
 
 void free_udprelay(void);
 
@@ -58,6 +59,11 @@ enum {
     GETOPT_VAL_TCP_OUTGOING_SNDBUF,
     GETOPT_VAL_TCP_OUTGOING_RCVBUF,
     GETOPT_VAL_FWMARK,
+    GETOPT_VAL_PROBE_INTERVAL,
+    GETOPT_VAL_PROBE_TIMEOUT,
+    GETOPT_VAL_PROBE_UP_COUNT,
+    GETOPT_VAL_PROBE_DOWN_COUNT,
+    GETOPT_VAL_PROBE_DOMAIN,
 };
 
 #endif // _COMMON_H
diff --git a/src/jconf.c b/src/jconf.c
index e72bc8b..1d3a77b 100644
--- a/src/jconf.c
+++ b/src/jconf.c
@@ -318,8 +318,6 @@ read_jconf(const char *file)
                         }
                     }
                 }
-            } else if (strcmp(name, "tunnel_address") == 0) {
-                conf.tunnel_address = to_string(value);
             } else if (strcmp(name, "mode") == 0) {
                 char *mode_str = to_string(value);
 
@@ -371,6 +369,28 @@ read_jconf(const char *file)
                     value, json_integer,
                     "invalid config file: option 'fwmark' must be an integer");
                 conf.fwmark = value->u.integer;
+            } else if (strcmp(name, "probe_interval") == 0) {
+                check_json_value_type(
+                    value, json_integer,
+                    "invalid config file: option 'probe_interval' must be an integer");
+                conf.probe_interval = value->u.integer;
+            } else if (strcmp(name, "probe_timeout") == 0) {
+                check_json_value_type(
+                    value, json_integer,
+                    "invalid config file: option 'probe_timeout' must be an integer");
+                conf.probe_timeout = value->u.integer;
+            } else if (strcmp(name, "probe_up_count") == 0) {
+                check_json_value_type(
+                    value, json_integer,
+                    "invalid config file: option 'probe_up_count' must be an integer");
+                conf.probe_up_count = value->u.integer;
+            } else if (strcmp(name, "probe_down_count") == 0) {
+                check_json_value_type(
+                    value, json_integer,
+                    "invalid config file: option 'probe_down_count' must be an integer");
+                conf.probe_down_count = value->u.integer;
+            } else if (strcmp(name, "probe_domain") == 0) {
+                conf.probe_domain = to_string(value);
             } else if (strcmp(name, "acl") == 0) {
                 conf.acl = to_string(value);
             } else if (strcmp(name, "manager_address") == 0) {
diff --git a/src/jconf.h b/src/jconf.h
index 1955536..57674d9 100644
--- a/src/jconf.h
+++ b/src/jconf.h
@@ -80,7 +80,6 @@ typedef struct {
     char *nameserver;
     int dscp_num;
     ss_dscp_t dscp[MAX_DSCP_NUM];
-    char *tunnel_address;
     int mode;
     int mtu;
     int mptcp;
@@ -91,6 +90,11 @@ typedef struct {
     char *acl;
     char *manager_address;
     int fwmark;
+    int probe_interval;
+    int probe_timeout;
+    int probe_up_count;
+    int probe_down_count;
+    char *probe_domain;
 } jconf_t;
 
 jconf_t *read_jconf(const char *file);
diff --git a/src/netutils.c b/src/netutils.c
index 7b32805..af41624 100644
--- a/src/netutils.c
+++ b/src/netutils.c
@@ -41,6 +41,7 @@
 
 #include "netutils.h"
 #include "utils.h"
+#include "crypto.h"
 
 #ifndef SO_REUSEPORT
 #define SO_REUSEPORT 15
@@ -123,6 +124,168 @@ bind_to_addr(struct sockaddr_storage *storage,
     return -1;
 }
 
+int
+construct_udprelay_header(const struct sockaddr_storage *in_addr,
+                          char *addr_header)
+{
+    int addr_header_len = 0;
+
+    if (in_addr->ss_family == AF_INET) {
+        struct sockaddr_in *addr = (struct sockaddr_in *)in_addr;
+        size_t addr_len          = sizeof(struct in_addr);
+
+        addr_header[addr_header_len++] = 1;
+        memcpy(addr_header + addr_header_len, &addr->sin_addr, addr_len);
+        addr_header_len += addr_len;
+        memcpy(addr_header + addr_header_len, &addr->sin_port, 2);
+        addr_header_len += 2;
+    } else if (in_addr->ss_family == AF_INET6) {
+        struct sockaddr_in6 *addr = (struct sockaddr_in6 *)in_addr;
+        size_t addr_len           = sizeof(struct in6_addr);
+
+        addr_header[addr_header_len++] = 4;
+        memcpy(addr_header + addr_header_len, &addr->sin6_addr, addr_len);
+        addr_header_len += addr_len;
+        memcpy(addr_header + addr_header_len, &addr->sin6_port, 2);
+        addr_header_len += 2;
+    } else {
+        return 0;
+    }
+
+    return addr_header_len;
+}
+
+int
+parse_udprelay_header(const char *buf, const size_t buf_len,
+                      char *host, char *port, struct sockaddr_storage *storage)
+{
+    if (buf == NULL || buf_len == 0) return 0;
+
+    const uint8_t atyp = *(const uint8_t *)buf;
+    int offset = 1;
+
+    /* helper to check remaining length */
+    #define REMAIN_AT_LEAST(x) ((size_t)(offset) + (size_t)(x) <= (buf_len))
+
+    if ((atyp & ADDRTYPE_MASK) == 1) {
+        /* IPv4 */
+        size_t in_addr_len = sizeof(struct in_addr);
+        /* need: 1 (atyp) + in_addr_len + 2 (port) */
+        if (!REMAIN_AT_LEAST(in_addr_len + 2)) {
+            LOGE("[udp] parse header: IPv4 header too short");
+            return 0;
+        }
+        if (storage != NULL) {
+            struct sockaddr_in *addr = (struct sockaddr_in *)storage;
+            addr->sin_family = AF_INET;
+            memcpy(&addr->sin_addr, buf + offset, in_addr_len);
+            memcpy(&addr->sin_port, buf + offset + in_addr_len, sizeof(uint16_t));
+        }
+        if (host != NULL) {
+            if (inet_ntop(AF_INET, (const void *)(buf + offset), host, INET_ADDRSTRLEN) == NULL) {
+                /* inet_ntop 失敗也不致命，但清空 host */
+                host[0] = '\0';
+            }
+        }
+        offset += in_addr_len + 2;
+    } else if ((atyp & ADDRTYPE_MASK) == 3) {
+        /* Domain name */
+        if (!REMAIN_AT_LEAST(1)) {
+            LOGE("[udp] parse header: domain length byte missing");
+            return 0;
+        }
+        uint8_t name_len = *(const uint8_t *)(buf + offset);
+        /* total needed: 1 (atyp) + 1 (name_len) + name_len + 2 (port) */
+        if (!REMAIN_AT_LEAST(1 + name_len + 2)) {
+            LOGE("[udp] parse header: domain header too short (name_len=%d, buf_len=%zu)", name_len, buf_len);
+            return 0;
+        }
+        /* guard tmp buffer size */
+        if (name_len >= MAX_HOSTNAME_LEN) {
+            LOGE("[udp] parse header: domain name too long (%d >= %d)", name_len, MAX_HOSTNAME_LEN);
+            return 0;
+        }
+
+        if (storage != NULL) {
+            char tmp[MAX_HOSTNAME_LEN];
+            memset(tmp, 0, sizeof(tmp));
+            memcpy(tmp, buf + offset + 1, name_len);
+            tmp[name_len] = '\0'; /* ensure nul-terminated */
+
+            struct cork_ip ip;
+            if (cork_ip_init(&ip, tmp) != -1) {
+                if (ip.version == 4) {
+                    struct sockaddr_in *addr = (struct sockaddr_in *)storage;
+                    memset(addr, 0, sizeof(*addr));
+                    addr->sin_family = AF_INET;
+                    if (inet_pton(AF_INET, tmp, &(addr->sin_addr)) <= 0) {
+                        LOGE("[udp] inet_pton failed for %s", tmp);
+                    }
+                    memcpy(&addr->sin_port, buf + offset + 1 + name_len, sizeof(uint16_t));
+                } else if (ip.version == 6) {
+                    struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)storage;
+                    memset(addr6, 0, sizeof(*addr6));
+                    addr6->sin6_family = AF_INET6;
+                    if (inet_pton(AF_INET6, tmp, &(addr6->sin6_addr)) <= 0) {
+                        LOGE("[udp] inet_pton failed for %s", tmp);
+                    }
+                    memcpy(&addr6->sin6_port, buf + offset + 1 + name_len, sizeof(uint16_t));
+                } else {
+                    /* leave storage with AF_UNSPEC so caller can know it failed */
+                    ((struct sockaddr_storage*)storage)->ss_family = AF_UNSPEC;
+                }
+            } else {
+                /* try resolving later — for now leave storage untouched or AF_UNSPEC */
+                ((struct sockaddr_storage*)storage)->ss_family = AF_UNSPEC;
+            }
+        }
+        if (host != NULL) {
+            /* copy and NUL-terminate host */
+            memcpy(host, buf + offset + 1, name_len);
+            host[name_len] = '\0';
+        }
+        offset += 1 + name_len + 2;
+    } else if ((atyp & ADDRTYPE_MASK) == 4) {
+        /* IPv6 */
+        size_t in6_addr_len = sizeof(struct in6_addr);
+        /* need: 1 (atyp) + in6_addr_len + 2 (port) */
+        if (!REMAIN_AT_LEAST(in6_addr_len + 2)) {
+            LOGE("[udp] parse header: IPv6 header too short");
+            return 0;
+        }
+        if (storage != NULL) {
+            struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
+            addr->sin6_family = AF_INET6;
+            memcpy(&addr->sin6_addr, buf + offset, in6_addr_len);
+            memcpy(&addr->sin6_port, buf + offset + in6_addr_len, sizeof(uint16_t));
+        }
+        if (host != NULL) {
+            if (inet_ntop(AF_INET6, (const void *)(buf + offset), host, INET6_ADDRSTRLEN) == NULL) {
+                host[0] = '\0';
+            }
+        }
+        offset += in6_addr_len + 2;
+    } else {
+        LOGE("[udp] parse header: unknown atyp %d", atyp);
+        return 0;
+    }
+
+    /* final sanity */
+    if (offset <= 1 || (size_t)offset > buf_len) {
+        LOGE("[udp] invalid header parsing result (offset=%d, buf_len=%zu)", offset, buf_len);
+        return 0;
+    }
+
+    /* fill port if requested (offset currently points just past port) */
+    if (port != NULL) {
+        /* port bytes are at offset-2 .. offset-1 */
+        int port_val = load16_be((const uint8_t *)buf + offset - 2);
+        sprintf(port, "%d", port_val);
+    }
+
+    return offset;
+}
+
 ssize_t
 get_sockaddr(char *host, char *port,
              struct sockaddr_storage *storage, int block,
diff --git a/src/netutils.h b/src/netutils.h
index 47320a0..9dc404d 100644
--- a/src/netutils.h
+++ b/src/netutils.h
@@ -88,6 +88,10 @@ ssize_t get_sockaddr(char *host, char *port,
                      struct sockaddr_storage *storage, int block,
                      int ipv6first);
 int set_reuseport(int socket);
+int construct_udprelay_header(const struct sockaddr_storage *in_addr,
+                              char *addr_header);
+int parse_udprelay_header(const char *buf, const size_t buf_len,
+                          char *host, char *port, struct sockaddr_storage *storage);
 
 #ifdef SET_INTERFACE
 int setinterface(int socket_fd, const char *interface_name);
diff --git a/src/probe.c b/src/probe.c
new file mode 100644
index 0000000..ad1c28f
--- /dev/null
+++ b/src/probe.c
@@ -0,0 +1,324 @@
+/*
+ * probe.c - Active probing for remote server status
+ *
+ * Copyright (C) 2019, zkc <zkc@tcpip.fun>
+ *
+ * This file is part of the shadowsocks-libev.
+ *
+ * shadowsocks-libev is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * shadowsocks-libev is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with shadowsocks-libev; see the file COPYING. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <libcork/core.h>
+
+#include "probe.h"
+#include "utils.h"
+#include "netutils.h"
+#include "udprelay.h"
+
+#define MAX_SERVERS 32
+
+extern int verbose;
+
+/* UDP Probe */
+typedef struct udp_probe_ctx {
+    ev_io io;
+    ev_timer watcher;
+    int remote_idx;
+    server_ctx_t *server_ctx;
+    crypto_t *crypto;
+    ev_tstamp start_time;
+    uint16_t dns_tx_id;
+} udp_probe_ctx_t;
+
+static ev_timer udp_probe_timer;
+static server_ctx_t *udp_servers[MAX_SERVERS] = { NULL };
+static int probe_timeout_secs = 5;
+static int probe_up_threshold = 1;
+static int probe_down_threshold = 3;
+static int udp_server_count = 0;
+
+static int *udp_probe_success_count = NULL;
+static int *udp_probe_failure_count = NULL;
+
+static unsigned char *dns_probe_packet = NULL;
+static size_t dns_probe_packet_len = 0;
+
+/*
+ * build_dns_query - Constructs a DNS query packet for a given domain name.
+ * Returns the length of the generated packet, or 0 on failure.
+ */
+static size_t build_dns_query(const char *domain, unsigned char *buf, size_t buf_len) {
+    if (!domain || !buf) return 0;
+
+    // DNS Header (12 bytes)
+    // ID (random), QR=0, Opcode=0, AA=0, TC=0, RD=1, RA=0, Z=0, RCODE=0
+    // QDCOUNT=1, ANCOUNT=0, NSCOUNT=0, ARCOUNT=0
+    unsigned char header[] = {
+        0, 0,       // Transaction ID (to be filled per-probe)
+        0x01, 0x00, // Flags: 0x0100 (Standard query)
+        0x00, 0x01, // Questions: 1
+        0x00, 0x00, // Answer RRs: 0
+        0x00, 0x00, // Authority RRs: 0
+        0x00, 0x00  // Additional RRs: 0
+    };
+    size_t offset = sizeof(header);
+    if (buf_len < offset) return 0;
+    memcpy(buf, header, offset);
+
+    // QNAME section
+    const char *p = domain;
+    while (*p) {
+        const char *dot = strchr(p, '.');
+        size_t len = dot ? (dot - p) : strlen(p);
+        if (buf_len < offset + 1 + len) return 0;
+        buf[offset++] = (unsigned char)len;
+        memcpy(buf + offset, p, len);
+        offset += len;
+        p += len;
+        if (dot) p++; // Skip the dot
+    }
+    if (buf_len < offset + 5) return 0; // 1 (null terminator) + 2 (QTYPE) + 2 (QCLASS)
+    buf[offset++] = 0x00; // Null terminator for QNAME
+    buf[offset++] = 0x00; buf[offset++] = 0x01; // QTYPE: A
+    buf[offset++] = 0x00; buf[offset++] = 0x01; // QCLASS: IN
+    return offset;
+}
+
+/* UDP Probe Implementation */
+static void udp_probe_cleanup(EV_P_ udp_probe_ctx_t *p_ctx) {
+    ev_io_stop(EV_A_ &p_ctx->io);
+    ev_timer_stop(EV_A_ &p_ctx->watcher);
+    close(p_ctx->io.fd);
+    ss_free(p_ctx);
+}
+
+static void udp_probe_recv_cb(EV_P_ ev_io *w, int revents) {
+    udp_probe_ctx_t *p_ctx = (udp_probe_ctx_t *)w;
+    buffer_t *buf = ss_malloc(sizeof(buffer_t));
+    balloc(buf, MAX_UDP_PACKET_SIZE);
+
+    ev_tstamp latency = ev_time() - p_ctx->start_time;
+    const char *addr_str = get_addr_str(p_ctx->server_ctx->remote_addr[p_ctx->remote_idx], true);
+
+    ssize_t r = recv(p_ctx->io.fd, buf->data, MAX_UDP_PACKET_SIZE, 0);
+    bool success = false;
+    if (r > 0) {
+        buf->len = r;
+        if (p_ctx->crypto->decrypt_all(buf, p_ctx->crypto->cipher, buf->capacity) == 0) {
+            // The decrypted payload is: [ss addr header][dns response]
+            // We need to parse the ss addr header first to get to the dns response.
+            int header_len = parse_udprelay_header(buf->data, buf->len, NULL, NULL, NULL);
+
+            if (header_len > 0 && buf->len > header_len) {
+                const char *dns_response_ptr = buf->data + header_len;
+                const size_t dns_response_len = buf->len - header_len;
+
+                /*
+                 * A successful probe requires:
+                 * 1. DNS RCODE is 0 (No Error).
+                 * 2. ANCOUNT (Answer Record Count) is greater than 0.
+                 */
+                const uint16_t dns_rx_id = load16_be((const uint8_t *)dns_response_ptr);
+                const bool rcode_ok = (dns_response_len >= 12) && ((dns_response_ptr[3] & 0x0F) == 0);
+                const bool has_answers = rcode_ok && (load16_be((const uint8_t *)dns_response_ptr + 6) > 0);
+
+                if (dns_rx_id == p_ctx->dns_tx_id && rcode_ok && has_answers) {
+                    success = true;
+                    if (verbose) LOGI("[probe] successful probe to %s (latency: %.3fms)", addr_str, latency * 1000);
+                }
+            }
+        }
+    }
+
+    if (success) {
+        udp_probe_failure_count[p_ctx->remote_idx] = 0;
+        udp_probe_success_count[p_ctx->remote_idx]++;
+
+        if (!p_ctx->server_ctx->remote_status[p_ctx->remote_idx] &&
+            udp_probe_success_count[p_ctx->remote_idx] >= probe_up_threshold) {
+            LOGI("[probe] remote %d is back online after %d successful probes.", p_ctx->remote_idx, udp_probe_success_count[p_ctx->remote_idx]);
+            p_ctx->server_ctx->remote_status[p_ctx->remote_idx] = true;
+        }
+    } else {
+        udp_probe_success_count[p_ctx->remote_idx] = 0;
+        udp_probe_failure_count[p_ctx->remote_idx]++;
+
+        if (p_ctx->server_ctx->remote_status[p_ctx->remote_idx] &&
+            udp_probe_failure_count[p_ctx->remote_idx] >= probe_down_threshold) {
+            LOGI("[probe] remote %d is offline after %d failed probes.", p_ctx->remote_idx, udp_probe_failure_count[p_ctx->remote_idx]);
+            p_ctx->server_ctx->remote_status[p_ctx->remote_idx] = false;
+        }
+    }
+
+    bfree(buf);
+    ss_free(buf);
+    udp_probe_cleanup(EV_A_ p_ctx);
+}
+
+static void udp_probe_timeout_cb(EV_P_ ev_timer *w, int revents) {
+    udp_probe_ctx_t *p_ctx = cork_container_of(w, udp_probe_ctx_t, watcher);
+
+    udp_probe_success_count[p_ctx->remote_idx] = 0;
+    udp_probe_failure_count[p_ctx->remote_idx]++;
+
+    const char *addr_str = get_addr_str(p_ctx->server_ctx->remote_addr[p_ctx->remote_idx], true);
+    if (p_ctx->server_ctx->remote_status[p_ctx->remote_idx] &&
+        udp_probe_failure_count[p_ctx->remote_idx] >= probe_down_threshold) {
+        LOGI("[probe] remote %d is offline after %d probe timeouts.", p_ctx->remote_idx, udp_probe_failure_count[p_ctx->remote_idx]);
+        p_ctx->server_ctx->remote_status[p_ctx->remote_idx] = false;
+    }
+    udp_probe_cleanup(EV_A_ p_ctx);
+}
+
+static void start_one_udp_probe(EV_P_ server_ctx_t *s_ctx, int idx) {
+    struct sockaddr *remote_addr = s_ctx->remote_addr[idx];
+    const char *addr_str = get_addr_str(remote_addr, true);
+
+    int probefd = socket(remote_addr->sa_family, SOCK_DGRAM, 0);
+    if (probefd == -1) return;
+
+    setnonblocking(probefd);
+
+    if (!dns_probe_packet) {
+        close(probefd);
+        return;
+    }
+
+    /* This logic now mirrors server_recv_cb to ensure packet format is identical
+     * to a real proxied packet. */
+
+    struct sockaddr_storage dns_server_addr;
+    if (get_sockaddr("8.8.8.8", "53", &dns_server_addr, 1, 0) != 0) {
+        LOGE("[probe] failed to resolve 8.8.8.8:53");
+        close(probefd);
+        return;
+    }
+    char addr_header[MAX_ADDR_HEADER_SIZE] = {0};
+    int addr_header_len = construct_udprelay_header(&dns_server_addr, addr_header);
+
+    buffer_t *buf = ss_malloc(sizeof(buffer_t));
+    balloc(buf, MAX_UDP_PACKET_SIZE);
+
+    /* 1. Start with the raw DNS query as the initial payload */
+    memcpy(buf->data, dns_probe_packet, dns_probe_packet_len);
+    buf->len = dns_probe_packet_len;
+
+    /* Generate and set a random Transaction ID for this specific probe */
+    uint16_t tx_id = rand();
+    store16_be(tx_id, (uint8_t*)buf->data);
+
+
+    /* 2. Prepend the shadowsocks address header */
+    brealloc(buf, buf->len + addr_header_len, MAX_UDP_PACKET_SIZE);
+    memmove(buf->data + addr_header_len, buf->data, buf->len);
+    memcpy(buf->data, addr_header, addr_header_len);
+    buf->len += addr_header_len;
+
+    /* 3. Encrypt the entire payload ([addr_header][dns_packet]) */
+    if (s_ctx->crypto->encrypt_all(buf, s_ctx->crypto->cipher, buf->capacity) != 0) {
+        bfree(buf);
+        ss_free(buf);
+        close(probefd);
+        return;
+    }
+
+    sendto(probefd, buf->data, buf->len, 0, remote_addr, get_sockaddr_len(remote_addr));
+    bfree(buf);
+    ss_free(buf);
+
+    udp_probe_ctx_t *p_ctx = ss_malloc(sizeof(udp_probe_ctx_t));
+    memset(p_ctx, 0, sizeof(udp_probe_ctx_t));
+    p_ctx->server_ctx = s_ctx;
+    p_ctx->remote_idx = idx;
+    p_ctx->crypto = s_ctx->crypto;
+    p_ctx->start_time = ev_time();
+    p_ctx->dns_tx_id = tx_id;
+
+    ev_io_init(&p_ctx->io, udp_probe_recv_cb, probefd, EV_READ);
+    ev_timer_init(&p_ctx->watcher, udp_probe_timeout_cb, probe_timeout_secs, 0);
+    ev_io_start(EV_A_ &p_ctx->io);
+    ev_timer_start(EV_A_ &p_ctx->watcher);
+}
+
+static void udp_probe_timer_cb(EV_P_ ev_timer *w, int revents) {
+    for (int i = 0; i < udp_server_count; i++) {
+        server_ctx_t *s_ctx = udp_servers[i];
+        if (s_ctx && s_ctx->remote_num > 1) {
+            for (int j = 0; j < s_ctx->remote_num; j++) {
+                start_one_udp_probe(EV_A_ s_ctx, j);
+            }
+        }
+    }
+}
+
+/* Public Interface */
+void probe_init(EV_P_ int udp_interval, int udp_timeout, int up_count, int down_count, const char *probe_domain) {
+    /*
+     * Initialize the timer to fire immediately (after=0) upon starting the event loop,
+     * and then repeat at the specified interval.
+     */
+    ev_timer_init(&udp_probe_timer, udp_probe_timer_cb, 0, udp_interval);
+    probe_timeout_secs = udp_timeout;
+
+    if (up_count > 0) probe_up_threshold = up_count;
+    if (down_count > 0) probe_down_threshold = down_count;
+
+    /* Allocate counters for all possible remotes */
+    udp_probe_success_count = ss_malloc(sizeof(int) * MAX_REMOTE_NUM);
+    udp_probe_failure_count = ss_malloc(sizeof(int) * MAX_REMOTE_NUM);
+    memset(udp_probe_success_count, 0, sizeof(int) * MAX_REMOTE_NUM);
+    memset(udp_probe_failure_count, 0, sizeof(int) * MAX_REMOTE_NUM);
+
+    /* Build the DNS probe packet */
+    dns_probe_packet = ss_malloc(512);
+    dns_probe_packet_len = build_dns_query(probe_domain, dns_probe_packet, 512);
+    if (dns_probe_packet_len == 0) {
+        LOGE("[probe] failed to build DNS query packet for domain: %s", probe_domain);
+        ss_free(dns_probe_packet);
+        dns_probe_packet = NULL;
+    }
+    LOGI("[probe] initialized with domain=%s, interval=%d, timeout=%d, up_threshold=%d, down_threshold=%d", 
+        probe_domain, udp_interval, udp_timeout, probe_up_threshold, probe_down_threshold);
+}
+
+void probe_add_udp_server(void *server_ptr) {
+    server_ctx_t *server = (server_ctx_t *)server_ptr;
+    if (udp_server_count < MAX_SERVERS) {
+        udp_servers[udp_server_count++] = server;
+        if (server->remote_num > 1 && !ev_is_active(&udp_probe_timer)) {
+            ev_timer_start(EV_DEFAULT, &udp_probe_timer);
+        }
+    } else {
+        LOGE("[probe] too many udp servers");
+    }
+}
+
+void probe_cleanup(EV_P) {
+    if (ev_is_active(&udp_probe_timer)) {
+        ev_timer_stop(EV_A_ &udp_probe_timer);
+    }
+    ss_free(udp_probe_success_count);
+    ss_free(udp_probe_failure_count);
+    udp_probe_success_count = NULL;
+    udp_probe_failure_count = NULL;
+    ss_free(dns_probe_packet);
+    dns_probe_packet = NULL;
+}
\ No newline at end of file
diff --git a/src/probe.h b/src/probe.h
new file mode 100644
index 0000000..4e6f5ee
--- /dev/null
+++ b/src/probe.h
@@ -0,0 +1,32 @@
+/*
+ * probe.h - Active probing for remote server status
+ *
+ * Copyright (C) 2019, zkc <zkc@tcpip.fun>
+ *
+ * This file is part of the shadowsocks-libev.
+ *
+ * shadowsocks-libev is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * shadowsocks-libev is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with shadowsocks-libev; see the file COPYING. If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _PROBE_H
+#define _PROBE_H
+
+#include <ev.h>
+
+void probe_init(EV_P_ int udp_interval, int udp_timeout, int up_count, int down_count, const char *domain);
+void probe_add_udp_server(void *server);
+void probe_cleanup(EV_P);
+
+#endif // _PROBE_H
\ No newline at end of file
diff --git a/src/redir.c b/src/redir.c
index d242a61..27fc0de 100644
--- a/src/redir.c
+++ b/src/redir.c
@@ -52,6 +52,8 @@
 #include "utils.h"
 #include "common.h"
 #include "redir.h"
+#include "udprelay.h"
+#include "probe.h"
 
 #ifndef EAGAIN
 #define EAGAIN EWOULDBLOCK
@@ -87,6 +89,9 @@ static void close_and_free_remote(EV_P_ remote_t *remote);
 static void free_server(server_t *server);
 static void close_and_free_server(EV_P_ server_t *server);
 
+static void start_connect_remote(EV_P_ server_t *server);
+static void handle_tcp_fail(EV_P_ server_t *server);
+
 int verbose    = 0;
 int reuse_port = 0;
 int tcp_incoming_sndbuf = 0;
@@ -112,6 +117,10 @@ static struct ev_signal sigchld_watcher;
 
 static int tcp_tproxy = 0; /* use tproxy instead of redirect (for tcp) */
 
+#define MAX_LISTEN_CTX 128
+static listen_ctx_t *listen_ctx_list[MAX_LISTEN_CTX] = { NULL };
+static int listen_ctx_count                          = 0;
+
 static int
 getdestaddr(int fd, struct sockaddr_storage *destaddr)
 {
@@ -134,17 +143,7 @@ getdestaddr(int fd, struct sockaddr_storage *destaddr)
 }
 
 int
-setnonblocking(int fd)
-{
-    int flags;
-    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
-        flags = 0;
-    }
-    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-}
-
-int
-create_and_bind(const char *addr, const char *port)
+create_and_bind(const char *addr, const char *port, int af)
 {
     struct addrinfo hints;
     struct addrinfo *result, *rp;
@@ -153,6 +152,10 @@ create_and_bind(const char *addr, const char *port)
     memset(&hints, 0, sizeof(struct addrinfo));
     hints.ai_family   = AF_UNSPEC;   /* Return IPv4 and IPv6 choices */
     hints.ai_socktype = SOCK_STREAM; /* We want a TCP socket */
+    if (addr == NULL) {
+        /* For wildcard IP address */
+        hints.ai_flags = AI_PASSIVE;
+    }
 
     result = NULL;
 
@@ -168,6 +171,10 @@ create_and_bind(const char *addr, const char *port)
     }
 
     for (rp = result; rp != NULL; rp = rp->ai_next) {
+        if (af != AF_UNSPEC && rp->ai_family != af) {
+            continue;
+        }
+
         listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
         if (listen_sock == -1) {
             continue;
@@ -203,7 +210,13 @@ create_and_bind(const char *addr, const char *port)
 
         s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);
         if (s == 0) {
-            /* We managed to bind successfully! */
+            if (listen(listen_sock, SOMAXCONN) == -1) {
+                ERROR("listen() error");
+                close(listen_sock);
+                listen_sock = -1;
+                continue;
+            }
+            setnonblocking(listen_sock);
             break;
         } else {
             ERROR("bind");
@@ -221,8 +234,8 @@ create_and_bind(const char *addr, const char *port)
 static void
 server_recv_cb(EV_P_ ev_io *w, int revents)
 {
-    server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
-    server_t *server              = server_recv_ctx->server;
+    tcp_server_ctx_t *server_recv_ctx = (tcp_server_ctx_t *)w;
+    server_t *server             = server_recv_ctx->server;
     remote_t *remote              = server->remote;
 
     ev_timer_stop(EV_A_ & server->delayed_connect_watcher);
@@ -313,8 +326,8 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
 static void
 server_send_cb(EV_P_ ev_io *w, int revents)
 {
-    server_ctx_t *server_send_ctx = (server_ctx_t *)w;
-    server_t *server              = server_send_ctx->server;
+    tcp_server_ctx_t *server_send_ctx = (tcp_server_ctx_t *)w;
+    server_t *server             = server_send_ctx->server;
     remote_t *remote              = server->remote;
     if (server->buf->len == 0) {
         // close and free
@@ -374,23 +387,27 @@ delayed_connect_cb(EV_P_ ev_timer *watcher, int revents)
 static void
 remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
 {
-    remote_ctx_t *remote_ctx
-        = cork_container_of(watcher, remote_ctx_t, watcher);
+    tcp_remote_ctx_t *remote_ctx
+        = cork_container_of(watcher, tcp_remote_ctx_t, watcher);
 
     remote_t *remote = remote_ctx->remote;
     server_t *server = remote->server;
 
     ev_timer_stop(EV_A_ watcher);
 
-    close_and_free_remote(EV_A_ remote);
-    close_and_free_server(EV_A_ server);
+    /* On remote connect/send timeout, try failover (don't immediately
+     * kill the server). The failover function will close the current
+     * remote socket and start connect to next remote in the listener
+     * address list.
+     */
+    handle_tcp_fail(EV_A_ server);
 }
 
 static void
 remote_recv_cb(EV_P_ ev_io *w, int revents)
 {
-    remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_recv_ctx->remote;
+    tcp_remote_ctx_t *remote_recv_ctx = (tcp_remote_ctx_t *)w;
+    remote_t *remote                    = remote_recv_ctx->remote;
     server_t *server              = remote->server;
 
     ssize_t r = recv(remote->fd, server->buf->data, SOCKET_BUF_SIZE, 0);
@@ -458,9 +475,9 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
 static void
 remote_send_cb(EV_P_ ev_io *w, int revents)
 {
-    remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
-    remote_t *remote              = remote_send_ctx->remote;
-    server_t *server              = remote->server;
+    tcp_remote_ctx_t *remote_send_ctx = (tcp_remote_ctx_t *)w;
+    remote_t *remote                    = remote_send_ctx->remote;
+    server_t *server                    = remote->server;
 
     ev_timer_stop(EV_A_ & remote_send_ctx->watcher);
 
@@ -479,60 +496,38 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
             ev_io_stop(EV_A_ & server->recv_ctx->io);
             ev_io_start(EV_A_ & remote->recv_ctx->io);
 
-            // send destaddr
+            /* send destaddr */
             buffer_t ss_addr_to_send;
             buffer_t *abuf = &ss_addr_to_send;
             balloc(abuf, SOCKET_BUF_SIZE);
 
-            if (AF_INET6 == server->destaddr.ss_family) { // IPv6
-                abuf->data[abuf->len++] = 4;          // Type 4 is IPv6 address
-
-                size_t in6_addr_len = sizeof(struct in6_addr);
-                memcpy(abuf->data + abuf->len,
-                       &(((struct sockaddr_in6 *)&(server->destaddr))->sin6_addr),
-                       in6_addr_len);
-                abuf->len += in6_addr_len;
-                memcpy(abuf->data + abuf->len,
-                       &(((struct sockaddr_in6 *)&(server->destaddr))->sin6_port),
-                       2);
-            } else {                             // IPv4
-                abuf->data[abuf->len++] = 1; // Type 1 is IPv4 address
-
-                size_t in_addr_len = sizeof(struct in_addr);
-                memcpy(abuf->data + abuf->len,
-                       &((struct sockaddr_in *)&(server->destaddr))->sin_addr, in_addr_len);
-                abuf->len += in_addr_len;
-                memcpy(abuf->data + abuf->len,
-                       &((struct sockaddr_in *)&(server->destaddr))->sin_port, 2);
-            }
-
-            abuf->len += 2;
-
-            int err = crypto->encrypt(abuf, server->e_ctx, SOCKET_BUF_SIZE);
-            if (err) {
-                LOGE("invalid password or cipher");
+            // Construct address header directly into abuf
+            int addr_len = construct_udprelay_header(&server->destaddr, abuf->data);
+            if (addr_len == 0) {
+                LOGE("failed to construct address header");
                 bfree(abuf);
                 close_and_free_remote(EV_A_ remote);
                 close_and_free_server(EV_A_ server);
                 return;
             }
+            abuf->len = addr_len;
+
+            // Prepend address header to the data buffer
+            bprepend(remote->buf, abuf, SOCKET_BUF_SIZE);
+            bfree(abuf);
 
-            err = crypto->encrypt(remote->buf, server->e_ctx, SOCKET_BUF_SIZE);
+            // Encrypt the combined buffer ([addr_header][payload]) once
+            int err = crypto->encrypt(remote->buf, server->e_ctx, SOCKET_BUF_SIZE);
             if (err) {
                 LOGE("invalid password or cipher");
-                bfree(abuf);
                 close_and_free_remote(EV_A_ remote);
                 close_and_free_server(EV_A_ server);
                 return;
             }
-
-            bprepend(remote->buf, abuf, SOCKET_BUF_SIZE);
-            bfree(abuf);
         } else {
             ERROR("getpeername");
             // not connected
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
+            handle_tcp_fail(EV_A_ server);
             return;
         }
     }
@@ -577,8 +572,7 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
                     } else {
                         ERROR("fast_open_connect");
                     }
-                    close_and_free_remote(EV_A_ remote);
-                    close_and_free_server(EV_A_ server);
+                    handle_tcp_fail(EV_A_ server);
                 }
                 return;
             }
@@ -590,19 +584,18 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
         if (s == -1) {
             if (errno != EAGAIN && errno != EWOULDBLOCK) {
                 ERROR("send");
-                // close and free
-                close_and_free_remote(EV_A_ remote);
-                close_and_free_server(EV_A_ server);
+                /* close current remote and try next */
+                handle_tcp_fail(EV_A_ server);
             }
             return;
         } else if (s < remote->buf->len) {
-            // partly sent, move memory, wait for the next time to send
+            /* partly sent, move memory, wait for the next time to send */
             remote->buf->len -= s;
             remote->buf->idx += s;
             ev_io_start(EV_A_ & remote_send_ctx->io);
             return;
         } else {
-            // all sent out, wait for reading
+            /* all sent out, wait for reading */
             remote->buf->len = 0;
             remote->buf->idx = 0;
             ev_io_stop(EV_A_ & remote_send_ctx->io);
@@ -617,12 +610,12 @@ new_remote(int fd, int timeout)
     remote_t *remote = ss_malloc(sizeof(remote_t));
     memset(remote, 0, sizeof(remote_t));
 
-    remote->recv_ctx = ss_malloc(sizeof(remote_ctx_t));
-    remote->send_ctx = ss_malloc(sizeof(remote_ctx_t));
+    remote->recv_ctx = ss_malloc(sizeof(tcp_remote_ctx_t));
+    remote->send_ctx = ss_malloc(sizeof(tcp_remote_ctx_t));
     remote->buf      = ss_malloc(sizeof(buffer_t));
     balloc(remote->buf, SOCKET_BUF_SIZE);
-    memset(remote->recv_ctx, 0, sizeof(remote_ctx_t));
-    memset(remote->send_ctx, 0, sizeof(remote_ctx_t));
+    memset(remote->recv_ctx, 0, sizeof(tcp_remote_ctx_t));
+    memset(remote->send_ctx, 0, sizeof(tcp_remote_ctx_t));
     remote->fd                  = fd;
     remote->recv_ctx->remote    = remote;
     remote->recv_ctx->connected = 0;
@@ -670,12 +663,12 @@ new_server(int fd)
     server_t *server = ss_malloc(sizeof(server_t));
     memset(server, 0, sizeof(server_t));
 
-    server->recv_ctx = ss_malloc(sizeof(server_ctx_t));
-    server->send_ctx = ss_malloc(sizeof(server_ctx_t));
+    server->recv_ctx = ss_malloc(sizeof(tcp_server_ctx_t));
+    server->send_ctx = ss_malloc(sizeof(tcp_server_ctx_t));
     server->buf      = ss_malloc(sizeof(buffer_t));
     balloc(server->buf, SOCKET_BUF_SIZE);
-    memset(server->recv_ctx, 0, sizeof(server_ctx_t));
-    memset(server->send_ctx, 0, sizeof(server_ctx_t));
+    memset(server->recv_ctx, 0, sizeof(tcp_server_ctx_t));
+    memset(server->send_ctx, 0, sizeof(tcp_server_ctx_t));
     server->fd                  = fd;
     server->recv_ctx->server    = server;
     server->recv_ctx->connected = 0;
@@ -732,43 +725,45 @@ close_and_free_server(EV_P_ server_t *server)
 }
 
 static void
-accept_cb(EV_P_ ev_io *w, int revents)
+handle_tcp_fail(EV_P_ server_t *server)
 {
-    listen_ctx_t *listener = (listen_ctx_t *)w;
-    struct sockaddr_storage destaddr;
-    memset(&destaddr, 0, sizeof(struct sockaddr_storage));
-
-    int err;
-
-    int serverfd = accept(listener->fd, NULL, NULL);
-    if (serverfd == -1) {
-        ERROR("accept");
-        return;
+    if (server->remote) {
+        close_and_free_remote(EV_A_ server->remote);
+        server->remote = NULL;
     }
 
-    err = getdestaddr(serverfd, &destaddr);
-    if (err) {
-        ERROR("getdestaddr");
-        return;
+    if (server->listener) {
+        if (verbose) {
+            LOGI("tcp: handling failure for remote index %d", server->remote_idx);
+        }
+        const char *addr_str = get_addr_str(server->listener->remote_addr[server->remote_idx], true);
     }
 
-    setnonblocking(serverfd);
-    int opt = 1;
-    setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
-#ifdef SO_NOSIGPIPE
-    setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
-#endif
+    /*
+     * Do not failover to the next remote on connection failure.
+     * The probing mechanism is now solely responsible for managing remote status.
+     * We just close the server connection and let the client retry.
+     */
+    LOGE("TCP connection to remote %d failed, closing connection.", server->remote_idx);
+    close_and_free_server(EV_A_ server);
+}
 
-    if (tcp_incoming_sndbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &tcp_incoming_sndbuf, sizeof(int));
-    }
+static void
+start_connect_remote(EV_P_ server_t *server)
+{
+    listen_ctx_t *listener = server->listener;
 
-    if (tcp_incoming_rcvbuf > 0) {
-        setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &tcp_incoming_rcvbuf, sizeof(int));
+    if (server->remote_idx >= listener->remote_num) {
+        LOGE("all remote servers failed to connect");
+        handle_tcp_fail(EV_A_ server);
+        return;
     }
 
-    int index                    = rand() % listener->remote_num;
-    struct sockaddr *remote_addr = listener->remote_addr[index];
+    struct sockaddr *remote_addr = listener->remote_addr[server->remote_idx];
+    const char *addr_str = get_addr_str(remote_addr, true);
+    if (verbose) {
+        LOGI("tcp: attempting to connect to remote %d at %s", server->remote_idx, addr_str);
+    }
 
     int protocol = IPPROTO_TCP;
     if (listener->mptcp < 0) {
@@ -776,17 +771,19 @@ accept_cb(EV_P_ ev_io *w, int revents)
     }
     int remotefd = socket(remote_addr->sa_family, SOCK_STREAM, protocol);
     if (remotefd == -1) {
-        ERROR("socket");
+        ERROR("[tcp] socket");
+        handle_tcp_fail(EV_A_ server);
         return;
     }
 
-    // Set flags
+    int opt = 1;
+    /* Set flags */
     setsockopt(remotefd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
 #ifdef SO_NOSIGPIPE
     setsockopt(remotefd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
 #endif
 
-    // Enable TCP keepalive feature
+    /* Enable TCP keepalive feature */
     int keepAlive    = 1;
     int keepIdle     = 40;
     int keepInterval = 20;
@@ -796,7 +793,7 @@ accept_cb(EV_P_ ev_io *w, int revents)
     setsockopt(remotefd, SOL_TCP, TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval));
     setsockopt(remotefd, SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount));
 
-    // Set non blocking
+    /* Set non blocking */
     setnonblocking(remotefd);
 
     if (listener->tos >= 0) {
@@ -816,7 +813,7 @@ accept_cb(EV_P_ ev_io *w, int revents)
     if (listener->mptcp > 1) {
         int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
         if (err == -1) {
-            ERROR("failed to enable out-of-tree multipath TCP");
+            ERROR("[tcp] failed to enable out-of-tree multipath TCP");
         }
     } else if (listener->mptcp == 1) {
         int i = 0;
@@ -828,7 +825,7 @@ accept_cb(EV_P_ ev_io *w, int revents)
             i++;
         }
         if (listener->mptcp == 0) {
-            ERROR("failed to enable out-of-tree multipath TCP");
+            ERROR("[tcp] failed to enable out-of-tree multipath TCP");
         }
     }
 
@@ -848,32 +845,104 @@ accept_cb(EV_P_ ev_io *w, int revents)
     }
 #endif
 
-    server_t *server = new_server(serverfd);
     remote_t *remote = new_remote(remotefd, listener->timeout);
     server->remote   = remote;
     remote->server   = server;
-    server->destaddr = destaddr;
 
     if (fast_open) {
-        // save remote addr for fast open
+        if (verbose) {
+            LOGI("tcp: using TCP Fast Open for remote connection");
+        }
+        /* save remote addr for fast open */
         remote->addr = remote_addr;
         ev_timer_start(EV_A_ & server->delayed_connect_watcher);
     } else {
         int r = connect(remotefd, remote_addr, get_sockaddr_len(remote_addr));
 
         if (r == -1 && errno != CONNECT_IN_PROGRESS) {
-            ERROR("connect");
-            close_and_free_remote(EV_A_ remote);
-            close_and_free_server(EV_A_ server);
+            ERROR("[tcp] connect");
+            handle_tcp_fail(EV_A_ server);
             return;
         }
-        // listen to remote connected event
+        if (verbose) {
+            LOGI("tcp: connect() issued for remote fd %d", remotefd);
+        }
+        /* listen to remote connected event */
         ev_io_start(EV_A_ & remote->send_ctx->io);
         ev_timer_start(EV_A_ & remote->send_ctx->watcher);
     }
     ev_io_start(EV_A_ & server->recv_ctx->io);
 }
 
+static void
+accept_cb(EV_P_ ev_io *w, int revents)
+{
+    listen_ctx_t *listener = (listen_ctx_t *)w;
+    struct sockaddr_storage destaddr;
+    memset(&destaddr, 0, sizeof(struct sockaddr_storage));
+
+    int err;
+
+    int serverfd = accept(listener->fd, NULL, NULL);
+    if (serverfd == -1) {
+        ERROR("[tcp] accept");
+        return;
+    }
+
+    err = getdestaddr(serverfd, &destaddr);
+    if (err) {
+        ERROR("tcp: getdestaddr");
+        close(serverfd);
+        return;
+    }
+
+    setnonblocking(serverfd);
+    int opt = 1;
+    setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &opt, sizeof(opt));
+#ifdef SO_NOSIGPIPE
+    setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
+#endif
+
+    if (tcp_incoming_sndbuf > 0) {
+        setsockopt(serverfd, SOL_SOCKET, SO_SNDBUF, &tcp_incoming_sndbuf, sizeof(int));
+    }
+
+    if (tcp_incoming_rcvbuf > 0) {
+        setsockopt(serverfd, SOL_SOCKET, SO_RCVBUF, &tcp_incoming_rcvbuf, sizeof(int));
+    }
+
+    server_t *server = new_server(serverfd);
+    server->destaddr = destaddr;
+    if (verbose) {
+        LOGI("tcp: created server context for fd %d", serverfd);
+    }
+
+    /* associate with listener and find first available remote */
+    server->listener = listener;
+    int start_idx = -1;
+    if (listener && listener->remote_num > 0) {
+        for (int i = 0; i < listener->remote_num; i++) {
+            if (listener->remote_status[i]) {
+                start_idx = i;
+                break;
+            }
+        }
+    }
+    if (start_idx == -1) {
+        LOGE("tcp: no remote servers available for fd %d, dropping connection.", serverfd);
+        close(serverfd);
+        free_server(server);
+        return;
+    }
+
+    server->remote_idx = start_idx;
+
+   if (verbose) {
+        LOGI("tcp: starting to connect remote for fd %d", serverfd);
+    }
+    start_connect_remote(EV_A_ server);
+}
+
 static void
 signal_cb(EV_P_ ev_signal *w, int revents)
 {
@@ -886,13 +955,15 @@ signal_cb(EV_P_ ev_signal *w, int revents)
             } else
                 return;
         case SIGINT:
-        case SIGTERM:
+        case SIGTERM: {
             ev_signal_stop(EV_DEFAULT, &sigint_watcher);
             ev_signal_stop(EV_DEFAULT, &sigterm_watcher);
             ev_signal_stop(EV_DEFAULT, &sigchld_watcher);
+            probe_cleanup(EV_A);
 
             ev_unloop(EV_A_ EVUNLOOP_ALL);
         }
+        }
     }
 }
 
@@ -919,6 +990,11 @@ main(int argc, char **argv)
     char *plugin_opts = NULL;
     char *plugin_host = NULL;
     char *plugin_port = NULL;
+    int probe_interval = 0;
+    int probe_timeout = 0;
+    int probe_up_count = 0;
+    int probe_down_count = 0;
+    char *probe_domain = NULL;
     char tmp_port[8];
 
     int dscp_num    = 0;
@@ -945,6 +1021,11 @@ main(int argc, char **argv)
         { "password",    required_argument, NULL, GETOPT_VAL_PASSWORD    },
         { "key",         required_argument, NULL, GETOPT_VAL_KEY         },
         { "fwmark",      required_argument, NULL, GETOPT_VAL_FWMARK      },
+        { "probe-interval", required_argument, NULL, GETOPT_VAL_PROBE_INTERVAL },
+        { "probe-timeout",  required_argument, NULL, GETOPT_VAL_PROBE_TIMEOUT  },
+        { "probe-up-count", required_argument, NULL, GETOPT_VAL_PROBE_UP_COUNT },
+        { "probe-down-count", required_argument, NULL, GETOPT_VAL_PROBE_DOWN_COUNT },
+        { "probe-domain", required_argument, NULL, GETOPT_VAL_PROBE_DOMAIN },
         { "help",        no_argument,       NULL, GETOPT_VAL_HELP        },
         { NULL,          0,                 NULL, 0                      }
     };
@@ -980,6 +1061,21 @@ main(int argc, char **argv)
         case GETOPT_VAL_FWMARK:
             fwmark = atoi(optarg);
             break;
+        case GETOPT_VAL_PROBE_INTERVAL:
+            probe_interval = atoi(optarg);
+            break;
+        case GETOPT_VAL_PROBE_TIMEOUT:
+            probe_timeout = atoi(optarg);
+            break;
+        case GETOPT_VAL_PROBE_UP_COUNT:
+            probe_up_count = atoi(optarg);
+            break;
+        case GETOPT_VAL_PROBE_DOWN_COUNT:
+            probe_down_count = atoi(optarg);
+            break;
+        case GETOPT_VAL_PROBE_DOMAIN:
+            probe_domain = optarg;
+            break;
         case GETOPT_VAL_REUSE_PORT:
             reuse_port = 1;
             break;
@@ -1158,6 +1254,21 @@ main(int argc, char **argv)
         if (fwmark == 0 && conf->fwmark > 0) {
             fwmark = conf->fwmark;
         }
+        if (probe_interval == 0) {
+            probe_interval = conf->probe_interval;
+        }
+        if (probe_timeout == 0) {
+            probe_timeout = conf->probe_timeout;
+        }
+        if (probe_up_count == 0) {
+            probe_up_count = conf->probe_up_count;
+        }
+        if (probe_down_count == 0) {
+            probe_down_count = conf->probe_down_count;
+        }
+        if (probe_domain == NULL) {
+            probe_domain = conf->probe_domain;
+        }
     }
 
     if (remote_num == 0 || remote_port == NULL || local_port == NULL
@@ -1203,14 +1314,6 @@ main(int argc, char **argv)
     }
 #endif
 
-    if (local_addr == NULL) {
-        if (is_ipv6only(remote_addr, remote_num, ipv6first)) {
-            local_addr = "::1";
-        } else {
-            local_addr = "127.0.0.1";
-        }
-    }
-
     if (fast_open == 1) {
 #ifdef TCP_FASTOPEN
         LOGI("using tcp fast open");
@@ -1238,15 +1341,15 @@ main(int argc, char **argv)
     }
 
     if (mtu > 0) {
-        LOGI("[redir] set MTU to %d", mtu);
+        LOGI("set MTU to %d", mtu);
     }
 
     if (timeout) {
-        LOGI("[redir] set timeout to %s", timeout);
+        LOGI("set timeout to %s", timeout);
     }
 
     if (fwmark > 0) {
-        LOGI("[redir] set fwmark to %d", fwmark);
+        LOGI("set fwmark to %d", fwmark);
     }
 
     if (tcp_incoming_sndbuf != 0 && tcp_incoming_sndbuf < SOCKET_BUF_SIZE) {
@@ -1281,6 +1384,26 @@ main(int argc, char **argv)
         LOGI("set TCP outgoing connection receive buffer size to %d", tcp_outgoing_rcvbuf);
     }
 
+    if (probe_interval <= 0) {
+        probe_interval = 60; /* default 60s */
+    }
+
+    if (probe_timeout <= 0){
+        probe_timeout = 5; /* default 5s */
+    }
+
+    if (probe_up_count <= 0) {
+        probe_up_count = 3; /* default 3 */
+    }
+
+    if (probe_down_count <= 0){
+        probe_down_count = 3; /* default 3 */
+    }
+
+    if(!probe_domain || strlen(probe_domain) == 0) {
+        probe_domain = "www.google.com";
+    }
+
     if (plugin != NULL) {
         int len          = 0;
         size_t buf_size  = 256 * remote_num;
@@ -1298,7 +1421,8 @@ main(int argc, char **argv)
         }
     }
 
-    // ignore SIGPIPE
+
+    /* ignore SIGPIPE */
     signal(SIGPIPE, SIG_IGN);
     signal(SIGABRT, SIG_IGN);
 
@@ -1309,19 +1433,25 @@ main(int argc, char **argv)
     ev_signal_start(EV_DEFAULT, &sigterm_watcher);
     ev_signal_start(EV_DEFAULT, &sigchld_watcher);
 
-    // Setup keys
+    struct ev_loop *loop = EV_DEFAULT;
+
+    probe_init(EV_A_ probe_interval, probe_timeout, probe_up_count, probe_down_count, probe_domain);
+
     LOGI("initializing ciphers... %s", method);
     crypto = crypto_init(password, key, method);
     if (crypto == NULL)
         FATAL("failed to initialize ciphers");
 
-    // Setup proxy context
+    /* Setup proxy context */
     struct listen_ctx listen_ctx;
     memset(&listen_ctx, 0, sizeof(struct listen_ctx));
     listen_ctx.remote_num  = remote_num;
     listen_ctx.remote_addr = ss_malloc(sizeof(struct sockaddr *) * remote_num);
     memset(listen_ctx.remote_addr, 0, sizeof(struct sockaddr *) * remote_num);
+    listen_ctx.remote_status = ss_malloc(sizeof(bool) * remote_num);
+
     for (i = 0; i < remote_num; i++) {
+        listen_ctx.remote_status[i] = true; /* Assume all are up initially */
         char *host = remote_addr[i].host;
         char *port = remote_addr[i].port == NULL ? remote_port :
                      remote_addr[i].port;
@@ -1342,63 +1472,66 @@ main(int argc, char **argv)
     listen_ctx.timeout = atoi(timeout);
     listen_ctx.mptcp   = mptcp;
 
-    struct ev_loop *loop = EV_DEFAULT;
-
-    listen_ctx_t *listen_ctx_current = &listen_ctx;
-    do {
-        if (listen_ctx_current->tos) {
-            LOGI("listening at %s:%s (TOS 0x%x)", local_addr, local_port, listen_ctx_current->tos);
-        } else {
-            LOGI("listening at %s:%s", local_addr, local_port);
-        }
+    /*
+     * Initialize UDP relay first if enabled.
+     * This is crucial because the UDP module allocates and manages the
+     * `remote_status` array that the TCP module will share.
+     */
+    if (mode != TCP_ONLY) {
+        init_udprelay(local_addr, local_port, listen_ctx.remote_num,
+                      listen_ctx.remote_addr, mtu, crypto,
+                      listen_ctx.timeout, NULL, fwmark, listen_ctx.remote_status);
+    }
 
-        if (mode != UDP_ONLY) {
-            // Setup socket
-            int listenfd;
-            listenfd = create_and_bind(local_addr, local_port);
-            if (listenfd == -1) {
-                FATAL("bind() error");
-            }
-            if (listen(listenfd, SOMAXCONN) == -1) {
-                FATAL("listen() error");
+    /*
+     * Now, set up TCP listeners. They will all share the same `remote_status`
+     * array, which is either managed by the UDP prober or statically set to true.
+     */
+    if (mode != UDP_ONLY) {
+        listen_ctx_t *listen_ctx_current = &listen_ctx;
+        do {
+            listen_ctx_current->local_port = local_port;
+            if (listen_ctx_current->tos) {
+                LOGI("listening at %s:%s (TOS 0x%x)", local_addr, local_port, listen_ctx_current->tos);
+            } else {
+                LOGI("listening at %s:%s", local_addr, local_port);
             }
-            setnonblocking(listenfd);
-
-            listen_ctx_current->fd = listenfd;
 
-            ev_io_init(&listen_ctx_current->io, accept_cb, listenfd, EV_READ);
-            ev_io_start(loop, &listen_ctx_current->io);
-        }
+            if (listen_ctx_count < MAX_LISTEN_CTX) {
+                listen_ctx_list[listen_ctx_count++] = listen_ctx_current;
+            } else {
+                LOGE("too many listen ctx; increase MAX_LISTEN_CTX");
+            }
 
-        // Setup UDP
-        if (mode != TCP_ONLY) {
-            LOGI("UDP relay enabled");
-            char *host                       = remote_addr[0].host;
-            char *port                       = remote_addr[0].port == NULL ? remote_port : remote_addr[0].port;
-            struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
-            memset(storage, 0, sizeof(struct sockaddr_storage));
-            if (get_sockaddr(host, port, storage, 1, ipv6first) == -1) {
-                FATAL("failed to resolve the provided hostname");
+            /* Handle additional TOS/DSCP listening ports */
+            if (dscp_num > 0) {
+                listen_ctx_t *new_lc = (listen_ctx_t *)ss_malloc(sizeof(listen_ctx_t));
+                memcpy(new_lc, &listen_ctx, sizeof(listen_ctx_t));
+                local_port = dscp[dscp_num - 1].port;
+                new_lc->tos = dscp[dscp_num - 1].dscp << 2;
+                listen_ctx_current = new_lc;
             }
-            struct sockaddr *addr = (struct sockaddr *)storage;
-            init_udprelay(local_addr, local_port, addr,
-                          get_sockaddr_len(addr), mtu, crypto, listen_ctx_current->timeout, NULL, fwmark);
-        }
+        } while (dscp_num-- > 0 && listen_ctx_current != NULL);
 
-        if (mode == UDP_ONLY) {
-            LOGI("TCP relay disabled");
-        }
+        /* Now, create sockets for all configured listeners */
+        for (i = 0; i < listen_ctx_count; i++) {
+            listen_ctx_t *listener = listen_ctx_list[i];
+            int listenfd = create_and_bind(local_addr, listener->local_port, AF_UNSPEC);
+            if (listenfd == -1) {
+                FATAL("bind() error");
+            }
+            listener->fd = listenfd;
 
-        // Handle additionals TOS/DSCP listening ports
-        if (dscp_num > 0) {
-            listen_ctx_current      = (listen_ctx_t *)ss_malloc(sizeof(listen_ctx_t));
-            listen_ctx_current      = memcpy(listen_ctx_current, &listen_ctx, sizeof(listen_ctx_t));
-            local_port              = dscp[dscp_num - 1].port;
-            listen_ctx_current->tos = dscp[dscp_num - 1].dscp << 2;
+            ev_io_init(&listener->io, accept_cb, listenfd, EV_READ);
+            listener->io.data = listener;
+            ev_io_start(EV_A_ &listener->io);
         }
-    } while (dscp_num-- > 0);
+    } else {
+        /* free listen_ctx if only UDP is enabled */
+        LOGI("TCP relay disabled");
+    }
 
-    // setuid
+    /* setuid */
     if (user != NULL && !run_as(user)) {
         FATAL("failed to switch user");
     }
@@ -1413,9 +1546,18 @@ main(int argc, char **argv)
         stop_plugin();
     }
 
-    for (i = 0; i < remote_num; i++)
+    for (i = 0; i < remote_num; i++) {
         ss_free(listen_ctx.remote_addr[i]);
+    }
+    
     ss_free(listen_ctx.remote_addr);
 
+    /* Free dynamically allocated listen contexts for DSCP */
+    for (i = 0; i < listen_ctx_count; i++) {
+        if (listen_ctx_list[i] != &listen_ctx) {
+            ss_free(listen_ctx_list[i]);
+        }
+    }
+
     return ret_val;
 }
diff --git a/src/redir.h b/src/redir.h
index 2544d65..29c69f0 100644
--- a/src/redir.h
+++ b/src/redir.h
@@ -38,42 +38,46 @@ typedef struct listen_ctx {
     int fd;
     int mptcp;
     int tos;
+    volatile bool *remote_status;
+    const char *local_port;
     struct sockaddr **remote_addr;
 } listen_ctx_t;
 
-typedef struct server_ctx {
+typedef struct tcp_server_ctx {
     ev_io io;
     int connected;
     struct server *server;
-} server_ctx_t;
+} tcp_server_ctx_t;
 
 typedef struct server {
     int fd;
 
     buffer_t *buf;
 
-    cipher_ctx_t *e_ctx;
-    cipher_ctx_t *d_ctx;
-    struct server_ctx *recv_ctx;
-    struct server_ctx *send_ctx;
+    cipher_ctx_t *e_ctx; // encryption context
+    cipher_ctx_t *d_ctx; // decryption context
+    tcp_server_ctx_t *recv_ctx;
+    tcp_server_ctx_t *send_ctx;
     struct remote *remote;
 
     struct sockaddr_storage destaddr;
     ev_timer delayed_connect_watcher;
+    int remote_idx;
+    struct listen_ctx *listener;
 } server_t;
 
-typedef struct remote_ctx {
+typedef struct tcp_remote_ctx {
     ev_io io;
     ev_timer watcher;
     int connected;
     struct remote *remote;
-} remote_ctx_t;
+} tcp_remote_ctx_t;
 
 typedef struct remote {
     int fd;
     buffer_t *buf;
-    struct remote_ctx *recv_ctx;
-    struct remote_ctx *send_ctx;
+    tcp_remote_ctx_t *recv_ctx;
+    tcp_remote_ctx_t *send_ctx;
     struct server *server;
     uint32_t counter;
     struct sockaddr *addr;
diff --git a/src/stream.c b/src/stream.c
index 4a09933..1f4d06a 100644
--- a/src/stream.c
+++ b/src/stream.c
@@ -318,7 +318,6 @@ stream_encrypt_all(buffer_t *plaintext, cipher_t *cipher, size_t capacity)
     cipher_ctx_set_nonce(&cipher_ctx, nonce, nonce_len, 1);
     memcpy(ciphertext->data, nonce, nonce_len);
 
-
     if (cipher->method >= SALSA20) {
         crypto_stream_xor_ic((uint8_t *)(ciphertext->data + nonce_len),
                              (const uint8_t *)plaintext->data, (uint64_t)(plaintext->len),
diff --git a/src/udprelay.c b/src/udprelay.c
index b786e13..7b27633 100644
--- a/src/udprelay.c
+++ b/src/udprelay.c
@@ -52,6 +52,7 @@
 #include "netutils.h"
 #include "cache.h"
 #include "udprelay.h"
+#include "probe.h"
 #include "winsock.h"
 #define MAX_UDP_CONN_NUM 256
 
@@ -67,7 +68,7 @@ static void server_recv_cb(EV_P_ ev_io *w, int revents);
 static void remote_recv_cb(EV_P_ ev_io *w, int revents);
 static void remote_timeout_cb(EV_P_ ev_timer *watcher, int revents);
 
-static char *hash_key(const int af, const struct sockaddr_storage *addr);
+static void hash_key_fill(char *out_key, const int af, const struct sockaddr_storage *addr);
 static void close_and_free_remote(EV_P_ remote_ctx_t *ctx);
 static remote_ctx_t *new_remote(int fd, server_ctx_t *server_ctx);
 
@@ -81,16 +82,6 @@ static server_ctx_t *server_ctx_list[MAX_REMOTE_NUM] = { NULL };
 
 const char *s_port = NULL;
 
-static int
-setnonblocking(int fd)
-{
-    int flags;
-    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
-        flags = 0;
-    }
-    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-}
-
 #ifdef SO_NOSIGPIPE
 static int
 set_nosigpipe(int socket_fd)
@@ -98,7 +89,6 @@ set_nosigpipe(int socket_fd)
     int opt = 1;
     return setsockopt(socket_fd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
 }
-
 #endif
 
 #ifndef IP_TRANSPARENT
@@ -125,157 +115,26 @@ set_nosigpipe(int socket_fd)
 #endif
 #endif
 
-static int
-get_dstaddr(struct msghdr *msg, struct sockaddr_storage *dstaddr)
-{
-    struct cmsghdr *cmsg;
-
-    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
-        if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVORIGDSTADDR) {
-            memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in));
-            dstaddr->ss_family = AF_INET;
-            return 0;
-        } else if (cmsg->cmsg_level == SOL_IPV6 && cmsg->cmsg_type == IPV6_RECVORIGDSTADDR) {
-            memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in6));
-            dstaddr->ss_family = AF_INET6;
-            return 0;
-        }
-    }
-
-    return 1;
-}
-
-#define HASH_KEY_LEN sizeof(struct sockaddr_storage) + sizeof(int)
-static char *
-hash_key(const int af, const struct sockaddr_storage *addr)
-{
-    size_t addr_len = sizeof(struct sockaddr_storage);
-    static char key[HASH_KEY_LEN];
-
-    memset(key, 0, HASH_KEY_LEN);
-    memcpy(key, &af, sizeof(int));
-    memcpy(key + sizeof(int), (const uint8_t *)addr, addr_len);
-
-    return key;
-}
+/* key length should match usage in cache (keep stable) */
+#define HASH_KEY_LEN (sizeof(struct sockaddr_storage) + sizeof(int))
 
-static int
-construct_udprelay_header(const struct sockaddr_storage *in_addr,
-                          char *addr_header)
-{
-    int addr_header_len = 0;
-
-    if (in_addr->ss_family == AF_INET) {
-        struct sockaddr_in *addr = (struct sockaddr_in *)in_addr;
-        size_t addr_len          = sizeof(struct in_addr);
-
-        addr_header[addr_header_len++] = 1;
-        memcpy(addr_header + addr_header_len, &addr->sin_addr, addr_len);
-        addr_header_len += addr_len;
-        memcpy(addr_header + addr_header_len, &addr->sin_port, 2);
-        addr_header_len += 2;
-    } else if (in_addr->ss_family == AF_INET6) {
-        struct sockaddr_in6 *addr = (struct sockaddr_in6 *)in_addr;
-        size_t addr_len           = sizeof(struct in6_addr);
-
-        addr_header[addr_header_len++] = 4;
-        memcpy(addr_header + addr_header_len, &addr->sin6_addr, addr_len);
-        addr_header_len += addr_len;
-        memcpy(addr_header + addr_header_len, &addr->sin6_port, 2);
-        addr_header_len += 2;
-    } else {
-        return 0;
-    }
-
-    return addr_header_len;
-}
-
-static int
-parse_udprelay_header(const char *buf, const size_t buf_len,
-                      char *host, char *port, struct sockaddr_storage *storage)
+/* Fill caller-provided buffer with key (no static buffer) */
+static void
+hash_key_fill(char *out_key, const int af, const struct sockaddr_storage *addr)
 {
-    const uint8_t atyp = *(uint8_t *)buf;
-    int offset         = 1;
-
-    // get remote addr and port
-    if ((atyp & ADDRTYPE_MASK) == 1) {
-        // IP V4
-        size_t in_addr_len = sizeof(struct in_addr);
-        if (buf_len >= in_addr_len + 3) {
-            if (storage != NULL) {
-                struct sockaddr_in *addr = (struct sockaddr_in *)storage;
-                addr->sin_family = AF_INET;
-                memcpy(&addr->sin_addr, buf + offset, sizeof(struct in_addr));
-                memcpy(&addr->sin_port, buf + offset + in_addr_len, sizeof(uint16_t));
-            }
-            if (host != NULL) {
-                inet_ntop(AF_INET, (const void *)(buf + offset),
-                          host, INET_ADDRSTRLEN);
-            }
-            offset += in_addr_len;
-        }
-    } else if ((atyp & ADDRTYPE_MASK) == 3) {
-        // Domain name
-        uint8_t name_len = *(uint8_t *)(buf + offset);
-        if (name_len + 4 <= buf_len) {
-            if (storage != NULL) {
-                char tmp[MAX_HOSTNAME_LEN] = { 0 };
-                struct cork_ip ip;
-                memcpy(tmp, buf + offset + 1, name_len);
-                if (cork_ip_init(&ip, tmp) != -1) {
-                    if (ip.version == 4) {
-                        struct sockaddr_in *addr = (struct sockaddr_in *)storage;
-                        inet_pton(AF_INET, tmp, &(addr->sin_addr));
-                        memcpy(&addr->sin_port, buf + offset + 1 + name_len, sizeof(uint16_t));
-                        addr->sin_family = AF_INET;
-                    } else if (ip.version == 6) {
-                        struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
-                        inet_pton(AF_INET, tmp, &(addr->sin6_addr));
-                        memcpy(&addr->sin6_port, buf + offset + 1 + name_len, sizeof(uint16_t));
-                        addr->sin6_family = AF_INET6;
-                    }
-                }
-            }
-            if (host != NULL) {
-                memcpy(host, buf + offset + 1, name_len);
-            }
-            offset += 1 + name_len;
-        }
-    } else if ((atyp & ADDRTYPE_MASK) == 4) {
-        // IP V6
-        size_t in6_addr_len = sizeof(struct in6_addr);
-        if (buf_len >= in6_addr_len + 3) {
-            if (storage != NULL) {
-                struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
-                addr->sin6_family = AF_INET6;
-                memcpy(&addr->sin6_addr, buf + offset, sizeof(struct in6_addr));
-                memcpy(&addr->sin6_port, buf + offset + in6_addr_len, sizeof(uint16_t));
-            }
-            if (host != NULL) {
-                inet_ntop(AF_INET6, (const void *)(buf + offset),
-                          host, INET6_ADDRSTRLEN);
-            }
-            offset += in6_addr_len;
-        }
-    }
-
-    if (offset == 1) {
-        LOGE("[udp] invalid header with addr type %d", atyp);
-        return 0;
-    }
-
-    if (port != NULL) {
-        sprintf(port, "%d", load16_be(buf + offset));
-    }
-    offset += 2;
-
-    return offset;
+    memset(out_key, 0, HASH_KEY_LEN);
+    memcpy(out_key, &af, sizeof(int));
+    memcpy(out_key + sizeof(int), (const uint8_t *)addr, sizeof(struct sockaddr_storage));
 }
 
-static char *
+char *
 get_addr_str(const struct sockaddr *sa, bool has_port)
 {
-    static char s[SS_ADDRSTRLEN];
+#ifdef __GNUC__
+    static __thread char s[SS_ADDRSTRLEN];
+#else
+    static _Thread_local char s[SS_ADDRSTRLEN];
+#endif
     memset(s, 0, SS_ADDRSTRLEN);
     char addr[INET6_ADDRSTRLEN] = { 0 };
     char port[PORTSTRLEN]       = { 0 };
@@ -317,38 +176,40 @@ get_addr_str(const struct sockaddr *sa, bool has_port)
 int
 create_remote_socket(int ipv6)
 {
-    int remote_sock;
+    int remote_sock = -1;
 
     if (ipv6) {
-        // Try to bind IPv6 first
-        struct sockaddr_in6 addr;
-        memset(&addr, 0, sizeof(struct sockaddr_in6));
-        addr.sin6_family = AF_INET6;
-        addr.sin6_addr   = in6addr_any;
-        addr.sin6_port   = 0;
-        remote_sock      = socket(AF_INET6, SOCK_DGRAM, 0);
+        struct sockaddr_in6 addr6;
+        memset(&addr6, 0, sizeof(addr6));
+        addr6.sin6_family = AF_INET6;
+        addr6.sin6_addr = in6addr_any;
+        addr6.sin6_port = 0;
+
+        remote_sock = socket(AF_INET6, SOCK_DGRAM, 0);
         if (remote_sock == -1) {
-            ERROR("[udp] cannot create socket");
+            ERROR("[udp] cannot create IPv6 socket");
             return -1;
         }
-        if (bind(remote_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
-            FATAL("[udp] cannot bind socket");
+        if (bind(remote_sock, (struct sockaddr *)&addr6, sizeof(addr6)) != 0) {
+            ERROR("[udp] cannot bind IPv6 socket");
+            close(remote_sock);
             return -1;
         }
     } else {
-        // Or else bind to IPv4
-        struct sockaddr_in addr;
-        memset(&addr, 0, sizeof(struct sockaddr_in));
-        addr.sin_family      = AF_INET;
-        addr.sin_addr.s_addr = INADDR_ANY;
-        addr.sin_port        = 0;
-        remote_sock          = socket(AF_INET, SOCK_DGRAM, 0);
+        struct sockaddr_in addr4;
+        memset(&addr4, 0, sizeof(addr4));
+        addr4.sin_family = AF_INET;
+        addr4.sin_addr.s_addr = INADDR_ANY;
+        addr4.sin_port = 0;
+
+        remote_sock = socket(AF_INET, SOCK_DGRAM, 0);
         if (remote_sock == -1) {
-            ERROR("[udp] cannot create socket");
+            ERROR("[udp] cannot create IPv4 socket");
             return -1;
         }
-        if (bind(remote_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
-            FATAL("[udp] cannot bind remote");
+        if (bind(remote_sock, (struct sockaddr *)&addr4, sizeof(addr4)) != 0) {
+            ERROR("[udp] cannot bind IPv4 socket");
+            close(remote_sock);
             return -1;
         }
     }
@@ -360,6 +221,7 @@ create_remote_socket(int ipv6)
     return remote_sock;
 }
 
+
 int
 create_server_socket(const char *host, const char *port)
 {
@@ -412,7 +274,11 @@ create_server_socket(const char *host, const char *port)
         }
 
         if (rp->ai_family == AF_INET6) {
-            int ipv6only = host ? 1 : 0;
+            // When binding to a specific host, enable IPV6_V6ONLY.
+            // When binding to a wildcard address (host is NULL), disable IPV6_V6ONLY
+            // to allow the socket to accept both IPv4 and IPv6 traffic.
+            // This is the standard way to create a dual-stack server socket.
+            int ipv6only = (host != NULL);
             setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));
         }
 
@@ -432,27 +298,35 @@ create_server_socket(const char *host, const char *port)
         int tos   = 46 << 2;
         int rc = setsockopt(server_sock, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
         if (rc < 0 && errno != ENOPROTOOPT) {
-            LOGE("setting ipv4 dscp failed: %d", errno);
+            ERROR("setting ipv4 dscp failed");
         }
 #ifdef IPV6_TCLASS
         rc = setsockopt(server_sock, IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos));
         if (rc < 0 && errno != ENOPROTOOPT) {
-            LOGE("setting ipv6 dscp failed: %d", errno);
+            ERROR("setting ipv6 dscp failed");
         }
 #endif
 #endif
 
-        int sol    = rp->ai_family == AF_INET ? SOL_IP : SOL_IPV6;
-        int flag_t = rp->ai_family == AF_INET ? IP_TRANSPARENT : IPV6_TRANSPARENT;
-        int flag_r = rp->ai_family == AF_INET ? IP_RECVORIGDSTADDR : IPV6_RECVORIGDSTADDR;
-
-        if (setsockopt(server_sock, sol, flag_t, &opt, sizeof(opt))) {
-            ERROR("[udp] setsockopt IP_TRANSPARENT");
-            exit(EXIT_FAILURE);
-        }
-
-        if (setsockopt(server_sock, sol, flag_r, &opt, sizeof(opt))) {
-            FATAL("[udp] setsockopt IP_RECVORIGDSTADDR");
+        /* For a dual-stack socket, we must set options for BOTH protocols */
+        if (rp->ai_family == AF_INET6 && host == NULL) {
+            if (setsockopt(server_sock, SOL_IPV6, IPV6_TRANSPARENT, &opt, sizeof(opt)) ||
+                setsockopt(server_sock, SOL_IP, IP_TRANSPARENT, &opt, sizeof(opt))) {
+                ERROR("[udp] setsockopt IP_TRANSPARENT for dual-stack failed");
+                goto next_addr;
+            }
+            if (setsockopt(server_sock, SOL_IPV6, IPV6_RECVORIGDSTADDR, &opt, sizeof(opt)) ||
+                setsockopt(server_sock, SOL_IP, IP_RECVORIGDSTADDR, &opt, sizeof(opt))) {
+                ERROR("[udp] setsockopt IP_RECVORIGDSTADDR for dual-stack failed");
+                goto next_addr;
+            }
+        } else { /* Single-stack socket */
+            int sol = rp->ai_family == AF_INET ? SOL_IP : SOL_IPV6;
+            if (setsockopt(server_sock, sol, rp->ai_family == AF_INET ? IP_TRANSPARENT : IPV6_TRANSPARENT, &opt, sizeof(opt)) ||
+                setsockopt(server_sock, sol, rp->ai_family == AF_INET ? IP_RECVORIGDSTADDR : IPV6_RECVORIGDSTADDR, &opt, sizeof(opt))) {
+                ERROR("[udp] setsockopt for TPROXY failed");
+                goto next_addr;
+            }
         }
 
         s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);
@@ -463,6 +337,7 @@ create_server_socket(const char *host, const char *port)
             ERROR("[udp] bind");
         }
 
+next_addr:
         close(server_sock);
         server_sock = -1;
     }
@@ -475,20 +350,26 @@ create_server_socket(const char *host, const char *port)
 
     return server_sock;
 }
-
+/* new_remote: 初始化 remote_ctx，remote_idx 初始来自 server_ctx->preferred_remote_idx */
 remote_ctx_t *
 new_remote(int fd, server_ctx_t *server_ctx)
 {
     remote_ctx_t *ctx = ss_malloc(sizeof(remote_ctx_t));
+    if (!ctx) {
+        ERROR("[udp] out of memory new_remote");
+        close(fd);
+        return NULL;
+    }
     memset(ctx, 0, sizeof(remote_ctx_t));
 
     ctx->fd         = fd;
     ctx->server_ctx = server_ctx;
     ctx->af         = AF_UNSPEC;
+    ctx->remote_idx = 0; /* Will be set properly when used */
+    ctx->state      = STATE_IDLE;
 
     ev_io_init(&ctx->io, remote_recv_cb, fd, EV_READ);
-    ev_timer_init(&ctx->watcher, remote_timeout_cb, server_ctx->timeout,
-                  server_ctx->timeout);
+    ev_timer_init(&ctx->watcher, remote_timeout_cb, server_ctx->timeout, server_ctx->timeout);
 
     return ctx;
 }
@@ -497,10 +378,10 @@ server_ctx_t *
 new_server_ctx(int fd)
 {
     server_ctx_t *ctx = ss_malloc(sizeof(server_ctx_t));
+    if (!ctx) return NULL;
     memset(ctx, 0, sizeof(server_ctx_t));
 
     ctx->fd = fd;
-
     ev_io_init(&ctx->io, server_recv_cb, fd, EV_READ);
 
     return ctx;
@@ -517,20 +398,6 @@ close_and_free_remote(EV_P_ remote_ctx_t *ctx)
     }
 }
 
-static void
-remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
-{
-    remote_ctx_t *remote_ctx
-        = cork_container_of(watcher, remote_ctx_t, watcher);
-
-    if (verbose) {
-        LOGI("[udp] connection timeout");
-    }
-
-    char *key = hash_key(remote_ctx->af, &remote_ctx->src_addr);
-    cache_remove(remote_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN);
-}
-
 void convert_ipv4_mapped_ipv6(struct sockaddr_storage* addr) {
     if (addr->ss_family == AF_INET) {
         struct sockaddr_in* ipv4_addr = (struct sockaddr_in*)addr;
@@ -554,122 +421,141 @@ void convert_ipv4_mapped_ipv6(struct sockaddr_storage* addr) {
     }
 }
 
+/* 当 remote 超时时，尝试将 listener 的 preferred_remote_idx 向后移动一位（failover），并删除 cache */
 static void
-remote_recv_cb(EV_P_ ev_io *w, int revents)
+remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
 {
-    ssize_t r;
-    remote_ctx_t *remote_ctx = (remote_ctx_t *)w;
+    remote_ctx_t *remote_ctx = cork_container_of(watcher, remote_ctx_t, watcher);
     server_ctx_t *server_ctx = remote_ctx->server_ctx;
 
-    // server has been closed
+    ev_timer_stop(EV_A_ & remote_ctx->watcher);
+
     if (server_ctx == NULL) {
-        LOGE("[udp] invalid server");
         close_and_free_remote(EV_A_ remote_ctx);
         return;
     }
 
+    if (remote_ctx->state == STATE_AWAITING_REPLY) {
+        const char *addr_str = get_addr_str(server_ctx->remote_addr[remote_ctx->remote_idx], true);
+        LOGI("[udprelay] session timed out for remote %d (%s) waiting for reply.", remote_ctx->remote_idx, addr_str);
+    } else {
+        if (verbose) LOGI("[udp] idle session timed out.");
+    }
+
     if (verbose) {
-        LOGI("[udp] remote receive a packet");
+        LOGI("[udp] connection timeout for src %s", get_addr_str((struct sockaddr *)&remote_ctx->src_addr, true));
+    }
+
+    /* 使用栈上的 key 以移除 cache 条目（触发 free_cb） */
+    char key[HASH_KEY_LEN];
+    hash_key_fill(key, remote_ctx->af, &remote_ctx->src_addr);
+    cache_remove(server_ctx->conn_cache, key, HASH_KEY_LEN);
+}
+
+/* remote recv: 收到从 remote 发回的加密数据，解密并发回对应的客户端地址 */
+static void
+remote_recv_cb(EV_P_ ev_io *w, int revents)
+{
+    /* safe container_of to get remote_ctx */
+    remote_ctx_t *remote_ctx = cork_container_of(w, remote_ctx_t, io);
+    server_ctx_t *server_ctx = remote_ctx->server_ctx;
+
+    if (server_ctx == NULL) {
+        LOGE("[udp] invalid server_ctx in remote_recv_cb");
+        close_and_free_remote(EV_A_ remote_ctx);
+        return;
     }
 
+    if (verbose) LOGI("[udp] remote receive a packet");
+
     struct sockaddr_storage src_addr;
-    socklen_t src_addr_len = sizeof(struct sockaddr_storage);
+    socklen_t src_addr_len = sizeof(src_addr);
     memset(&src_addr, 0, src_addr_len);
 
     buffer_t *buf = ss_malloc(sizeof(buffer_t));
     balloc(buf, buf_size);
 
-    // recv
-    r = recvfrom(remote_ctx->fd, buf->data, buf_size, 0, (struct sockaddr *)&src_addr, &src_addr_len);
-
+    ssize_t r = recvfrom(remote_ctx->fd, buf->data, buf_size, 0, (struct sockaddr *)&src_addr, &src_addr_len);
     if (r == -1) {
-        // error on recv
-        // simply drop that packet
         ERROR("[udp] remote_recv_recvfrom");
         goto CLEAN_UP;
-    } else if (r > packet_size) {
-        if (verbose) {
-            LOGI("[udp] remote_recv_recvfrom fragmentation, MTU at least be: " SSIZE_FMT, r + PACKET_HEADER_SIZE);
-        }
     }
-
+    if (r > packet_size && verbose) {
+        LOGI("[udp] remote_recv fragmentation: " SSIZE_FMT, r + PACKET_HEADER_SIZE);
+    }
     buf->len = r;
 
     int err = server_ctx->crypto->decrypt_all(buf, server_ctx->crypto->cipher, buf_size);
     if (err) {
-        LOGE("failed to handshake with %s: %s",
-                get_addr_str((struct sockaddr *)&src_addr, false), "suspicious UDP packet");
-        // drop the packet silently
+        LOGE("[udp] decrypt_all failed or suspicious packet from %s", get_addr_str((struct sockaddr *)&src_addr, true));
         goto CLEAN_UP;
     }
 
     struct sockaddr_storage dst_addr;
-    memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
+    memset(&dst_addr, 0, sizeof(dst_addr));
     int len = parse_udprelay_header(buf->data, buf->len, NULL, NULL, &dst_addr);
-
-    if (dst_addr.ss_family != AF_INET && dst_addr.ss_family != AF_INET6) {
-        LOGI("[udp] ss-redir does not support domain name");
-        goto CLEAN_UP;
-    }
-
     if (len == 0) {
-        // error when parsing header
-        LOGE("[udp] error in parse header");
+        LOGE("[udp] parse header failed in remote_recv_cb");
         goto CLEAN_UP;
     }
 
-    // Construct packet
     buf->len -= len;
     memmove(buf->data, buf->data + len, buf->len);
 
-    if (buf->len > packet_size) {
-        if (verbose) {
-            LOGI("[udp] remote_recv_sendto fragmentation, MTU at least be: " SSIZE_FMT, buf->len + PACKET_HEADER_SIZE);
-        }
+    if (buf->len > packet_size && verbose) {
+        LOGI("[udp] remote_sendto fragmentation MTU maybe: " SSIZE_FMT, buf->len + PACKET_HEADER_SIZE);
     }
 
     convert_ipv4_mapped_ipv6(&dst_addr);
 
     size_t remote_dst_addr_len = get_sockaddr_len((struct sockaddr *)&dst_addr);
 
-    int src_fd = socket(AF_INET6, SOCK_DGRAM, 0);
-    if (src_fd < 0) {
+    int reply_fd = socket(AF_INET6, SOCK_DGRAM, 0);
+    if (reply_fd < 0) {
         ERROR("[udp] remote_recv_socket");
         goto CLEAN_UP;
     }
     int opt = 1;
-    if (setsockopt(src_fd, SOL_IPV6, IPV6_TRANSPARENT, &opt, sizeof(opt))) {
+    if (setsockopt(reply_fd, SOL_IPV6, IPV6_TRANSPARENT, &opt, sizeof(opt))) {
         ERROR("[udp] remote_recv_setsockopt");
-        close(src_fd);
+        close(reply_fd);
         goto CLEAN_UP;
     }
-    if (setsockopt(src_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
+    // Allow binding to non-local IP addresses. This is essential for TPROXY
+    // to be able to send a reply with the original destination as the source.
+    if (setsockopt(reply_fd, SOL_IP, IP_FREEBIND, &opt, sizeof(opt))) {
+        ERROR("[udp] remote_recv_setsockopt IP_FREEBIND failed");
+        // This is not a fatal error on all systems, so we just log it.
+        // If bind() fails later, we will know for sure.
+        // On some systems, IP_TRANSPARENT implies IP_FREEBIND.
+    }
+    if (setsockopt(reply_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
         ERROR("[udp] remote_recv_setsockopt");
-        close(src_fd);
+        close(reply_fd);
         goto CLEAN_UP;
     }
     if (reuse_port) {
-        if (set_reuseport(src_fd) != 0) {
+        if (set_reuseport(reply_fd) != 0) {
             ERROR("[udp] remote_recv port_reuse");
         }
     }
 #ifdef IP_TOS
     // Set QoS flag
     int tos = 46 << 2;
-    int rc = setsockopt(src_fd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
+    int rc = setsockopt(reply_fd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
     if (rc < 0 && errno != ENOPROTOOPT) {
         LOGE("setting ipv4 dscp failed: %d", errno);
     }
 #ifdef IPV6_TCLASS
-    rc = setsockopt(src_fd, IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos));
+    rc = setsockopt(reply_fd, IPPROTO_IPV6, IPV6_TCLASS, &tos, sizeof(tos));
     if (rc < 0 && errno != ENOPROTOOPT) {
         LOGE("setting ipv6 dscp failed: %d", errno);
     }
 #endif
 #endif
-    if (bind(src_fd, (struct sockaddr *)&dst_addr, remote_dst_addr_len) != 0) {
+    if (bind(reply_fd, (struct sockaddr *)&dst_addr, remote_dst_addr_len) != 0) {
         ERROR("[udp] remote_recv_bind");
-        close(src_fd);
+        close(reply_fd);
         goto CLEAN_UP;
     }
 
@@ -679,21 +565,22 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
 
     size_t remote_src_addr_len = get_sockaddr_len((struct sockaddr *)&mapped_src_addr);
 
-    int s = sendto(src_fd, buf->data, buf->len, 0,
+    ssize_t s = sendto(reply_fd, buf->data, buf->len, 0,
                    (struct sockaddr *)&mapped_src_addr, remote_src_addr_len);
+
+    close(reply_fd);
+
     if (s == -1 && !(errno == EAGAIN || errno == EWOULDBLOCK)) {
-        ERROR("[udp] remote_recv_sendto");
-        close(src_fd);
-        goto CLEAN_UP;
+        ERROR("[udp] remote_recv sendto to client failed");
     }
-    close(src_fd);
 
-    // handle the UDP packet successfully,
-    // triger the timer
+    /* Mark as idle since we've successfully processed a reply */
+    remote_ctx->state = STATE_IDLE;
+
+    /* 成功收到回包後，重置 remote 的 watcher（延長可用時間） */
     ev_timer_again(EV_A_ & remote_ctx->watcher);
 
 CLEAN_UP:
-
     bfree(buf);
     ss_free(buf);
 }
@@ -702,160 +589,121 @@ CLEAN_UP:
 static void
 server_recv_cb(EV_P_ ev_io *w, int revents)
 {
-    server_ctx_t *server_ctx = (server_ctx_t *)w;
-    struct sockaddr_storage src_addr;
-    memset(&src_addr, 0, sizeof(struct sockaddr_storage));
+    /* get server_ctx by container_of (safer than casting) */
+    server_ctx_t *server_ctx = cork_container_of(w, server_ctx_t, io);
 
     buffer_t *buf = ss_malloc(sizeof(buffer_t));
     balloc(buf, buf_size);
 
-    socklen_t src_addr_len = sizeof(struct sockaddr_storage);
-    unsigned int offset    = 0;
-
-    char control_buffer[64] = { 0 };
-    struct msghdr msg;
-    memset(&msg, 0, sizeof(struct msghdr));
+    struct msghdr msgh;
     struct iovec iov[1];
-    struct sockaddr_storage dst_addr;
-    memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
+    char cbuf[CMSG_SPACE(sizeof(struct sockaddr_in6))];
+    struct sockaddr_storage src_addr, dst_addr;
+
+    memset(&src_addr, 0, sizeof(src_addr));
+    memset(&dst_addr, 0, sizeof(dst_addr));
 
-    msg.msg_name       = &src_addr;
-    msg.msg_namelen    = src_addr_len;
-    msg.msg_control    = control_buffer;
-    msg.msg_controllen = sizeof(control_buffer);
+    /* IMPORTANT: initialize msgh to zero to avoid uninitialized fields */
+    memset(&msgh, 0, sizeof(msgh));
 
     iov[0].iov_base = buf->data;
-    iov[0].iov_len  = buf_size;
-    msg.msg_iov     = iov;
-    msg.msg_iovlen  = 1;
+    iov[0].iov_len = buf_size;
 
-    buf->len = recvmsg(server_ctx->fd, &msg, 0);
-    if (buf->len == -1) {
-        ERROR("[udp] server_recvmsg");
-        goto CLEAN_UP;
-    } else if (buf->len > packet_size) {
-        if (verbose) {
-            LOGI("[udp] UDP server_recv_recvmsg fragmentation, MTU at least be: " SSIZE_FMT,
-                 buf->len + PACKET_HEADER_SIZE);
-        }
-    }
+    msgh.msg_name = &src_addr;
+    msgh.msg_namelen = sizeof(src_addr);
+    msgh.msg_iov = iov;
+    msgh.msg_iovlen = 1;
+    msgh.msg_control = cbuf;
+    msgh.msg_controllen = sizeof(cbuf);
+    msgh.msg_flags = 0;
 
-    if (get_dstaddr(&msg, &dst_addr)) {
-        LOGE("[udp] unable to get dest addr");
+    ssize_t r = recvmsg(server_ctx->fd, &msgh, 0);
+    if (r == -1) {
+        ERROR("[udp] server_recv_recvfrom");
         goto CLEAN_UP;
     }
 
-    src_addr_len = msg.msg_namelen;
+    if (r > packet_size && verbose) {
+        LOGI("[udp] server_recv_recvfrom fragmentation: " SSIZE_FMT, r + PACKET_HEADER_SIZE);
+    }
+    buf->len = r;
 
-    if (verbose) {
-        LOGI("[udp] server receive a packet");
+    struct cmsghdr *cmsg;
+    for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL; cmsg = CMSG_NXTHDR(&msgh, cmsg)) {
+        if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVORIGDSTADDR) {
+            memcpy(&dst_addr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in));
+        } else if (cmsg->cmsg_level == SOL_IPV6 && cmsg->cmsg_type == IPV6_RECVORIGDSTADDR) {
+            memcpy(&dst_addr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in6));
+        }
     }
 
-    /*
-     *
-     * SOCKS5 UDP Request
-     * +----+------+------+----------+----------+----------+
-     * |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
-     * +----+------+------+----------+----------+----------+
-     * | 2  |  1   |  1   | Variable |    2     | Variable |
-     * +----+------+------+----------+----------+----------+
-     *
-     * SOCKS5 UDP Response
-     * +----+------+------+----------+----------+----------+
-     * |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
-     * +----+------+------+----------+----------+----------+
-     * | 2  |  1   |  1   | Variable |    2     | Variable |
-     * +----+------+------+----------+----------+----------+
-     *
-     * shadowsocks UDP Request (before encrypted)
-     * +------+----------+----------+----------+
-     * | ATYP | DST.ADDR | DST.PORT |   DATA   |
-     * +------+----------+----------+----------+
-     * |  1   | Variable |    2     | Variable |
-     * +------+----------+----------+----------+
-     *
-     * shadowsocks UDP Response (before encrypted)
-     * +------+----------+----------+----------+
-     * | ATYP | DST.ADDR | DST.PORT |   DATA   |
-     * +------+----------+----------+----------+
-     * |  1   | Variable |    2     | Variable |
-     * +------+----------+----------+----------+
-     *
-     * shadowsocks UDP Request and Response (after encrypted)
-     * +-------+--------------+
-     * |   IV  |    PAYLOAD   |
-     * +-------+--------------+
-     * | Fixed |   Variable   |
-     * +-------+--------------+
-     *
-     */
+    if (dst_addr.ss_family == AF_UNSPEC) {
+        LOGE("[udp] could not get original destination address for TPROXY "
+             "(is it enabled and configured correctly?)");
+        goto CLEAN_UP;
+    }
 
-    char addr_header[MAX_ADDR_HEADER_SIZE] = { 0 };
-    int addr_header_len                    = construct_udprelay_header(&dst_addr, addr_header);
+    if (verbose) LOGI("[udp] server receive a packet from %s", get_addr_str((struct sockaddr *)&src_addr, true));
 
+    char addr_header[MAX_ADDR_HEADER_SIZE] = {0};
+    int addr_header_len = construct_udprelay_header(&dst_addr, addr_header);
     if (addr_header_len == 0) {
-        LOGE("[udp] failed to parse tproxy addr");
+        LOGE("[udp] failed to construct addr header (tproxy)");
         goto CLEAN_UP;
     }
-
-    // reconstruct the buffer
     brealloc(buf, buf->len + addr_header_len, buf_size);
     memmove(buf->data + addr_header_len, buf->data, buf->len);
     memcpy(buf->data, addr_header, addr_header_len);
     buf->len += addr_header_len;
 
-    char *key = hash_key(server_ctx->remote_addr->sa_family, &src_addr);
+    /* key: 用 src_addr + family 作为 cache key */
+    char key[HASH_KEY_LEN];
+    hash_key_fill(key, src_addr.ss_family, &src_addr);
 
     struct cache *conn_cache = server_ctx->conn_cache;
-
     remote_ctx_t *remote_ctx = NULL;
     cache_lookup(conn_cache, key, HASH_KEY_LEN, (void *)&remote_ctx);
 
-    if (remote_ctx != NULL) {
-        if (sockaddr_cmp(&src_addr, &remote_ctx->src_addr, sizeof(src_addr))) {
+    /* 校验 cache 里的 remote_ctx 是否属于相同的 src_addr（防止 hash 冲突） */
+    if (remote_ctx) {
+        if (sockaddr_cmp(&src_addr, &remote_ctx->src_addr, sizeof(src_addr)) != 0) {
+            /* 不同 src_addr 的 entry，不复用（hash 冲突） */
             remote_ctx = NULL;
         }
     }
 
-    // reset the timer
-    if (remote_ctx != NULL) {
+    if (remote_ctx) {
+        /* cache 命中：重置 timer */
         ev_timer_again(EV_A_ & remote_ctx->watcher);
-    }
+        if (verbose) LOGI("[udp] cache hit for %s", get_addr_str((struct sockaddr *)&src_addr, true));
+    } else {
+        if (verbose) LOGI("[udp] cache miss for %s, creating remote_ctx", get_addr_str((struct sockaddr *)&src_addr, true));
 
-    if (remote_ctx == NULL) {
-        if (verbose) {
-            char src[SS_ADDRSTRLEN];
-            char dst[SS_ADDRSTRLEN];
-            strcpy(src, get_addr_str((struct sockaddr *)&src_addr, true));
-            strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr, true));
-            LOGI("[%s] [udp] cache miss: %s <-> %s", s_port, dst, src);
+        /* Find first available remote */
+        int start_idx = -1;
+        for (int i = 0; i < server_ctx->remote_num; i++) {
+            if (server_ctx->remote_status[i]) {
+                start_idx = i;
+                break;
+            }
         }
-    } else {
-        if (verbose) {
-            char src[SS_ADDRSTRLEN];
-            char dst[SS_ADDRSTRLEN];
-            strcpy(src, get_addr_str((struct sockaddr *)&src_addr, true));
-            strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr, true));
-            LOGI("[%s] [udp] cache hit: %s <-> %s", s_port, dst, src);
+        if (start_idx == -1) {
+            LOGE("[udp] No remote servers available, dropping packet.");
+            goto CLEAN_UP;
         }
-    }
+        const struct sockaddr *start_remote_addr = server_ctx->remote_addr[start_idx];
+        int prefer_is_v6 = start_remote_addr->sa_family == AF_INET6 ? 1 : 0;
 
-    const struct sockaddr *remote_addr = server_ctx->remote_addr;
-    const int remote_addr_len          = server_ctx->remote_addr_len;
-
-    if (remote_ctx == NULL) {
-        // Bind to any port
-        int remotefd = create_remote_socket(remote_addr->sa_family == AF_INET6);
+        int remotefd = create_remote_socket(prefer_is_v6);
         if (remotefd < 0) {
-            ERROR("[udp] udprelay bind() error");
+            ERROR("[udp] create_remote_socket failed");
             goto CLEAN_UP;
         }
         setnonblocking(remotefd);
 
 #ifdef SO_MARK
         if (server_ctx->fwmark > 0) {
-            if (setsockopt(remotefd, SOL_SOCKET, SO_MARK, &server_ctx->fwmark,
-                           sizeof(server_ctx->fwmark)) != 0) {
+            if (setsockopt(remotefd, SOL_SOCKET, SO_MARK, &server_ctx->fwmark, sizeof(server_ctx->fwmark)) != 0) {
                 ERROR("setsockopt SO_MARK");
             }
         }
@@ -864,6 +712,7 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
 #ifdef SO_NOSIGPIPE
         set_nosigpipe(remotefd);
 #endif
+
 #ifdef IP_TOS
         // Set QoS flag
         int tos = 46 << 2;
@@ -878,108 +727,148 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
         }
 #endif
 #endif
+
 #ifdef SET_INTERFACE
-        if (server_ctx->iface) {
-            if (setinterface(remotefd, server_ctx->iface) == -1)
-                ERROR("setinterface");
+        if (server_ctx->iface && strlen(server_ctx->iface) > 0) {
+            if (setinterface(remotefd, server_ctx->iface) == -1) ERROR("setinterface");
         }
 #endif
 
-        // Init remote_ctx
-        remote_ctx           = new_remote(remotefd, server_ctx);
-        remote_ctx->src_addr = src_addr;
-        remote_ctx->af       = remote_addr->sa_family;
+        /* 新建 remote_ctx */
+        remote_ctx = new_remote(remotefd, server_ctx);
+        if (!remote_ctx) {
+            close(remotefd);
+            goto CLEAN_UP;
+        }
+        remote_ctx->src_addr = src_addr; /* 保存客户端地址 */
+        remote_ctx->af = src_addr.ss_family;
+        remote_ctx->remote_idx = start_idx;
 
-        // Add to conn cache
+        /* 插入 cache（cache 应复制 key 内容） */
         cache_insert(conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
 
-        // Start remote io
         ev_io_start(EV_A_ & remote_ctx->io);
         ev_timer_start(EV_A_ & remote_ctx->watcher);
     }
 
-    if (offset > 0) {
-        buf->len -= offset;
-        memmove(buf->data, buf->data + offset, buf->len);
+    /*
+     * If the remote for this session is now offline, we must failover.
+     * This is an "in-session" failover.
+     */
+    if (!server_ctx->remote_status[remote_ctx->remote_idx]) {
+        int next_idx = -1;
+        for (int i = 0; i < server_ctx->remote_num; i++) {
+            if (server_ctx->remote_status[i]) {
+                next_idx = i;
+                break;
+            }
+        }
+        if (next_idx != -1) {
+            LOGI("[udp] in-session failover for %s: %d -> %d", get_addr_str((struct sockaddr *)&src_addr, true), remote_ctx->remote_idx, next_idx);
+            remote_ctx->remote_idx = next_idx;
+        }
     }
+    const struct sockaddr *remote_addr = server_ctx->remote_addr[remote_ctx->remote_idx];
+    int remote_addr_len = get_sockaddr_len((struct sockaddr *)remote_addr);
 
+    /* 对 payload 进行加密 */
     int err = server_ctx->crypto->encrypt_all(buf, server_ctx->crypto->cipher, buf_size);
-
     if (err) {
-        // drop the packet silently
+        LOGE("[udp] encrypt_all failed, drop packet");
         goto CLEAN_UP;
     }
 
-    if (buf->len > packet_size) {
-        if (verbose) {
-            LOGI("[udp] server_recv_sendto fragmentation, MTU at least be: " SSIZE_FMT, buf->len + PACKET_HEADER_SIZE);
-        }
+    if (buf->len > packet_size && verbose) {
+        LOGI("[udp] sending possibly fragmented UDP packet to remote (len=%d)", (int)buf->len);
     }
 
     int s = sendto(remote_ctx->fd, buf->data, buf->len, 0, remote_addr, remote_addr_len);
-
+    if (remote_ctx) remote_ctx->state = STATE_AWAITING_REPLY;
     if (s == -1) {
-        ERROR("[udp] server_recv_sendto");
+        if (errno == EMSGSIZE) {
+            LOGE("[udp] server->sendto to remote failed: Message too large (packet size: %zu, current MTU setting leads to max payload: %d)",
+                 buf->len, packet_size);
+        }
+        if (errno != EAGAIN && errno != EWOULDBLOCK) {
+            ERROR("[udp] server->sendto to remote failed");
+            /* If send fails immediately, mark remote as down and destroy this session */
+            if (server_ctx->remote_num > 1) {
+                /* Remove from cache to force re-creation on next packet */
+                char key_to_remove[HASH_KEY_LEN];
+                hash_key_fill(key_to_remove, remote_ctx->af, &remote_ctx->src_addr);
+                cache_remove(conn_cache, key_to_remove, HASH_KEY_LEN);
+                remote_ctx = NULL; /* Prevent timer reset below */
+            }
+        } else {
+            /* send succeeded */
+        }
     }
 
 CLEAN_UP:
     bfree(buf);
     ss_free(buf);
+    return;
 }
 
+/* cache free callback: 由 cache 在删除条目时调用（移除 remote_ctx） */
 void
 free_cb(void *key, void *element)
 {
     remote_ctx_t *remote_ctx = (remote_ctx_t *)element;
-    if (verbose) {
-        LOGI("[udp] one connection freed");
-    }
-
-    close_and_free_remote(EV_DEFAULT, remote_ctx);
+    if (verbose) LOGI("[udp] freeing remote_ctx %p", (void *)remote_ctx);
+    if (remote_ctx) close_and_free_remote(EV_DEFAULT, remote_ctx);
 }
 
+/* 初始化 udprelay，支持多个 remote_addr，记录 preferred_remote_idx 并注册 failback timer */
 int
-init_udprelay(const char *server_host, const char *server_port,
-              const struct sockaddr *remote_addr, const int remote_addr_len,
-              int mtu, crypto_t *crypto, int timeout, const char *iface, int fwmark)
+init_udprelay(const char *server_host, const char *server_port, int remote_num,
+              struct sockaddr **remote_addr, int mtu, crypto_t *crypto,
+              int timeout, const char *iface, int fwmark,
+              volatile bool *remote_status)
 {
     s_port = server_port;
-    // Initialize ev loop
     struct ev_loop *loop = EV_DEFAULT;
 
-    // Initialize MTU
+    /*
+     * Adjust packet_size calculation to account for AEAD overhead (salt + tag).
+     * This provides a more accurate upper bound for the original payload.
+     * We assume a common case (e.g., chacha20-ietf-poly1305: 32-byte salt, 16-byte tag).
+     */
     if (mtu > 0) {
-        packet_size = mtu - PACKET_HEADER_SIZE;
-        buf_size    = packet_size * 2;
+        packet_size = mtu - PACKET_HEADER_SIZE - crypto->cipher->key_len - crypto->cipher->tag_len;
+        buf_size = packet_size * 2;
     }
 
-    // ////////////////////////////////////////////////
-    // Setup server context
-
-    // Bind to port
     int serverfd = create_server_socket(server_host, server_port);
-    if (serverfd < 0) {
-        return -1;
-    }
+    if (serverfd < 0) return -1;
     setnonblocking(serverfd);
 
-    // Initialize cache
-    struct cache *conn_cache;
+    struct cache *conn_cache = NULL;
     cache_create(&conn_cache, MAX_UDP_CONN_NUM, free_cb);
 
     server_ctx_t *server_ctx = new_server_ctx(serverfd);
-    server_ctx->timeout    = max(timeout, MIN_UDP_TIMEOUT);
-    server_ctx->crypto     = crypto;
-    server_ctx->iface      = iface;
+    if (!server_ctx) {
+        close(serverfd);
+        return -1;
+    }
+
+    server_ctx->timeout = max(timeout, MIN_UDP_TIMEOUT);
+    server_ctx->crypto = crypto;
+    server_ctx->iface = iface;
     server_ctx->conn_cache = conn_cache;
     server_ctx->fwmark = fwmark;
-    server_ctx->remote_addr     = remote_addr;
-    server_ctx->remote_addr_len = remote_addr_len;
+    server_ctx->remote_num = remote_num;
+    server_ctx->remote_addr = remote_addr;
+    server_ctx->remote_status = remote_status;
 
     ev_io_start(loop, &server_ctx->io);
 
-    server_ctx_list[server_num++] = server_ctx;
-
+    if (server_num < MAX_REMOTE_NUM) {
+        server_ctx_list[server_num++] = server_ctx;
+    } else {
+        LOGE("[udp] too many server instances");
+    }
+    probe_add_udp_server(server_ctx);
     return serverfd;
 }
 
@@ -990,6 +879,9 @@ free_udprelay()
     while (server_num > 0) {
         server_ctx_t *server_ctx = server_ctx_list[--server_num];
         ev_io_stop(loop, &server_ctx->io);
+        /* Use a temporary variable to hold the pointer for ss_free */
+        void *status_ptr = (void *)server_ctx->remote_status;
+        ss_free(status_ptr);
         close(server_ctx->fd);
         cache_delete(server_ctx->conn_cache, 0);
 #ifdef MODULE_LOCAL
diff --git a/src/udprelay.h b/src/udprelay.h
index 8f071dc..335191e 100644
--- a/src/udprelay.h
+++ b/src/udprelay.h
@@ -51,18 +51,28 @@ typedef struct server_ctx {
     int timeout;
     const char *iface;
     struct cache *conn_cache;
-    const struct sockaddr *remote_addr;
-    int remote_addr_len;
+    int remote_num;
+    struct sockaddr **remote_addr;
     int fwmark;
+    volatile bool *remote_status;
 } server_ctx_t;
 
+typedef enum {
+    STATE_IDLE,
+    STATE_AWAITING_REPLY
+} remote_state_t;
+
 typedef struct remote_ctx {
     ev_io io;
     ev_timer watcher;
     int af;
     int fd;
     struct sockaddr_storage src_addr;
-    struct server_ctx *server_ctx;
+    remote_state_t state;
+    server_ctx_t *server_ctx;
+    int remote_idx;
 } remote_ctx_t;
 
+char *get_addr_str(const struct sockaddr *sa, bool has_port);
+
 #endif // _UDPRELAY_H
diff --git a/src/utils.c b/src/utils.c
index ff4a16b..8b7415a 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -65,6 +65,16 @@ ERROR(const char *s)
 
 int use_tty = 1;
 
+int
+setnonblocking(int fd)
+{
+    int flags;
+    if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
+        flags = 0;
+    }
+    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
+}
+
 char *
 ss_itoa(int i)
 {
@@ -364,6 +374,16 @@ usage()
         "       [--plugin-opts <options>]  Set SIP003 plugin options. (Experimental)\n");
     printf(
         "       [--fwmark <mark>]          Set firewall mark for outgoing packets.\n");
+    printf(
+        "       [--probe-interval <secs>]  Interval in seconds for active remote server probing (default: 60).\n");
+    printf(
+        "       [--probe-timeout <secs>]   Timeout in seconds for active remote server probing (default: 5).\n");
+    printf(
+        "       [--probe-up-count <cnt>]   Success count to mark a remote as up (default: 3).\n");
+    printf(
+        "       [--probe-down-count <cnt>] Failure count to mark a remote as down (default: 3).\n");
+    printf(
+        "       [--probe-domain <domain>]  Domain to use for probing (default: www.google.com).\n");
     printf("\n");
     printf(
         "       [-v]                       Verbose mode.\n");
@@ -504,6 +524,15 @@ load16_be(const void *s)
            | ((uint16_t)in[1]);
 }
 
+void
+store16_be(uint16_t val, uint8_t *s)
+{
+    if (s != NULL) {
+        s[0] = (val >> 8) & 0xff;
+        s[1] = val & 0xff;
+    }
+}
+
 int
 get_mptcp(int enable)
 {
diff --git a/src/utils.h b/src/utils.h
index 1df24c1..bd82472 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -222,6 +222,7 @@ int run_as(const char *user);
 void FATAL(const char *msg);
 void usage(void);
 void daemonize(const char *path);
+int setnonblocking(int fd);
 char *ss_strndup(const char *s, size_t n);
 #ifdef HAVE_SETRLIMIT
 int set_nofile(int nofile);
@@ -250,6 +251,7 @@ void *ss_realloc(void *ptr, size_t new_size);
 int ss_is_ipv6addr(const char *addr);
 char *get_default_conf(void);
 uint16_t load16_be(const void *s);
+void store16_be(uint16_t val, uint8_t *s);
 int get_mptcp(int enable);
 
 #endif // _UTILS_H
-- 
2.37.1 (Apple Git-137.1)

