From 85615acf2dbfcd6c19a6466b6d8d0d1534d211ab Mon Sep 17 00:00:00 2001
From: zhenglixin <lixin.zhenglx@gmail.com>
Date: Thu, 25 Sep 2025 15:18:23 +0800
Subject: [PATCH 6/6] add module prefix in log message

---
 src/aead.c     |  38 ++++++------
 src/crypto.c   |  20 +++----
 src/jconf.c    |  22 +++----
 src/metrics.c  |  10 ++--
 src/netutils.c |  18 +++---
 src/plugin.c   |   4 +-
 src/redir.c    | 153 ++++++++++++++++++++++++-------------------------
 src/stream.c   |  40 ++++++-------
 src/udprelay.c |   4 +-
 src/utils.c    |  18 +++---
 10 files changed, 159 insertions(+), 168 deletions(-)

diff --git a/src/aead.c b/src/aead.c
index 73349da..cbca1a9 100644
--- a/src/aead.c
+++ b/src/aead.c
@@ -271,7 +271,7 @@ const cipher_kt_t *
 aead_get_cipher_type(int method)
 {
     if (method < AES128GCM || method >= AEAD_CIPHER_NUM) {
-        LOGE("aead_get_cipher_type(): Illegal method");
+        LOGE("[aead] aead_get_cipher_type(): Illegal method");
         return NULL;
     }
 
@@ -283,7 +283,7 @@ aead_get_cipher_type(int method)
     const char *ciphername  = supported_aead_ciphers[method];
     const char *mbedtlsname = supported_aead_ciphers_mbedtls[method];
     if (strcmp(mbedtlsname, CIPHER_UNSUPPORTED) == 0) {
-        LOGE("Cipher %s currently is not supported by mbed TLS library",
+        LOGE("[aead] cipher %s currently is not supported by mbed TLS library",
              ciphername);
         return NULL;
     }
@@ -295,7 +295,7 @@ aead_cipher_ctx_set_key(cipher_ctx_t *cipher_ctx, int enc)
 {
     const digest_type_t *md = mbedtls_md_info_from_string("SHA1");
     if (md == NULL) {
-        FATAL("SHA1 Digest not found in crypto library");
+        FATAL("[aead] SHA1 Digest not found in crypto library");
     }
 
     int err = crypto_hkdf(md,
@@ -304,7 +304,7 @@ aead_cipher_ctx_set_key(cipher_ctx_t *cipher_ctx, int enc)
                           (uint8_t *)SUBKEY_INFO, strlen(SUBKEY_INFO),
                           cipher_ctx->skey, cipher_ctx->cipher->key_len);
     if (err) {
-        FATAL("Unable to generate subkey");
+        FATAL("[aead] unable to generate subkey");
     }
 
     memset(cipher_ctx->nonce, 0, cipher_ctx->cipher->nonce_len);
@@ -316,16 +316,16 @@ aead_cipher_ctx_set_key(cipher_ctx_t *cipher_ctx, int enc)
     if (cipher_ctx->aes256gcm_ctx != NULL) {
         if (crypto_aead_aes256gcm_beforenm(cipher_ctx->aes256gcm_ctx,
                                            cipher_ctx->skey) != 0) {
-            FATAL("Cannot set libsodium cipher key");
+            FATAL("[aead] cannot set libsodium cipher key");
         }
         return;
     }
     if (mbedtls_cipher_setkey(cipher_ctx->evp, cipher_ctx->skey,
                               cipher_ctx->cipher->key_len * 8, enc) != 0) {
-        FATAL("Cannot set mbed TLS cipher key");
+        FATAL("[aead] cannot set mbed TLS cipher key");
     }
     if (mbedtls_cipher_reset(cipher_ctx->evp) != 0) {
-        FATAL("Cannot finish preparation of mbed TLS cipher context");
+        FATAL("[aead] cannot finish preparation of mbed TLS cipher context");
     }
 }
 
@@ -333,7 +333,7 @@ static void
 aead_cipher_ctx_init(cipher_ctx_t *cipher_ctx, int method, int enc)
 {
     if (method < AES128GCM || method >= AEAD_CIPHER_NUM) {
-        LOGE("cipher_context_init(): Illegal method");
+        LOGE("[aead] cipher_context_init(): Illegal method");
         return;
     }
 
@@ -355,13 +355,13 @@ aead_cipher_ctx_init(cipher_ctx_t *cipher_ctx, int method, int enc)
         cipher_evp_t *evp = cipher_ctx->evp;
         mbedtls_cipher_init(evp);
         if (mbedtls_cipher_setup(evp, cipher) != 0) {
-            FATAL("Cannot initialize mbed TLS cipher context");
+            FATAL("[aead] cannot initialize mbed TLS cipher context");
         }
     }
 
     if (cipher == NULL) {
-        LOGE("Cipher %s not found in mbed TLS library", ciphername);
-        FATAL("Cannot initialize mbed TLS cipher");
+        LOGE("[aead] cipher %s not found in mbed TLS library", ciphername);
+        FATAL("[aead] cannot initialize mbed TLS cipher");
     }
 
 #ifdef SS_DEBUG
@@ -470,7 +470,7 @@ aead_decrypt_all(buffer_t *ciphertext, cipher_t *cipher, size_t capacity)
     memcpy(salt, ciphertext->data, salt_len);
 
     if (ppbloom_check((void *)salt, salt_len) == 1) {
-        LOGE("crypto: AEAD: repeat salt detected");
+        LOGE("[aead] crypto: AEAD: repeat salt detected");
         return CRYPTO_ERROR;
     }
 
@@ -663,7 +663,7 @@ aead_decrypt(buffer_t *ciphertext, cipher_ctx_t *cipher_ctx, size_t capacity)
         memcpy(cipher_ctx->salt, cipher_ctx->chunk->data, salt_len);
 
         if (ppbloom_check((void *)cipher_ctx->salt, salt_len) == 1) {
-            LOGE("crypto: AEAD: repeat salt detected");
+            LOGE("[aead] crypto: AEAD: repeat salt detected");
             return CRYPTO_ERROR;
         }
 
@@ -705,7 +705,7 @@ aead_decrypt(buffer_t *ciphertext, cipher_ctx_t *cipher_ctx, size_t capacity)
     // Add the salt to bloom filter
     if (cipher_ctx->init == 1) {
         if (ppbloom_check((void *)cipher_ctx->salt, salt_len) == 1) {
-            LOGE("crypto: AEAD: repeat salt detected");
+            LOGE("[aead] crypto: AEAD: repeat salt detected");
             return CRYPTO_ERROR;
         }
         ppbloom_add((void *)cipher_ctx->salt, salt_len);
@@ -723,7 +723,7 @@ cipher_t *
 aead_key_init(int method, const char *pass, const char *key)
 {
     if (method < AES128GCM || method >= AEAD_CIPHER_NUM) {
-        LOGE("aead_key_init(): Illegal method");
+        LOGE("[aead] aead_key_init(): Illegal method");
         return NULL;
     }
 
@@ -731,8 +731,8 @@ aead_key_init(int method, const char *pass, const char *key)
     memset(cipher, 0, sizeof(cipher_t));
 
     if (method < CHACHA20POLY1305IETF && aead_get_cipher_type(method) == NULL) {
-        LOGE("Cipher %s not found in crypto library", supported_aead_ciphers[method]);
-        FATAL("Cannot initialize cipher");
+        LOGE("[aead] cipher %s not found in crypto library", supported_aead_ciphers[method]);
+        FATAL("[aead] cannot initialize cipher");
     }
 
     if (key != NULL)
@@ -743,7 +743,7 @@ aead_key_init(int method, const char *pass, const char *key)
                                             supported_aead_ciphers_key_size[method]);
 
     if (cipher->key_len == 0) {
-        FATAL("Cannot generate key and nonce");
+        FATAL("[aead] cannot generate key and nonce");
     }
 
     cipher->nonce_len = supported_aead_ciphers_nonce_size[method];
@@ -764,7 +764,7 @@ aead_init(const char *pass, const char *key, const char *method)
                 break;
             }
         if (m >= AEAD_CIPHER_NUM) {
-            LOGE("Invalid cipher name: %s, use chacha20-ietf-poly1305 instead", method);
+            LOGE("[aead] invalid cipher name: %s, use chacha20-ietf-poly1305 instead", method);
             m = CHACHA20POLY1305IETF;
         }
     }
diff --git a/src/crypto.c b/src/crypto.c
index d8a554e..8295930 100644
--- a/src/crypto.c
+++ b/src/crypto.c
@@ -105,7 +105,7 @@ crypto_md5(const unsigned char *d, size_t n, unsigned char *md)
     }
 #if MBEDTLS_VERSION_NUMBER < 0x03000000 && MBEDTLS_VERSION_NUMBER >= 0x02070000
     if (mbedtls_md5_ret(d, n, md) != 0)
-        FATAL("Failed to calculate MD5");
+        FATAL("[crypto] failed to calculate MD5");
 #else
     mbedtls_md5(d, n, md);
 #endif
@@ -121,7 +121,7 @@ entropy_check(void)
 
     if ((fd = open("/dev/random", O_RDONLY)) != -1) {
         if (ioctl(fd, RNDGETENTCNT, &c) == 0 && c < 160) {
-            LOGI("This system doesn't provide enough entropy to quickly generate high-quality random numbers.\n"
+            LOGI("[crypto] This system doesn't provide enough entropy to quickly generate high-quality random numbers.\n"
                  "Installing the rng-utils/rng-tools, jitterentropy or haveged packages may help.\n"
                  "On virtualized Linux environments, also consider using virtio-rng.\n"
                  "The service will not start until enough entropy has been collected.\n");
@@ -139,7 +139,7 @@ crypto_init(const char *password, const char *key, const char *method)
     entropy_check();
     // Initialize sodium for random generator
     if (sodium_init() == -1) {
-        FATAL("Failed to initialize sodium");
+        FATAL("[crypto] failed to initialize sodium");
     }
 
     // Initialize NONCE bloom filter
@@ -152,7 +152,7 @@ crypto_init(const char *password, const char *key, const char *method)
                 break;
             }
         if (m != -1) {
-            LOGI("Stream ciphers are insecure, therefore deprecated, and should be almost always avoided.");
+            LOGI("[crypto] stream ciphers are insecure, therefore deprecated, and should be almost always avoided.");
             cipher_t *cipher = stream_init(password, key, method);
             if (cipher == NULL)
                 return NULL;
@@ -194,7 +194,7 @@ crypto_init(const char *password, const char *key, const char *method)
         }
     }
 
-    LOGE("invalid cipher name: %s", method);
+    LOGE("[crypto] invalid cipher name: %s", method);
     return NULL;
 }
 
@@ -206,7 +206,7 @@ crypto_derive_key(const char *pass, uint8_t *key, size_t key_len)
 
     const digest_type_t *md = mbedtls_md_info_from_string("MD5");
     if (md == NULL) {
-        FATAL("MD5 Digest not found in crypto library");
+        FATAL("[crypto] MD5 Digest not found in crypto library");
     }
 
     mbedtls_md_context_t c;
@@ -368,10 +368,10 @@ crypto_parse_key(const char *base64, uint8_t *key, size_t key_len)
     char out_key[out_len];
     rand_bytes(key, key_len);
     base64_encode(out_key, out_len, key, key_len);
-    LOGE("Invalid key for your chosen cipher!");
-    LOGE("It requires a " SIZE_FMT "-byte key encoded with URL-safe Base64", key_len);
-    LOGE("Generating a new random key: %s", out_key);
-    FATAL("Please use the key above or input a valid key");
+    LOGE("[crypto] Invalid key for your chosen cipher!");
+    LOGE("[crypto] It requires a " SIZE_FMT "-byte key encoded with URL-safe Base64", key_len);
+    LOGE("[crypto] Generating a new random key: %s", out_key);
+    FATAL("[crypto] Please use the key above or input a valid key");
     return key_len;
 }
 
diff --git a/src/jconf.c b/src/jconf.c
index c75a3ae..4a7769b 100644
--- a/src/jconf.c
+++ b/src/jconf.c
@@ -49,8 +49,8 @@ to_string(const json_value *value)
     } else if (value->type == json_null) {
         return NULL;
     } else {
-        LOGE("%d", value->type);
-        FATAL("Invalid config format.");
+        LOGE("[jconf] %d", value->type);
+        FATAL("[jconf] invalid config format.");
     }
     return 0;
 }
@@ -148,7 +148,7 @@ parse_dscp(char *str)
         return dscp;
     }
 
-    LOGE("Invalid DSCP value (%s)", str);
+    LOGE("[jconf] invalid DSCP value (%s)", str);
     return DSCP_DEFAULT;
 }
 
@@ -167,7 +167,7 @@ read_jconf(const char *file)
 
     FILE *f = fopen(file, "rb");
     if (f == NULL) {
-        FATAL("Invalid config path.");
+        FATAL("[jconf] invalid config path.");
     }
 
     fseek(f, 0, SEEK_END);
@@ -175,21 +175,21 @@ read_jconf(const char *file)
     fseek(f, 0, SEEK_SET);
 
     if (pos < 0) {
-        FATAL("Invalid config path.");
+        FATAL("[jconf] invalid config path.");
     }
 
     if (pos >= MAX_CONF_SIZE) {
-        FATAL("Too large config file.");
+        FATAL("[jconf] too large config file.");
     }
 
     buf = ss_malloc(pos + 1);
     if (buf == NULL) {
-        FATAL("No enough memory.");
+        FATAL("[jconf] no enough memory.");
     }
 
     int nread = fread(buf, pos, 1, f);
     if (!nread) {
-        FATAL("Failed to read the config file.");
+        FATAL("[jconf] failed to read the config file.");
     }
     fclose(f);
 
@@ -294,7 +294,7 @@ read_jconf(const char *file)
                                       "invalid config file: option 'tcp_outgoing_rcvbuf' must be an integer");
                 conf.tcp_outgoing_rcvbuf = value->u.integer;
             } else if (strcmp(name, "auth") == 0) {
-                FATAL("One time auth has been deprecated. Try AEAD ciphers instead.");
+                FATAL("[jconf] one time auth has been deprecated. Try AEAD ciphers instead.");
             } else if (strcmp(name, "nofile") == 0) {
                 check_json_value_type(value, json_integer,
                                       "invalid config file: option 'nofile' must be an integer");
@@ -330,7 +330,7 @@ read_jconf(const char *file)
                 else if (strcmp(mode_str, "udp_only") == 0)
                     conf.mode = UDP_ONLY;
                 else
-                    LOGI("ignore unknown mode: %s, use tcp_only as fallback",
+                    LOGI("[jconf] ignore unknown mode: %s, use tcp_only as fallback",
                          mode_str);
 
                 ss_free(mode_str);
@@ -401,7 +401,7 @@ read_jconf(const char *file)
             }
         }
     } else {
-        FATAL("Invalid config file");
+        FATAL("[jconf] invalid config file");
     }
 
     ss_free(buf);
diff --git a/src/metrics.c b/src/metrics.c
index a0c0c61..e7a1106 100644
--- a/src/metrics.c
+++ b/src/metrics.c
@@ -256,7 +256,7 @@ metrics_init(EV_P_ const char *addr, uint16_t port, int remote_num, time_t start
 
     metrics_fd = socket(AF_INET, SOCK_STREAM, 0);
     if (metrics_fd == -1) {
-        ERROR("metrics: socket");
+        ERROR("[metrics] failed to create socket");
         return;
     }
 
@@ -269,21 +269,21 @@ metrics_init(EV_P_ const char *addr, uint16_t port, int remote_num, time_t start
     sock_addr.sin_family = AF_INET;
     sock_addr.sin_port = htons(port);
     if (inet_pton(AF_INET, addr, &sock_addr.sin_addr) <= 0) {
-        ERROR("metrics: inet_pton");
+        ERROR("[metrics] inet_pton");
         close(metrics_fd);
         metrics_fd = -1;
         return;
     }
 
     if (bind(metrics_fd, (struct sockaddr *)&sock_addr, sizeof(sock_addr)) != 0) {
-        ERROR("metrics: bind");
+        ERROR("[metrics] bind");
         close(metrics_fd);
         metrics_fd = -1;
         return;
     }
 
     if (listen(metrics_fd, SOMAXCONN) != 0) {
-        ERROR("metrics: listen");
+        ERROR("[metrics] listen");
         close(metrics_fd);
         metrics_fd = -1;
         return;
@@ -292,7 +292,7 @@ metrics_init(EV_P_ const char *addr, uint16_t port, int remote_num, time_t start
     ev_io_init(&metrics_watcher, metrics_accept_cb, metrics_fd, EV_READ);
     ev_io_start(EV_A_ &metrics_watcher);
 
-    LOGI("Metrics server started on %s:%d", addr, port);
+    LOGI("[metrics] metrics server started on %s:%d", addr, port);
 }
 
 void
diff --git a/src/netutils.c b/src/netutils.c
index af41624..88de888 100644
--- a/src/netutils.c
+++ b/src/netutils.c
@@ -172,7 +172,7 @@ parse_udprelay_header(const char *buf, const size_t buf_len,
         size_t in_addr_len = sizeof(struct in_addr);
         /* need: 1 (atyp) + in_addr_len + 2 (port) */
         if (!REMAIN_AT_LEAST(in_addr_len + 2)) {
-            LOGE("[udp] parse header: IPv4 header too short");
+            LOGE("parse header: IPv4 header too short");
             return 0;
         }
         if (storage != NULL) {
@@ -191,18 +191,18 @@ parse_udprelay_header(const char *buf, const size_t buf_len,
     } else if ((atyp & ADDRTYPE_MASK) == 3) {
         /* Domain name */
         if (!REMAIN_AT_LEAST(1)) {
-            LOGE("[udp] parse header: domain length byte missing");
+            LOGE("parse header: domain length byte missing");
             return 0;
         }
         uint8_t name_len = *(const uint8_t *)(buf + offset);
         /* total needed: 1 (atyp) + 1 (name_len) + name_len + 2 (port) */
         if (!REMAIN_AT_LEAST(1 + name_len + 2)) {
-            LOGE("[udp] parse header: domain header too short (name_len=%d, buf_len=%zu)", name_len, buf_len);
+            LOGE("parse header: domain header too short (name_len=%d, buf_len=%zu)", name_len, buf_len);
             return 0;
         }
         /* guard tmp buffer size */
         if (name_len >= MAX_HOSTNAME_LEN) {
-            LOGE("[udp] parse header: domain name too long (%d >= %d)", name_len, MAX_HOSTNAME_LEN);
+            LOGE("parse header: domain name too long (%d >= %d)", name_len, MAX_HOSTNAME_LEN);
             return 0;
         }
 
@@ -219,7 +219,7 @@ parse_udprelay_header(const char *buf, const size_t buf_len,
                     memset(addr, 0, sizeof(*addr));
                     addr->sin_family = AF_INET;
                     if (inet_pton(AF_INET, tmp, &(addr->sin_addr)) <= 0) {
-                        LOGE("[udp] inet_pton failed for %s", tmp);
+                        LOGE("inet_pton failed for %s", tmp);
                     }
                     memcpy(&addr->sin_port, buf + offset + 1 + name_len, sizeof(uint16_t));
                 } else if (ip.version == 6) {
@@ -227,7 +227,7 @@ parse_udprelay_header(const char *buf, const size_t buf_len,
                     memset(addr6, 0, sizeof(*addr6));
                     addr6->sin6_family = AF_INET6;
                     if (inet_pton(AF_INET6, tmp, &(addr6->sin6_addr)) <= 0) {
-                        LOGE("[udp] inet_pton failed for %s", tmp);
+                        LOGE("inet_pton failed for %s", tmp);
                     }
                     memcpy(&addr6->sin6_port, buf + offset + 1 + name_len, sizeof(uint16_t));
                 } else {
@@ -250,7 +250,7 @@ parse_udprelay_header(const char *buf, const size_t buf_len,
         size_t in6_addr_len = sizeof(struct in6_addr);
         /* need: 1 (atyp) + in6_addr_len + 2 (port) */
         if (!REMAIN_AT_LEAST(in6_addr_len + 2)) {
-            LOGE("[udp] parse header: IPv6 header too short");
+            LOGE("parse header: IPv6 header too short");
             return 0;
         }
         if (storage != NULL) {
@@ -266,13 +266,13 @@ parse_udprelay_header(const char *buf, const size_t buf_len,
         }
         offset += in6_addr_len + 2;
     } else {
-        LOGE("[udp] parse header: unknown atyp %d", atyp);
+        LOGE("parse header: unknown atyp %d", atyp);
         return 0;
     }
 
     /* final sanity */
     if (offset <= 1 || (size_t)offset > buf_len) {
-        LOGE("[udp] invalid header parsing result (offset=%d, buf_len=%zu)", offset, buf_len);
+        LOGE("invalid header parsing result (offset=%d, buf_len=%zu)", offset, buf_len);
         return 0;
     }
 
diff --git a/src/plugin.c b/src/plugin.c
index 4dba96c..25d1cfc 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -162,7 +162,7 @@ start_obfsproxy(const char *plugin,
     if (plugin_opts != NULL) {
         opts_dump = strndup(plugin_opts, OBFSPROXY_OPTS_MAX);
         if (!opts_dump) {
-            ERROR("start_obfsproxy strndup failed");
+            ERROR("[plugin] start_obfsproxy strndup failed");
             if (env != NULL) {
                 cork_env_free(env);
             }
@@ -306,7 +306,7 @@ stop_plugin()
     if (sub != NULL) {
         cork_subprocess_abort(sub);
         if (cork_subprocess_wait(sub) == -1) {
-            LOGI("error on terminating the plugin.");
+            LOGI("[plugin] error on terminating the plugin.");
         }
         cork_subprocess_free(sub);
     }
diff --git a/src/redir.c b/src/redir.c
index b014518..52bc104 100644
--- a/src/redir.c
+++ b/src/redir.c
@@ -162,12 +162,12 @@ create_and_bind(const char *addr, const char *port, int af)
 
     s = getaddrinfo(addr, port, &hints, &result);
     if (s != 0) {
-        LOGI("getaddrinfo: %s", gai_strerror(s));
+        LOGI("[redir] getaddrinfo: %s", gai_strerror(s));
         return -1;
     }
 
     if (result == NULL) {
-        LOGE("Could not bind");
+        LOGE("[redir] Could not bind");
         return -1;
     }
 
@@ -189,7 +189,7 @@ create_and_bind(const char *addr, const char *port, int af)
         if (reuse_port) {
             int err = set_reuseport(listen_sock);
             if (err == 0) {
-                LOGI("tcp port reuse enabled");
+                LOGI("[redir] tcp port reuse enabled");
             }
         }
 
@@ -204,7 +204,7 @@ create_and_bind(const char *addr, const char *port, int af)
             }
 
             if (setsockopt(listen_sock, level, optname, &opt, sizeof(opt)) != 0) {
-                ERROR("setsockopt IP_TRANSPARENT");
+                ERROR("[redir] setsockopt IP_TRANSPARENT");
                 exit(EXIT_FAILURE);
             }
         }
@@ -255,7 +255,7 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
             // continue to wait for recv
             return;
         } else {
-            ERROR("server recv");
+            ERROR("[redir] server recv");
             close_and_free_remote(EV_A_ remote);
             close_and_free_server(EV_A_ server);
             return;
@@ -280,7 +280,7 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
             port = ntohs(sa->sin6_port);
         }
 
-        LOGI("redir to %s:%d, len=%zu, recv=%zd", ipstr, port, remote->buf->len, r);
+        LOGI("[redir] redir to %s:%d, len=%zu, recv=%zd", ipstr, port, remote->buf->len, r);
     }
 
     if (!remote->send_ctx->connected) {
@@ -292,7 +292,7 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
     int err = crypto->encrypt(remote->buf, server->e_ctx, SOCKET_BUF_SIZE);
 
     if (err) {
-        LOGE("invalid password or cipher");
+        LOGE("[redir] invalid password or cipher");
         close_and_free_remote(EV_A_ remote);
         close_and_free_server(EV_A_ server);
         return;
@@ -308,7 +308,7 @@ server_recv_cb(EV_P_ ev_io *w, int revents)
             ev_io_start(EV_A_ & remote->send_ctx->io);
             return;
         } else {
-            ERROR("send");
+            ERROR("[redir] send");
             close_and_free_remote(EV_A_ remote);
             close_and_free_server(EV_A_ server);
             return;
@@ -342,7 +342,7 @@ server_send_cb(EV_P_ ev_io *w, int revents)
                          server->buf->len, 0);
         if (s == -1) {
             if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("send");
+                ERROR("[redir] send");
                 close_and_free_remote(EV_A_ remote);
                 close_and_free_server(EV_A_ server);
             }
@@ -375,7 +375,7 @@ delayed_connect_cb(EV_P_ ev_timer *watcher, int revents)
     remote->addr = NULL;
 
     if (r == -1 && errno != CONNECT_IN_PROGRESS) {
-        ERROR("connect");
+        ERROR("[redir] connect");
         close_and_free_remote(EV_A_ remote);
         close_and_free_server(EV_A_ server);
         return;
@@ -425,7 +425,7 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
             // continue to wait for recv
             return;
         } else {
-            ERROR("remote recv");
+            ERROR("[redir] remote recv");
             close_and_free_remote(EV_A_ remote);
             close_and_free_server(EV_A_ server);
             return;
@@ -436,7 +436,7 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
 
     int err = crypto->decrypt(server->buf, server->d_ctx, SOCKET_BUF_SIZE);
     if (err == CRYPTO_ERROR) {
-        LOGE("invalid password or cipher");
+        LOGE("[redir] invalid password or cipher");
         close_and_free_remote(EV_A_ remote);
         close_and_free_server(EV_A_ server);
         return;
@@ -457,7 +457,7 @@ remote_recv_cb(EV_P_ ev_io *w, int revents)
             ev_io_stop(EV_A_ & remote_recv_ctx->io);
             ev_io_start(EV_A_ & server->send_ctx->io);
         } else {
-            ERROR("send");
+            ERROR("[redir] send");
             close_and_free_remote(EV_A_ remote);
             close_and_free_server(EV_A_ server);
             return;
@@ -510,7 +510,7 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
             // Construct address header directly into abuf
             int addr_len = construct_udprelay_header(&server->destaddr, abuf->data);
             if (addr_len == 0) {
-                LOGE("failed to construct address header");
+                LOGE("[redir] failed to construct address header");
                 bfree(abuf);
                 close_and_free_remote(EV_A_ remote);
                 close_and_free_server(EV_A_ server);
@@ -525,13 +525,13 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
             // Encrypt the combined buffer ([addr_header][payload]) once
             int err = crypto->encrypt(remote->buf, server->e_ctx, SOCKET_BUF_SIZE);
             if (err) {
-                LOGE("invalid password or cipher");
+                LOGE("[redir] invalid password or cipher");
                 close_and_free_remote(EV_A_ remote);
                 close_and_free_server(EV_A_ server);
                 return;
             }
         } else {
-            ERROR("getpeername");
+            ERROR("[redir] getpeername");
             // not connected
             handle_tcp_fail(EV_A_ server);
             return;
@@ -552,7 +552,7 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
             int optval = 1;
             if (setsockopt(remote->fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT,
                            (void *)&optval, sizeof(optval)) < 0)
-                FATAL("failed to set TCP_FASTOPEN_CONNECT");
+                FATAL("[redir] failed to set TCP_FASTOPEN_CONNECT");
             s = connect(remote->fd, remote->addr, get_sockaddr_len(remote->addr));
             if (s == 0)
                 s = send(remote->fd, remote->buf->data, remote->buf->len, 0);
@@ -561,7 +561,7 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
                        remote->buf->len, MSG_FASTOPEN, remote->addr,
                        get_sockaddr_len(remote->addr));
 #else
-            FATAL("tcp fast open is not supported on this platform");
+            FATAL("[redir] tcp fast open is not supported on this platform");
 #endif
 
             remote->addr = NULL;
@@ -574,9 +574,9 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
                     if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
                         errno == ENOPROTOOPT) {
                         fast_open = 0;
-                        LOGE("fast open is not supported on this platform");
+                        LOGE("[redir] fast open is not supported on this platform");
                     } else {
-                        ERROR("fast_open_connect");
+                        ERROR("[redir] fast_open_connect");
                     }
                     handle_tcp_fail(EV_A_ server);
                 }
@@ -589,7 +589,7 @@ remote_send_cb(EV_P_ ev_io *w, int revents)
 
         if (s == -1) {
             if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("send");
+                ERROR("[redir] send");
                 /* close current remote and try next */
                 handle_tcp_fail(EV_A_ server);
             }
@@ -741,19 +741,17 @@ handle_tcp_fail(EV_P_ server_t *server)
     }
 
     if (server->listener) {
-        if (verbose) {
-            LOGI("tcp: handling failure for remote index %d", server->remote_idx);
-        }
         const char *addr_str = get_addr_str(server->listener->remote_addr[server->remote_idx], true);
         metrics_inc_remote_tcp_failures_total(server->remote_idx, addr_str);
     }
 
     /*
-     * Do not failover to the next remote on connection failure.
-     * The probing mechanism is now solely responsible for managing remote status.
-     * We just close the server connection and let the client retry.
-     */
-    LOGE("TCP connection to remote %d failed, closing connection.", server->remote_idx);
+    * Do not failover to the next remote on connection failure.
+    * The probing mechanism is now solely responsible for managing remote status.
+    * We just close the server connection and let the client retry.
+    */
+    LOGE("[redir] TCP connection to remote %d failed, closing connection.", server->remote_idx);
+
     close_and_free_server(EV_A_ server);
 }
 
@@ -763,18 +761,16 @@ start_connect_remote(EV_P_ server_t *server)
     listen_ctx_t *listener = server->listener;
 
     if (server->remote_idx >= listener->remote_num) {
-        LOGE("all remote servers failed to connect");
+        LOGE("[redir] all remote servers failed to connect");
         handle_tcp_fail(EV_A_ server);
         return;
     }
 
     struct sockaddr *remote_addr = listener->remote_addr[server->remote_idx];
     const char *addr_str = get_addr_str(remote_addr, true);
-
     if (verbose) {
-        LOGI("tcp: attempting to connect to remote %d at %s", server->remote_idx, addr_str);
+        LOGI("[redir] tcp: attempting to connect to remote %d at %s", server->remote_idx, addr_str);
     }
-
     metrics_inc_remote_tcp_connections_total(server->remote_idx, addr_str);
 
     int protocol = IPPROTO_TCP;
@@ -783,7 +779,7 @@ start_connect_remote(EV_P_ server_t *server)
     }
     int remotefd = socket(remote_addr->sa_family, SOCK_STREAM, protocol);
     if (remotefd == -1) {
-        ERROR("[tcp] socket");
+        ERROR("[redir] tcp: socket");
         handle_tcp_fail(EV_A_ server);
         return;
     }
@@ -811,12 +807,12 @@ start_connect_remote(EV_P_ server_t *server)
     if (listener->tos >= 0) {
         int rc = setsockopt(remotefd, IPPROTO_IP, IP_TOS, &listener->tos, sizeof(listener->tos));
         if (rc < 0 && errno != ENOPROTOOPT) {
-            LOGE("setting ipv4 dscp failed: %d", errno);
+            ERROR("[redir] setting ipv4 dscp failed");
         }
 #ifdef IPV6_TCLASS
         rc = setsockopt(remotefd, IPPROTO_IPV6, IPV6_TCLASS, &listener->tos, sizeof(listener->tos));
         if (rc < 0 && errno != ENOPROTOOPT) {
-            LOGE("setting ipv6 dscp failed: %d", errno);
+            ERROR("[redir] setting ipv6 dscp failed");
         }
 #endif
     }
@@ -825,7 +821,7 @@ start_connect_remote(EV_P_ server_t *server)
     if (listener->mptcp > 1) {
         int err = setsockopt(remotefd, SOL_TCP, listener->mptcp, &opt, sizeof(opt));
         if (err == -1) {
-            ERROR("[tcp] failed to enable out-of-tree multipath TCP");
+            ERROR("[redir] failed to enable out-of-tree multipath TCP");
         }
     } else if (listener->mptcp == 1) {
         int i = 0;
@@ -837,7 +833,7 @@ start_connect_remote(EV_P_ server_t *server)
             i++;
         }
         if (listener->mptcp == 0) {
-            ERROR("[tcp] failed to enable out-of-tree multipath TCP");
+            ERROR("[redir] failed to enable out-of-tree multipath TCP");
         }
     }
 
@@ -852,7 +848,7 @@ start_connect_remote(EV_P_ server_t *server)
 #ifdef SO_MARK
     if (fwmark > 0) {
         if (setsockopt(remotefd, SOL_SOCKET, SO_MARK, &fwmark, sizeof(fwmark)) != 0) {
-            ERROR("setsockopt SO_MARK");
+            ERROR("[redir] setsockopt SO_MARK");
         }
     }
 #endif
@@ -863,7 +859,7 @@ start_connect_remote(EV_P_ server_t *server)
 
     if (fast_open) {
         if (verbose) {
-            LOGI("tcp: using TCP Fast Open for remote connection");
+            LOGI("[redir] tcp: using TCP Fast Open for remote connection");
         }
         /* save remote addr for fast open */
         remote->addr = remote_addr;
@@ -872,12 +868,12 @@ start_connect_remote(EV_P_ server_t *server)
         int r = connect(remotefd, remote_addr, get_sockaddr_len(remote_addr));
 
         if (r == -1 && errno != CONNECT_IN_PROGRESS) {
-            ERROR("[tcp] connect");
+            ERROR("[redir] tcp: connect");
             handle_tcp_fail(EV_A_ server);
             return;
         }
         if (verbose) {
-            LOGI("tcp: connect() issued for remote fd %d", remotefd);
+            LOGI("[redir] tcp: connect() issued for remote fd %d", remotefd);
         }
         /* listen to remote connected event */
         ev_io_start(EV_A_ & remote->send_ctx->io);
@@ -897,7 +893,7 @@ accept_cb(EV_P_ ev_io *w, int revents)
 
     int serverfd = accept(listener->fd, NULL, NULL);
     if (serverfd == -1) {
-        ERROR("[tcp] accept");
+        ERROR("[redir] tcp: accept");
         return;
     }
 
@@ -925,9 +921,6 @@ accept_cb(EV_P_ ev_io *w, int revents)
 
     server_t *server = new_server(serverfd);
     server->destaddr = destaddr;
-    if (verbose) {
-        LOGI("tcp: created server context for fd %d", serverfd);
-    }
 
     /* associate with listener and find first available remote */
     server->listener = listener;
@@ -941,20 +934,21 @@ accept_cb(EV_P_ ev_io *w, int revents)
         }
     }
     if (start_idx == -1) {
-        LOGE("tcp: no remote servers available for fd %d, dropping connection.", serverfd);
+        LOGE("[redir] tcp: no remote servers available for fd %d, dropping connection.", serverfd);
         close(serverfd);
         free_server(server);
         return;
     }
-
     server->remote_idx = start_idx;
 
-   if (verbose) {
-        LOGI("tcp: starting to connect remote for fd %d", serverfd);
-    }
     metrics_inc_tcp_connections();
     metrics_inc_tcp_connections_total();
     metrics_inc_remote_tcp_connections(server->remote_idx, get_addr_str(listener->remote_addr[server->remote_idx], true));
+
+    if (verbose) {
+        LOGI("[redir] tcp: starting to connect remote for fd %d", serverfd);
+    }
+
     start_connect_remote(EV_A_ server);
 }
 
@@ -965,7 +959,7 @@ signal_cb(EV_P_ ev_signal *w, int revents)
         switch (w->signum) {
         case SIGCHLD:
             if (!is_plugin_running()) {
-                LOGE("plugin service exit unexpectedly");
+                LOGE("[redir] plugin service exit unexpectedly");
                 ret_val = -1;
             } else
                 return;
@@ -1172,11 +1166,11 @@ main(int argc, char **argv)
             ipv6first = 1;
             break;
         case 'A':
-            FATAL("One time auth has been deprecated. Try AEAD ciphers instead.");
+            FATAL("[redir] One time auth has been deprecated. Try AEAD ciphers instead.");
             break;
         case '?':
             // The option character is not recognized.
-            LOGE("Unrecognized option: %s", optarg);
+            LOGE("[redir] Unrecognized option: %s", optarg);
             opterr = 1;
             break;
         }
@@ -1305,7 +1299,7 @@ main(int argc, char **argv)
     if (plugin != NULL) {
         uint16_t port = get_local_port();
         if (port == 0) {
-            FATAL("failed to find a free port");
+            FATAL("[redir] failed to find a free port");
         }
         snprintf(tmp_port, 8, "%d", port);
         if (is_ipv6only(remote_addr, remote_num, ipv6first)) {
@@ -1315,7 +1309,7 @@ main(int argc, char **argv)
         }
         plugin_port = tmp_port;
 
-        LOGI("plugin \"%s\" enabled", plugin);
+        LOGI("[redir] plugin \"%s\" enabled", plugin);
     }
 
     if (method == NULL) {
@@ -1333,7 +1327,7 @@ main(int argc, char **argv)
      */
     if (nofile > 1024) {
         if (verbose) {
-            LOGI("setting NOFILE to %d", nofile);
+            LOGI("[redir] setting NOFILE to %d", nofile);
         }
         set_nofile(nofile);
     }
@@ -1341,9 +1335,9 @@ main(int argc, char **argv)
 
     if (fast_open == 1) {
 #ifdef TCP_FASTOPEN
-        LOGI("using tcp fast open");
+        LOGI("[redir] using tcp fast open");
 #else
-        LOGE("tcp fast open is not supported by this environment");
+        LOGE("[redir] tcp fast open is not supported by this environment");
         fast_open = 0;
 #endif
     }
@@ -1354,11 +1348,11 @@ main(int argc, char **argv)
     }
 
     if (no_delay) {
-        LOGI("enable TCP no-delay");
+        LOGI("[redir] enable TCP no-delay");
     }
 
     if (ipv6first) {
-        LOGI("resolving hostname to IPv6 address first");
+        LOGI("[redir] resolving hostname to IPv6 address first");
     }
 
     if (mptcp != 0){
@@ -1366,15 +1360,15 @@ main(int argc, char **argv)
     }
 
     if (mtu > 0) {
-        LOGI("set MTU to %d", mtu);
+        LOGI("[redir] set MTU to %d", mtu);
     }
 
     if (timeout) {
-        LOGI("set timeout to %s", timeout);
+        LOGI("[redir] set timeout to %s", timeout);
     }
 
     if (fwmark > 0) {
-        LOGI("set fwmark to %d", fwmark);
+        LOGI("[redir] set fwmark to %d", fwmark);
     }
 
     if (tcp_incoming_sndbuf != 0 && tcp_incoming_sndbuf < SOCKET_BUF_SIZE) {
@@ -1382,7 +1376,7 @@ main(int argc, char **argv)
     }
 
     if (tcp_incoming_sndbuf != 0) {
-        LOGI("set TCP incoming connection send buffer size to %d", tcp_incoming_sndbuf);
+        LOGI("[redir] set TCP incoming connection send buffer size to %d", tcp_incoming_sndbuf);
     }
 
     if (tcp_incoming_rcvbuf != 0 && tcp_incoming_rcvbuf < SOCKET_BUF_SIZE) {
@@ -1390,7 +1384,7 @@ main(int argc, char **argv)
     }
 
     if (tcp_incoming_rcvbuf != 0) {
-        LOGI("set TCP incoming connection receive buffer size to %d", tcp_incoming_rcvbuf);
+        LOGI("[redir] set TCP incoming connection receive buffer size to %d", tcp_incoming_rcvbuf);
     }
 
     if (tcp_outgoing_sndbuf != 0 && tcp_outgoing_sndbuf < SOCKET_BUF_SIZE) {
@@ -1398,7 +1392,7 @@ main(int argc, char **argv)
     }
 
     if (tcp_outgoing_sndbuf != 0) {
-        LOGI("set TCP outgoing connection send buffer size to %d", tcp_outgoing_sndbuf);
+        LOGI("[redir] set TCP outgoing connection send buffer size to %d", tcp_outgoing_sndbuf);
     }
 
     if (tcp_outgoing_rcvbuf != 0 && tcp_outgoing_rcvbuf < SOCKET_BUF_SIZE) {
@@ -1406,7 +1400,7 @@ main(int argc, char **argv)
     }
 
     if (tcp_outgoing_rcvbuf != 0) {
-        LOGI("set TCP outgoing connection receive buffer size to %d", tcp_outgoing_rcvbuf);
+        LOGI("[redir] set TCP outgoing connection receive buffer size to %d", tcp_outgoing_rcvbuf);
     }
 
     if (probe_interval <= 0) {
@@ -1442,7 +1436,7 @@ main(int argc, char **argv)
         int err = start_plugin(plugin, plugin_opts, remote_str,
                                remote_port, plugin_host, plugin_port, MODE_CLIENT);
         if (err) {
-            FATAL("failed to start the plugin");
+            FATAL("[redir] failed to start the plugin");
         }
     }
 
@@ -1467,10 +1461,11 @@ main(int argc, char **argv)
         metrics_init(EV_A_ metrics_addr, metrics_port, remote_num, start_time);
     }
 
-    LOGI("initializing ciphers... %s", method);
+    LOGI("[redir] initializing ciphers... %s", method);
     crypto = crypto_init(password, key, method);
-    if (crypto == NULL)
-        FATAL("failed to initialize ciphers");
+    if (crypto == NULL) {
+        FATAL("[redir] failed to initialize ciphers");
+    }
 
     /* Setup proxy context */
     struct listen_ctx listen_ctx;
@@ -1492,7 +1487,7 @@ main(int argc, char **argv)
         struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
         memset(storage, 0, sizeof(struct sockaddr_storage));
         if (get_sockaddr(host, port, storage, 1, ipv6first) == -1) {
-            FATAL("failed to resolve the provided hostname");
+            FATAL("[redir] failed to resolve the provided hostname");
         }
         listen_ctx.remote_addr[i] = (struct sockaddr *)storage;
 
@@ -1522,15 +1517,15 @@ main(int argc, char **argv)
         do {
             listen_ctx_current->local_port = local_port;
             if (listen_ctx_current->tos) {
-                LOGI("listening at %s:%s (TOS 0x%x)", local_addr, local_port, listen_ctx_current->tos);
+                LOGI("[redir] listening at %s:%s (TOS 0x%x)", local_addr, local_port, listen_ctx_current->tos);
             } else {
-                LOGI("listening at %s:%s", local_addr, local_port);
+                LOGI("[redir] listening at %s:%s", local_addr, local_port);
             }
 
             if (listen_ctx_count < MAX_LISTEN_CTX) {
                 listen_ctx_list[listen_ctx_count++] = listen_ctx_current;
             } else {
-                LOGE("too many listen ctx; increase MAX_LISTEN_CTX");
+                LOGE("[redir] too many listen ctx; increase MAX_LISTEN_CTX");
             }
 
             /* Handle additional TOS/DSCP listening ports */
@@ -1558,16 +1553,16 @@ main(int argc, char **argv)
         }
     } else {
         /* free listen_ctx if only UDP is enabled */
-        LOGI("TCP relay disabled");
+        LOGI("[redir] TCP relay disabled");
     }
 
     /* setuid */
     if (user != NULL && !run_as(user)) {
-        FATAL("failed to switch user");
+        FATAL("[redir] failed to switch user");
     }
 
     if (geteuid() == 0) {
-        LOGI("running from root user");
+        LOGI("[redir] running from root user");
     }
 
     ev_run(loop, 0);
diff --git a/src/stream.c b/src/stream.c
index 1f4d06a..d803452 100644
--- a/src/stream.c
+++ b/src/stream.c
@@ -172,7 +172,7 @@ const cipher_kt_t *
 stream_get_cipher_type(int method)
 {
     if (method <= TABLE || method >= STREAM_CIPHER_NUM) {
-        LOGE("stream_get_cipher_type(): Illegal method");
+        LOGE("[stream] stream_get_cipher_type(): Illegal method");
         return NULL;
     }
 
@@ -187,7 +187,7 @@ stream_get_cipher_type(int method)
     const char *ciphername  = supported_stream_ciphers[method];
     const char *mbedtlsname = supported_stream_ciphers_mbedtls[method];
     if (strcmp(mbedtlsname, CIPHER_UNSUPPORTED) == 0) {
-        LOGE("Cipher %s currently is not supported by mbed TLS library",
+        LOGE("[stream] cipher %s currently is not supported by mbed TLS library",
              ciphername);
         return NULL;
     }
@@ -198,7 +198,7 @@ void
 stream_cipher_ctx_init(cipher_ctx_t *ctx, int method, int enc)
 {
     if (method <= TABLE || method >= STREAM_CIPHER_NUM) {
-        LOGE("stream_ctx_init(): Illegal method");
+        LOGE("[stream] stream_ctx_init(): Illegal method");
         return;
     }
 
@@ -214,12 +214,12 @@ stream_cipher_ctx_init(cipher_ctx_t *ctx, int method, int enc)
     cipher_evp_t *evp = ctx->evp;
 
     if (cipher == NULL) {
-        LOGE("Cipher %s not found in mbed TLS library", ciphername);
-        FATAL("Cannot initialize mbed TLS cipher");
+        LOGE("[stream] cipher %s not found in mbed TLS library", ciphername);
+        FATAL("[stream] cannot initialize mbed TLS cipher");
     }
     mbedtls_cipher_init(evp);
     if (mbedtls_cipher_setup(evp, cipher) != 0) {
-        FATAL("Cannot initialize mbed TLS cipher context");
+        FATAL("[stream] cannot initialize mbed TLS cipher context");
     }
 }
 
@@ -249,7 +249,7 @@ cipher_ctx_set_nonce(cipher_ctx_t *cipher_ctx, uint8_t *nonce, size_t nonce_len,
     cipher_t *cipher = cipher_ctx->cipher;
 
     if (nonce == NULL) {
-        LOGE("cipher_ctx_set_nonce(): NONCE is null");
+        LOGE("[stream] cipher_ctx_set_nonce(): NONCE is null");
         return;
     }
 
@@ -269,20 +269,20 @@ cipher_ctx_set_nonce(cipher_ctx_t *cipher_ctx, uint8_t *nonce, size_t nonce_len,
 
     cipher_evp_t *evp = cipher_ctx->evp;
     if (evp == NULL) {
-        LOGE("cipher_ctx_set_nonce(): Cipher context is null");
+        LOGE("[stream] cipher_ctx_set_nonce(): Cipher context is null");
         return;
     }
     if (mbedtls_cipher_setkey(evp, true_key, cipher->key_len * 8, enc) != 0) {
         mbedtls_cipher_free(evp);
-        FATAL("Cannot set mbed TLS cipher key");
+        FATAL("[stream] cannot set mbed TLS cipher key");
     }
     if (mbedtls_cipher_set_iv(evp, nonce, nonce_len) != 0) {
         mbedtls_cipher_free(evp);
-        FATAL("Cannot set mbed TLS cipher NONCE");
+        FATAL("[stream] cannot set mbed TLS cipher NONCE");
     }
     if (mbedtls_cipher_reset(evp) != 0) {
         mbedtls_cipher_free(evp);
-        FATAL("Cannot finalize mbed TLS cipher context");
+        FATAL("[stream] cannot finalize mbed TLS cipher context");
     }
 
 #ifdef SS_DEBUG
@@ -437,7 +437,7 @@ stream_decrypt_all(buffer_t *ciphertext, cipher_t *cipher, size_t capacity)
     memcpy(nonce, ciphertext->data, nonce_len);
 
     if (ppbloom_check((void *)nonce, nonce_len) == 1) {
-        LOGE("crypto: stream: repeat IV detected");
+        LOGE("[stream] crypto: stream: repeat IV detected");
         return CRYPTO_ERROR;
     }
 
@@ -522,7 +522,7 @@ stream_decrypt(buffer_t *ciphertext, cipher_ctx_t *cipher_ctx, size_t capacity)
 
         if (cipher->method >= RC4_MD5) {
             if (ppbloom_check((void *)nonce, nonce_len) == 1) {
-                LOGE("crypto: stream: repeat IV detected");
+                LOGE("[stream] crypto: stream: repeat IV detected");
                 return CRYPTO_ERROR;
             }
         }
@@ -569,7 +569,7 @@ stream_decrypt(buffer_t *ciphertext, cipher_ctx_t *cipher_ctx, size_t capacity)
     if (cipher_ctx->init == 1) {
         if (cipher->method >= RC4_MD5) {
             if (ppbloom_check((void *)cipher_ctx->nonce, cipher->nonce_len) == 1) {
-                LOGE("crypto: stream: repeat IV detected");
+                LOGE("[stream] crypto: stream: repeat IV detected");
                 return CRYPTO_ERROR;
             }
             ppbloom_add((void *)cipher_ctx->nonce, cipher->nonce_len);
@@ -600,7 +600,7 @@ cipher_t *
 stream_key_init(int method, const char *pass, const char *key)
 {
     if (method <= TABLE || method >= STREAM_CIPHER_NUM) {
-        LOGE("cipher->key_init(): Illegal method");
+        LOGE("[stream] cipher->key_init(): Illegal method");
         return NULL;
     }
 
@@ -608,8 +608,8 @@ stream_key_init(int method, const char *pass, const char *key)
     memset(cipher, 0, sizeof(cipher_t));
 
     if (method < SALSA20 && stream_get_cipher_type(method) == NULL) {
-        LOGE("Cipher %s not found in crypto library", supported_stream_ciphers[method]);
-        FATAL("Cannot initialize cipher");
+        LOGE("[stream] cipher %s not found in crypto library", supported_stream_ciphers[method]);
+        FATAL("[stream] cannot initialize cipher");
     }
 
     if (key != NULL)
@@ -620,7 +620,7 @@ stream_key_init(int method, const char *pass, const char *key)
                                             supported_stream_ciphers_key_size[method]);
 
     if (cipher->key_len == 0) {
-        FATAL("Cannot generate key and NONCE");
+        FATAL("[stream] cannot generate key and NONCE");
     }
     cipher->nonce_len = supported_stream_ciphers_nonce_size[method];
     cipher->method = method;
@@ -638,12 +638,12 @@ stream_init(const char *pass, const char *key, const char *method)
                 break;
             }
         if (m >= STREAM_CIPHER_NUM) {
-            LOGE("Invalid cipher name: %s, use chacha20-ietf instead", method);
+            LOGE("[stream] invalid cipher name: %s, use chacha20-ietf instead", method);
             m = CHACHA20IETF;
         }
     }
     if (m == TABLE) {
-        LOGE("Table is deprecated");
+        LOGE("[stream] table is deprecated");
         return NULL;
     }
     return stream_key_init(m, pass, key);
diff --git a/src/udprelay.c b/src/udprelay.c
index 98d80e8..81a607c 100644
--- a/src/udprelay.c
+++ b/src/udprelay.c
@@ -438,10 +438,10 @@ remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
 
     if (remote_ctx->state == STATE_AWAITING_REPLY) {
         const char *addr_str = get_addr_str(server_ctx->remote_addr[remote_ctx->remote_idx], true);
-        LOGI("[udprelay] session timed out for remote %d (%s) waiting for reply.", remote_ctx->remote_idx, addr_str);
+        LOGI("[udp] session timed out for remote %d (%s) waiting for reply.", remote_ctx->remote_idx, addr_str);
         metrics_inc_remote_udp_session_timeouts_total(remote_ctx->remote_idx, addr_str);
     } else {
-        if (verbose) LOGI("[udp] idle session timed out.");
+        if (verbose) LOGI("[udp] idle session timed out for remote %d.", remote_ctx->remote_idx);
     }
 
     if (verbose) {
diff --git a/src/utils.c b/src/utils.c
index 6862058..0113d37 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -143,22 +143,20 @@ run_as(const char *user)
             if (err == 0 && pwd) {
                 /* setgid first, because we may not be allowed to do it anymore after setuid */
                 if (setgid(pwd->pw_gid) != 0) {
-                    LOGE(
-                        "Could not change group id to that of run_as user '%s': %s",
+                    LOGE("could not change group id to that of run_as user '%s': %s",
                         pwd->pw_name, strerror(errno));
                     return 0;
                 }
 
 #ifndef __CYGWIN__
                 if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {
-                    LOGE("Could not change supplementary groups for user '%s'.", pwd->pw_name);
+                    LOGE("could not change supplementary groups for user '%s'.", pwd->pw_name);
                     return 0;
                 }
 #endif
 
                 if (setuid(pwd->pw_uid) != 0) {
-                    LOGE(
-                        "Could not change user id to that of run_as user '%s': %s",
+                    LOGE("could not change user id to that of run_as user '%s': %s",
                         pwd->pw_name, strerror(errno));
                     return 0;
                 }
@@ -174,8 +172,7 @@ run_as(const char *user)
             } else if (buflen >= 16 * 1024) {
                 /* If getpwnam_r() seems defective, call it quits rather than
                  * keep on allocating ever larger buffers until we crash. */
-                LOGE(
-                    "getpwnam_r() requires more than %u bytes of buffer space.",
+                LOGE("getpwnam_r() requires more than %u bytes of buffer space.",
                     (unsigned)buflen);
                 return 0;
             }
@@ -196,7 +193,7 @@ run_as(const char *user)
             return 0;
         }
         if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {
-            LOGE("Could not change supplementary groups for user '%s'.", pwd->pw_name);
+            LOGE("could not change supplementary groups for user '%s'.", pwd->pw_name);
             return 0;
         }
         if (setuid(pwd->pw_uid) != 0) {
@@ -464,14 +461,13 @@ set_nofile(int nofile)
 
     if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
         if (errno == EPERM) {
-            LOGE(
-                "insufficient permission to change NOFILE, not starting as root?");
+            LOGE("insufficient permission to change NOFILE, not starting as root?");
             return -1;
         } else if (errno == EINVAL) {
             LOGE("invalid nofile, decrease nofile and try again");
             return -1;
         } else {
-            LOGE("setrlimit failed: %s", strerror(errno));
+            ERROR("setrlimit failed");
             return -1;
         }
     }
-- 
2.37.1 (Apple Git-137.1)

